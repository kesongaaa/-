<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Racer: Curve Drift (WebGL + MediaPipe)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* UI 容器 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* 顶部状态栏 */
        .top-bar {
            padding: 20px;
            display: flex; justify-content: space-between; align-items: flex-start;
        }

        .status-box {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffcc;
            padding: 10px 20px;
            border-radius: 4px;
            color: #fff;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.2);
        }

        .cam-preview {
            width: 160px; height: 120px;
            border: 2px solid #ff00cc;
            background: #111;
            border-radius: 8px;
            overflow: hidden;
            transform: scaleX(-1); /* 镜像 */
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }

        /* 底部仪表盘 */
        .bottom-bar {
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .speedometer {
            display: inline-block;
            position: relative;
        }
        .speed-val {
            font-size: 80px; font-weight: 900; font-style: italic;
            background: linear-gradient(to bottom, #fff, #00ffcc);
            -webkit-background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
        }
        .speed-unit {
            font-size: 20px; color: #aaa; letter-spacing: 2px;
        }

        /* 引导文字 */
        .guide-text {
            position: absolute; bottom: 30px; right: 30px;
            text-align: right; color: rgba(255, 255, 255, 0.6);
            font-size: 14px; line-height: 1.5;
        }
        .highlight { color: #ff00cc; font-weight: bold; }

        /* 加载层 */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #00ffcc; transition: opacity 0.5s;
        }
        .loader-ring {
            width: 60px; height: 60px; border: 4px solid #333;
            border-top: 4px solid #ff00cc; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>

    <!-- 依赖库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="loader-ring"></div>
        <h3 id="load-msg">启动引擎中...</h3>
        <p>请授权摄像头以启用 AI 驾驶</p>
    </div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="status-box">
                <div>AI 状态: <span id="ai-status" style="color:yellow">初始化...</span></div>
                <div>输入模式: <span id="input-mode">检测中...</span></div>
            </div>
            <div class="cam-preview">
                <video id="input_video" autoplay playsinline muted></video>
            </div>
        </div>

        <div class="bottom-bar">
            <div class="speedometer">
                <div class="speed-val" id="speed-display">0</div>
                <div class="speed-unit">KM/H</div>
            </div>
            <div class="guide-text">
                <p>✋ <span class="highlight">单手操控</span>：左倾=左转 / 右倾=右转</p>
                <p>⌨️ <span class="highlight">备用键盘</span>：方向键左右</p>
            </div>
        </div>
    </div>

<script>
/**
 * ==========================================
 * 全局配置 (Tweakable)
 * ==========================================
 */
const CONFIG = {
    // 物理参数
    maxSpeed: 320,          // 最大显示速度
    accel: 0.8,             // 加速度
    decel: 0.3,             // 转向/摩擦减速
    turnSensitivity: 1.2,   // 转向灵敏度 (横向移动速度)
    maxRoadWidth: 12,       // 赛道半宽 (限制玩家不出界)
    
    // 视觉参数
    camHeight: 2.5,         // 相机高度
    camLookAhead: 30,       // 相机看向前方多少米 (决定过弯视线)
    fovBase: 80,            // 静止 FOV
    fovMax: 110,            // 极速 FOV
    fogDensity: 0.015,      // 雾浓度
    
    // 场景生成
    segmentLength: 5,       // 每个路段长度
    drawDistance: 300,      // 可视距离
    curveAmp: 60,           // 弯道幅度
    curveFreq: 0.002        // 弯道频率
};

// 运行时状态
const STATE = {
    speed: 0,           // 逻辑速度 (0-100)
    distance: 0,        // 总行驶距离 (虚拟 Z 轴)
    playerX: 0,         // 玩家在赛道上的横向偏移 (-RoadWidth ~ +RoadWidth)
    steerVal: 0,        // 当前转向输入 (-1 ~ 1)
    isAiActive: false   // AI 是否接管
};

// 资源容器
let scene, camera, renderer;
const roadSegments = [];    // 路段池
const debrisParticles = []; // 速度线粒子
let trackFunction;          // 赛道曲线函数

/**
 * ==========================================
 * 核心：数学与赛道曲线生成
 * ==========================================
 */

// 赛道中心线函数：输入 Z (距离)，返回 X (弯道偏移)
// 使用两个正弦波叠加，制造不规则的 S 弯
trackFunction = function(z) {
    return Math.sin(z * CONFIG.curveFreq) * CONFIG.curveAmp + 
           Math.sin(z * CONFIG.curveFreq * 2.5) * (CONFIG.curveAmp / 4);
};

// 获取某一点的切线角度 (用于物体旋转)
function getTrackDerivative(z) {
    const delta = 0.1;
    const x1 = trackFunction(z);
    const x2 = trackFunction(z + delta);
    return Math.atan2(x2 - x1, delta);
}

/**
 * ==========================================
 * 1. Three.js 场景初始化
 * ==========================================
 */
function initThree() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050011);
    scene.fog = new THREE.FogExp2(0x050011, CONFIG.fogDensity);

    camera = new THREE.PerspectiveCamera(CONFIG.fovBase, window.innerWidth/window.innerHeight, 0.1, 500);

    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // 限制像素比以保证性能
    document.body.appendChild(renderer.domElement);

    // 灯光
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);
    
    // 车头灯 (模拟)
    const carLight = new THREE.PointLight(0x00ffff, 1, 50);
    carLight.position.set(0, 2, 0);
    scene.add(carLight); // 这个灯会跟随摄像机组

    // 初始化路段池
    initRoadSegments();
    
    // 初始化速度线粒子
    initDebris();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

/**
 * 核心技巧：路段池系统
 * 我们不创建无限长的几何体，而是创建 ~60 个路段，循环使用。
 */
function initRoadSegments() {
    // 纹理生成 (无需外部图片)
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    // 沥青底色
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0,0,512,512);
    // 杂点
    ctx.fillStyle = '#333'; 
    for(let i=0;i<1000;i++) ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
    // 边缘红白路肩
    ctx.fillStyle = '#ff0044'; ctx.fillRect(0,0,30,256); ctx.fillRect(482,0,30,256);
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,256,30,256); ctx.fillRect(482,256,30,256);
    // 中间车道线
    ctx.fillStyle = '#ffffff'; ctx.fillRect(250, 100, 12, 100); ctx.fillRect(250, 356, 12, 100);

    const roadTex = new THREE.CanvasTexture(canvas);
    roadTex.anisotropy = 16; // 这种视角需要各向异性过滤

    const geo = new THREE.PlaneGeometry(30, CONFIG.segmentLength);
    const mat = new THREE.MeshStandardMaterial({ 
        map: roadTex, 
        roughness: 0.6,
        color: 0xaaaaaa
    });
    
    // 路边物体几何体 (复用)
    const poleGeo = new THREE.BoxGeometry(0.5, 8, 0.5);
    const poleMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc }); // 霓虹蓝

    const segmentsCount = Math.ceil(CONFIG.drawDistance / CONFIG.segmentLength) + 5;

    for (let i = 0; i < segmentsCount; i++) {
        // 创建组，包含路面和路边物体
        const group = new THREE.Group();
        
        // 路面
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI / 2;
        // 接收阴影/光照
        group.add(mesh);

        // 路边霓虹柱 (随机出现)
        if (i % 2 === 0) {
            const leftPole = new THREE.Mesh(poleGeo, poleMat);
            leftPole.position.set(-16, 4, 0); // 路宽之外
            group.add(leftPole);

            const rightPole = new THREE.Mesh(poleGeo, poleMat);
            rightPole.position.set(16, 4, 0);
            group.add(rightPole);
        }

        scene.add(group);
        roadSegments.push(group);
    }
}

function initDebris() {
    const geo = new THREE.BufferGeometry();
    const count = 200;
    const positions = new Float32Array(count * 3);
    for(let i=0; i<count; i++) {
        positions[i*3] = (Math.random() - 0.5) * 100;
        positions[i*3+1] = Math.random() * 20; // 高度
        positions[i*3+2] = Math.random() * -200;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.5 });
    const points = new THREE.Points(geo, mat);
    scene.add(points);
    debrisParticles.push(points);
}


/**
 * ==========================================
 * 2. 游戏逻辑循环
 * ==========================================
 */

function updatePhysics() {
    // 加速与阻力
    if (STATE.speed < 100) STATE.speed += CONFIG.accel;
    
    // 转向时的阻力
    if (Math.abs(STATE.steerVal) > 0.1) {
        STATE.speed -= CONFIG.decel * Math.abs(STATE.steerVal);
    }
    STATE.speed = Math.max(0, STATE.speed);

    // 实际移动距离 (每帧前进量)
    const moveStep = (STATE.speed / 100) * 1.5; // 系数调整速度感
    STATE.distance += moveStep;

    // 玩家横向移动
    // 只有在动的时候才能转向
    if (moveStep > 0.1) {
        // steerVal: -1 (Left) to 1 (Right)
        // 增加 CONFIG.turnSensitivity
        STATE.playerX += STATE.steerVal * CONFIG.turnSensitivity * (STATE.speed / 50);
        
        // 限制在路面上
        if (STATE.playerX > CONFIG.maxRoadWidth) STATE.playerX = CONFIG.maxRoadWidth;
        if (STATE.playerX < -CONFIG.maxRoadWidth) STATE.playerX = -CONFIG.maxRoadWidth;
    }
}

function updateScene() {
    // 1. 确定摄像机在赛道上的基础位置 (Z)
    const camZ = STATE.distance;
    
    // 2. 计算摄像机当前的 X 位置 (基于赛道曲线 + 玩家偏移)
    const trackCenterX = trackFunction(camZ);
    const camX = trackCenterX + STATE.playerX;

    // 3. 设置摄像机位置
    camera.position.x = camX;
    camera.position.y = CONFIG.camHeight + (Math.random()-0.5) * (STATE.speed/400); // 震动
    camera.position.z = -10; // 这里的 Z 实际上是相对 View 的，我们不动 Camera Z，而是动世界

    // 核心技巧：我们不移动 Camera 的 Z 轴到无限远，那样会精度溢出。
    // 相反，我们让 Camera Z 保持在 0 附近，
    // 而根据 (currentZ + relativeOffset) 来计算路段的 X 偏移。
    // 但是为了方便理解，这里我们采用 "Camera Z 不动，物体 Z 向后跑" 的逻辑。
    
    // 修正：为了配合 LookAt 逻辑，采用 "虚拟Z" 比较好算，
    // 我们让物体根据 (segmentIndex * length - distance) 来放置。

    const totalSegmentsLength = roadSegments.length * CONFIG.segmentLength;

    // 4. 更新路段
    roadSegments.forEach((seg, index) => {
        // 计算该路段在世界中的绝对 Z 索引
        // 比如 distance = 100, segLen = 5. 
        // 此时应该显示 distance 前方的路段。
        
        // 基础 Z 位置
        let segZ = index * CONFIG.segmentLength;
        
        // 循环滚动逻辑：如果路段跑到了摄像机后面太远，就把它移到最前方
        // 相对摄像机的距离
        let relZ = segZ - STATE.distance;
        
        // 修正模运算，处理循环
        while (relZ < -10) { 
            relZ += totalSegmentsLength; 
        }
        while (relZ > totalSegmentsLength - 10) {
            relZ -= totalSegmentsLength;
        }

        // 当前路段的虚拟世界 Z 坐标
        const worldZ = STATE.distance + relZ;

        // 根据世界 Z 计算 弯道 X
        const worldX = trackFunction(worldZ);

        // 设置物体位置
        seg.position.z = -relZ; // 负数因为 WebGL Z 轴向外
        seg.position.x = worldX - trackCenterX; // 相对摄像机 X 的偏移（让摄像机觉得自己在中间，或者我们把摄像机设为0，移动物体）

        // 这里有个坐标系转换：
        // 我们的 Camera.x 已经设为了 (trackCenterX + playerX)。
        // 所以物体的 x 应该是 worldX。
        // 为了视觉正确，Camera 是世界坐标，物体也是世界坐标？
        // 不，为了浮点精度，通常 Camera 保持原点附近。
        
        // 重新采用方案：Camera 在 (0,0,0) 附近，物体相对移动。
        // Camera.x = playerX (只反映横向偏移)
        // 路段.x = worldX - trackCenterX_Current
        
        // 修正 Camera设置：
        camera.position.x = STATE.playerX;
        camera.position.z = 0;
        
        seg.position.x = worldX - trackCenterX; // 这样路段中心就在相对 0 点的正确弯道位置
        seg.position.z = -relZ;

        // 旋转路段以匹配切线
        const tangent = getTrackDerivative(worldZ);
        seg.rotation.y = -tangent; // 弯曲路面朝向
    });

    // 5. 摄像机 LookAt (看向未来)
    // 我们希望摄像机看向前方路段的中心，加上一点玩家偏移
    const lookAheadDist = CONFIG.camLookAhead;
    const nextWorldZ = STATE.distance + lookAheadDist;
    const nextTrackX = trackFunction(nextWorldZ);
    const nextTrackX_Rel = nextTrackX - trackCenterX; // 相对当前赛道中心的偏移
    
    // 目标点：前方的路中心 + 玩家当前的相对偏移的一半 (产生延迟跟随感)
    const targetX = nextTrackX_Rel + (STATE.playerX * 0.5); 
    
    camera.lookAt(targetX, 0, -lookAheadDist);

    // 6. 摄像机 Roll (转向倾斜)
    camera.rotation.z = -STATE.steerVal * 0.15 - (camera.rotation.y * 0.5);

    // 7. FOV 动态变化
    const targetFov = CONFIG.fovBase + (STATE.speed / 100) * (CONFIG.fovMax - CONFIG.fovBase);
    camera.fov += (targetFov - camera.fov) * 0.1;
    camera.updateProjectionMatrix();

    // 8. 粒子效果 (简单的向后飞)
    const points = debrisParticles[0];
    const positions = points.geometry.attributes.position.array;
    for(let i=0; i<positions.length/3; i++) {
        positions[i*3+2] += STATE.speed * 0.1; // 向 Z 正方向跑 (靠近摄像机)
        if(positions[i*3+2] > 0) {
            positions[i*3+2] = -200; // 重置到远处
            positions[i*3] = (Math.random()-0.5) * 100;
        }
    }
    points.geometry.attributes.position.needsUpdate = true;
}

function updateUI() {
    const kmh = Math.floor(STATE.speed * 3.5); // 假装是 km/h
    document.getElementById('speed-display').innerText = kmh;
}

/**
 * ==========================================
 * 3. 输入控制 (MediaPipe + Keyboard)
 * ==========================================
 */
const keys = { Left: false, Right: false };
function initInput() {
    // 键盘
    document.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') keys.Left = true;
        if (e.key === 'ArrowRight') keys.Right = true;
    });
    document.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft') keys.Left = false;
        if (e.key === 'ArrowRight') keys.Right = false;
    });

    // AI
    const video = document.getElementById('input_video');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    
    hands.onResults(results => {
        document.getElementById('loader').style.display = 'none'; // 隐藏加载
        if (results.multiHandLandmarks.length > 0) {
            STATE.isAiActive = true;
            document.getElementById('ai-status').innerText = "已接管";
            document.getElementById('ai-status').style.color = "#00ffcc";
            processHand(results.multiHandLandmarks[0]);
        } else {
            STATE.isAiActive = false;
            document.getElementById('ai-status').innerText = "丢失目标";
            document.getElementById('ai-status').style.color = "yellow";
        }
    });

    const cam = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 320, height: 240
    });
    cam.start().then(()=> console.log("Cam started")).catch(e => {
        document.getElementById('load-msg').innerText = "摄像头失败，请使用键盘";
        setTimeout(()=> document.getElementById('loader').style.display = 'none', 2000);
    });
}

function processHand(landmarks) {
    // 计算手腕(0)到中指根(9)的角度
    const p0 = landmarks[0];
    const p9 = landmarks[9];
    const dx = p9.x - p0.x;
    const dy = p9.y - p0.y;
    // 计算旋转角
    const angle = Math.atan2(dy, dx) * (180/Math.PI);
    
    // 正常垂直是 -90度
    // 左倾 < -90, 右倾 > -90
    // 映射范围: -135 (左满) ~ -45 (右满)
    const center = -90;
    const range = 40;
    
    let diff = angle - center;
    // 钳制
    if(diff < -range) diff = -range;
    if(diff > range) diff = range;

    // 映射到 -1 ~ 1
    // 角度大是顺时针(右)，角度小是逆时针(左)
    const targetSteer = diff / range; 
    
    // 平滑应用
    STATE.steerVal += (targetSteer - STATE.steerVal) * 0.15;
    document.getElementById('input-mode').innerText = "手势控制";
}

function processKeyboard() {
    if (STATE.isAiActive) return;
    let target = 0;
    if (keys.Left) target = -1;
    if (keys.Right) target = 1;
    STATE.steerVal += (target - STATE.steerVal) * 0.1;
    if(target !== 0) document.getElementById('input-mode').innerText = "键盘控制";
}

/**
 * ==========================================
 * 主循环
 * ==========================================
 */
function animate() {
    requestAnimationFrame(animate);
    
    processKeyboard();
    updatePhysics();
    updateScene();
    updateUI();
    
    renderer.render(scene, camera);
}

// 启动
initThree();
initInput();
animate();

</script>
</body>
</html>
