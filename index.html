<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystic Tarot - Three.js & MediaPipe</title>
    <style>
        :root {
            --primary: #d4af37;
            --bg: #111;
            --panel-bg: rgba(0, 0, 0, 0.85);
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            user-select: none;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--primary);
            padding: 15px;
            border-radius: 8px;
            pointer-events: auto;
            position: absolute;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
            transition: opacity 0.3s;
        }
        /* Top Info */
        #status-panel {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            min-width: 300px;
        }
        #card-name {
            font-size: 1.5em;
            color: var(--primary);
            margin: 0;
            font-weight: bold;
        }
        #card-meaning {
            font-size: 0.9em;
            margin-top: 5px;
            color: #ccc;
        }
        #action-hint {
            margin-top: 8px;
            font-size: 0.8em;
            color: #ffaa33;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        /* Controls */
        #controls {
            bottom: 20px;
            left: 20px;
            font-size: 0.85em;
        }
        #mode-toggle {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 5px;
        }
        /* History */
        #history-panel {
            top: 20px;
            right: 20px;
            width: 250px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .history-item {
            border-bottom: 1px solid #444;
            padding: 8px 0;
            font-size: 0.85em;
            display: flex;
            align-items: center;
        }
        .history-item img {
            width: 30px;
            height: 50px;
            margin-right: 10px;
            object-fit: cover;
        }
        .history-item .reversed {
            transform: rotate(180deg);
        }
        .rev-tag {
            color: #ff6b6b;
            font-size: 0.8em;
            margin-left: 5px;
        }
        /* Loading */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 999;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .spinner {
            width: 50px; height: 50px;
            border: 5px solid #333;
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #input_video { display: none; }
    </style>
    
    <!-- Dependencies -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p id="loading-text">Loading Neural Networks & Assets...</p>
    </div>

    <div id="canvas-container"></div>
    <video id="input_video"></video>

    <div id="ui-layer">
        <div id="status-panel" class="panel">
            <div id="card-name">å‡†å¤‡ä¸­...</div>
            <div id="card-meaning">è¯·ç­‰å¾…å‘ç‰Œ</div>
            <div id="action-hint"></div>
        </div>

        <div id="history-panel" class="panel">
            <h3>æŠ½å¡è®°å½•</h3>
            <div id="history-list"></div>
        </div>

        <div id="controls" class="panel">
            <div>å½“å‰æ¨¡å¼: <span id="mode-label" style="color:var(--primary)">åˆå§‹åŒ–...</span></div>
            <div id="gesture-hint">
                ğŸ‘Œ <b>æåˆ</b>: æŠ“å–<br>
                âœŠ <b>æ¡æ‹³</b>: ç¡®è®¤æŠ½å– (ç¿»ç‰Œ)<br>
                ğŸ– <b>å¼ å¼€</b>: é‡Šæ”¾ (åŒ–ä¸ºç°çƒ¬)
            </div>
            <div id="mouse-hint" style="display:none">
                ğŸ–±ï¸ <b>æŒ‰ä½å·¦é”®</b>: æŠ“å–<br>
                âŒ¨ï¸ <b>ç©ºæ ¼é”®</b>: ç¡®è®¤æŠ½å–<br>
                ğŸ–±ï¸ <b>æ¾å¼€æ‰€æœ‰</b>: é‡Šæ”¾
            </div>
            <button id="mode-toggle">åˆ‡æ¢è¾“å…¥æ¨¡å¼</button>
        </div>
    </div>

<script>
/**
 * å¡”ç½—ç‰Œæ•°æ® (å¤§é˜¿å¡çº³ 0-21)
 */
const TAROT_DATA = [
    { id: 0, name: "The Fool", url: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg", up: "æ–°çš„å¼€å§‹, å†’é™©, çº¯çœŸ", rev: "é²è½, å†’é™©çš„é£é™©, æ„šè ¢" },
    { id: 1, name: "The Magician", url: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg", up: "æ„å¿—åŠ›, åˆ›é€ , æŠ€èƒ½", rev: "æ“çºµ, è®¡åˆ’ä¸å‘¨, æ½œåœ¨å¤©èµ‹" },
    { id: 2, name: "The High Priestess", url: "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg", up: "ç›´è§‰, ç¥ç§˜, å†…åœ¨çŸ¥è¯†", rev: "ç§˜å¯†, å‹æŠ‘çš„æƒ…æ„Ÿ, æ’¤é€€" },
    { id: 3, name: "The Empress", url: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg", up: "ä¸°é¥¶, æ¯æ€§, è‡ªç„¶", rev: "ä¾èµ–, åˆ›é€ åŠ›å—é˜», ç©ºè™š" },
    { id: 4, name: "The Emperor", url: "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg", up: "æƒå¨, ç»“æ„, çˆ¶äº²å½¢è±¡", rev: "æš´æ”¿, åƒµåŒ–, ç¼ºä¹çºªå¾‹" },
    { id: 5, name: "The Hierophant", url: "https://upload.wikimedia.org/wikipedia/commons/8/8d/RWS_Tarot_05_Hierophant.jpg", up: "ä¼ ç»Ÿ, ç²¾ç¥æŒ‡å¼•, ä¿¡ä»°", rev: "åå›, æ–°è§‚å¿µ, é™åˆ¶" },
    { id: 6, name: "The Lovers", url: "https://upload.wikimedia.org/wikipedia/commons/3/3a/TheLovers.jpg", up: "çˆ±, å’Œè°, å…³ç³», é€‰æ‹©", rev: "ä¸å’Œè°, å¤±è¡¡, é”™è¯¯çš„ä»·å€¼è§‚" },
    { id: 7, name: "The Chariot", url: "https://upload.wikimedia.org/wikipedia/commons/9/9b/RWS_Tarot_07_Chariot.jpg", up: "æ§åˆ¶, æ„å¿—åŠ›, èƒœåˆ©", rev: "å¤±æ§, ä¾µç•¥æ€§, ç¼ºä¹æ–¹å‘" },
    { id: 8, name: "Strength", url: "https://upload.wikimedia.org/wikipedia/commons/f/f5/RWS_Tarot_08_Strength.jpg", up: "åŠ›é‡, å‹‡æ°”, åŠå¯¼", rev: "è‡ªæˆ‘æ€€ç–‘, è½¯å¼±, ç”ŸçŒ›" },
    { id: 9, name: "The Hermit", url: "https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg", up: "å†…çœ, å­¤ç‹¬, å¯»æ‰¾çœŸç†", rev: "å­¤ç«‹, åæ‰§, é€€å‡ºç¤¾ä¼š" },
    { id: 10, name: "Wheel of Fortune", url: "https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg", up: "å‘½è¿, è½¬æŠ˜ç‚¹, å‘¨æœŸ", rev: "åè¿æ°”, é˜»åŠ›, å¾ªç¯æ‰“ç ´" },
    { id: 11, name: "Justice", url: "https://upload.wikimedia.org/wikipedia/commons/e/e0/RWS_Tarot_11_Justice.jpg", up: "æ­£ä¹‰, å…¬å¹³, çœŸç›¸", rev: "ä¸å…¬, ç¼ºä¹è´£ä»», ä¸è¯šå®" },
    { id: 12, name: "The Hanged Man", url: "https://upload.wikimedia.org/wikipedia/commons/2/2b/RWS_Tarot_12_Hanged_Man.jpg", up: "æš‚åœ, æ”¾ä¸‹, æ–°è§†è§’", rev: "æ‹–å»¶, æŠµæŠ—, åœæ»" },
    { id: 13, name: "Death", url: "https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg", up: "ç»“æŸ, è½¬å˜, è¿‡æ¸¡", rev: "æŠ—æ‹’æ”¹å˜, æ— æ³•é‡Šæ€€" },
    { id: 14, name: "Temperance", url: "https://upload.wikimedia.org/wikipedia/commons/f/f8/RWS_Tarot_14_Temperance.jpg", up: "å¹³è¡¡, èŠ‚åˆ¶, è€å¿ƒ", rev: "å¤±è¡¡, è¿‡åº¦, ä»“ä¿ƒ" },
    { id: 15, name: "The Devil", url: "https://upload.wikimedia.org/wikipedia/commons/5/55/RWS_Tarot_15_Devil.jpg", up: "æŸç¼š, ç‰©è´¨ä¸»ä¹‰, è¯±æƒ‘", rev: "æ‰“ç ´æ·é”, æ¢å¤åŠ›é‡" },
    { id: 16, name: "The Tower", url: "https://upload.wikimedia.org/wikipedia/commons/5/53/RWS_Tarot_16_Tower.jpg", up: "çªå˜, ç¾éš¾, å¯ç¤º", rev: "é¿å…ç¾éš¾, ææƒ§æ”¹å˜" },
    { id: 17, name: "The Star", url: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg", up: "å¸Œæœ›, çµæ„Ÿ, å®é™", rev: "ç»æœ›, ç¼ºä¹ä¿¡å¿ƒ, æ²®ä¸§" },
    { id: 18, name: "The Moon", url: "https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg", up: "å¹»è§‰, ææƒ§, æ½œæ„è¯†", rev: "é‡Šæ”¾ææƒ§, æ··ä¹±å¹³æ¯" },
    { id: 19, name: "The Sun", url: "https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg", up: "å¿«ä¹, æˆåŠŸ, æ´»åŠ›", rev: "æ¶ˆæ²‰, æš‚æ—¶çš„å¤±è´¥" },
    { id: 20, name: "Judgement", url: "https://upload.wikimedia.org/wikipedia/commons/d/dd/RWS_Tarot_20_Judgement.jpg", up: "å®¡åˆ¤, é‡ç”Ÿ, å†…å¿ƒå¬å”¤", rev: "è‡ªæˆ‘æ€€ç–‘, æ‹’ç»å¬å”¤" },
    { id: 21, name: "The World", url: "https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg", up: "å®Œæˆ, æ•´åˆ, æˆå°±", rev: "æœªå®Œæˆ, ç¼ºä¹é—­ç¯" }
];

// å¡èƒŒçº¹ç†
function createCardBackTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#2a2a4a';
    ctx.fillRect(0, 0, 256, 512);
    ctx.strokeStyle = '#d4af37';
    ctx.lineWidth = 10;
    ctx.strokeRect(10, 10, 236, 492);
    ctx.beginPath();
    ctx.arc(128, 256, 50, 0, Math.PI * 2);
    ctx.stroke();
    return new THREE.CanvasTexture(canvas);
}

// ----------------------
// å…¨å±€å˜é‡ä¸çŠ¶æ€
// ----------------------
let scene, camera, renderer, light;
let currentCardMesh = null;
let currentCardData = null;
let isReversed = false;
let deck = [...TAROT_DATA];
let particles = []; 

// è¾“å…¥çŠ¶æ€
const InputMode = { HAND: 'hand', MOUSE: 'mouse' };
let currentMode = InputMode.HAND;
let handLandmarks = null;
let mouse = new THREE.Vector2();
let isMouseDown = false;
let isSpaceDown = false;

// æ¸¸æˆçŠ¶æ€æœº
const GameState = { 
    IDLE: 0,        // å¾…æœº
    HOVER: 1,       // æ‚¬åœ
    GRABBED: 2,     // æŠ“å–ä¸­
    REVEALING: 3,   // æ­ç¤ºåŠ¨ç”»ä¸­ (ç§»åŠ¨åˆ°ä¸­é—´ + ç¿»è½¬)
    REVEALED: 4,    // å·²æ­ç¤ºï¼Œç­‰å¾…é‡Šæ”¾
    DISSOLVING: 5   // ç°çƒ¬æ¶ˆæ•£ä¸­
};
let currentState = GameState.IDLE;
let raycaster = new THREE.Raycaster();
let cursorPosition = new THREE.Vector2(); 

// MediaPipe
let hands;
let cameraUtils;

// ----------------------
// åˆå§‹åŒ– Three.js
// ----------------------
function initThree() {
    const container = document.getElementById('canvas-container');
    
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x111111, 0.02);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffeebb, 0.8);
    dirLight.position.set(2, 5, 5);
    dirLight.castShadow = true;
    scene.add(dirLight);
    
    const pointLight = new THREE.PointLight(0xd4af37, 0.5, 10);
    pointLight.position.set(0, 2, 2);
    scene.add(pointLight);

    window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ----------------------
// å¡ç‰Œé€»è¾‘
// ----------------------
function spawnCard() {
    if (currentCardMesh) {
        scene.remove(currentCardMesh);
        currentCardMesh = null;
    }
    
    if (deck.length === 0) {
        deck = [...TAROT_DATA]; 
        addHistoryLog({name: "=== æ´—ç‰Œ ===", isMsg: true});
    }

    const index = Math.floor(Math.random() * deck.length);
    currentCardData = deck[index];
    isReversed = Math.random() < 0.5;

    const geometry = new THREE.BoxGeometry(2, 3.5, 0.05);
    const loader = new THREE.TextureLoader();
    const backTex = createCardBackTexture();
    
    // index 4 = Front, index 5 = Back
    const materials = [
        new THREE.MeshStandardMaterial({ color: 0x222222 }), 
        new THREE.MeshStandardMaterial({ color: 0x222222 }), 
        new THREE.MeshStandardMaterial({ color: 0x222222 }), 
        new THREE.MeshStandardMaterial({ color: 0x222222 }), 
        new THREE.MeshStandardMaterial({ color: 0x222222, map: null }), 
        new THREE.MeshStandardMaterial({ map: backTex }),   
    ];

    currentCardMesh = new THREE.Mesh(geometry, materials);
    
    loader.load(currentCardData.url, (tex) => {
        tex.encoding = THREE.sRGBEncoding;
        currentCardMesh.material[4].map = tex;
        currentCardMesh.material[4].needsUpdate = true;
    }, undefined, () => {
        currentCardMesh.material[4].color.setHex(0x550000); 
    });

    // åˆå§‹: åº•éƒ¨, èƒŒé¢æœå‰
    currentCardMesh.position.set(0, -5, 0);
    currentCardMesh.rotation.y = Math.PI; 
    
    scene.add(currentCardMesh);

    updateUI("å‡†å¤‡æŠ½å–", "è¯·ä½¿ç”¨æ‰‹åŠ¿æˆ–é¼ æ ‡æŠ“å–å¡ç‰Œ", "");
    currentState = GameState.IDLE;
    
    animateEntry();
}

function animateEntry() {
    let startTime = Date.now();
    const duration = 1000;
    
    function loop() {
        if (!currentCardMesh) return;
        const now = Date.now();
        const progress = Math.min((now - startTime) / duration, 1);
        const ease = 1 - Math.pow(1 - progress, 3);
        
        currentCardMesh.position.y = -5 + ease * 5; 
        currentCardMesh.rotation.y = Math.PI + ease * Math.PI * 2; 
        
        if (progress < 1) requestAnimationFrame(loop);
        else {
            currentCardMesh.rotation.y = Math.PI;
            currentState = GameState.IDLE;
        }
    }
    loop();
}

// ----------------------
// ç°çƒ¬ç‰¹æ•ˆ
// ----------------------
class AshEffect {
    constructor(mesh) {
        this.particles = [];
        const geom = mesh.geometry;
        const posAttribute = geom.attributes.position;
        const count = posAttribute.count;
        const sampleRate = 3; 
        const matWorld = mesh.matrixWorld;
        
        const particleGeom = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        
        const color = new THREE.Color(0xffaa33);
        
        for (let i = 0; i < count; i+=sampleRate) {
            const v = new THREE.Vector3();
            v.fromBufferAttribute(posAttribute, i);
            v.applyMatrix4(matWorld);
            
            this.particles.push({
                pos: v.clone(),
                vel: new THREE.Vector3((Math.random()-0.5)*0.08, Math.random()*0.15 + 0.05, (Math.random()-0.5)*0.08),
                life: 1.0 + Math.random() * 0.5,
                noiseOffset: Math.random() * 100
            });
            
            positions.push(v.x, v.y, v.z);
            colors.push(color.r, color.g, color.b);
        }
        
        particleGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        particleGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 1,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending
        });

        this.mesh = new THREE.Points(particleGeom, material);
        scene.add(this.mesh);
    }

    update() {
        const positions = this.mesh.geometry.attributes.position.array;
        let activeCount = 0;
        
        for (let i = 0; i < this.particles.length; i++) {
            const p = this.particles[i];
            if (p.life > 0) {
                p.vel.x += Math.sin(Date.now() * 0.005 + p.noiseOffset) * 0.003;
                p.pos.add(p.vel);
                p.life -= 0.03;
                
                positions[i*3] = p.pos.x;
                positions[i*3+1] = p.pos.y;
                positions[i*3+2] = p.pos.z;
                activeCount++;
            }
        }
        
        this.mesh.geometry.attributes.position.needsUpdate = true;
        this.mesh.material.opacity = Math.max(0, this.mesh.material.opacity - 0.02);
        
        return activeCount > 0 && this.mesh.material.opacity > 0;
    }

    dispose() {
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
    }
}

// ----------------------
// æ¸¸æˆä¸»å¾ªç¯é€»è¾‘
// ----------------------
function updateGameLogic() {
    // ç°çƒ¬æ›´æ–°
    if (particles.length > 0) {
        for (let i = particles.length - 1; i >= 0; i--) {
            const alive = particles[i].update();
            if (!alive) {
                particles[i].dispose();
                particles.splice(i, 1);
            }
        }
    }

    // åŠ¨ç”»ä¸­æˆ–å·²é”€æ¯åˆ™è·³è¿‡äº¤äº’é€»è¾‘
    if (currentState === GameState.REVEALING || currentState === GameState.DISSOLVING || !currentCardMesh) return;

    // 1. è·å–è¾“å…¥çŠ¶æ€
    let isPinching = false;
    let isFisting = false;

    if (currentMode === InputMode.HAND && handLandmarks) {
        const thumbTip = handLandmarks[4];
        const indexTip = handLandmarks[8];
        const wrist = handLandmarks[0];
        
        const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
        isPinching = pinchDist < 0.05;

        const middleTip = handLandmarks[12];
        const fistDist = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
        isFisting = fistDist < 0.15;

        const cx = (thumbTip.x + indexTip.x) / 2;
        const cy = (thumbTip.y + indexTip.y) / 2;
        cursorPosition.set((1 - cx) * 2 - 1, (1 - cy) * 2 - 1); 

    } else if (currentMode === InputMode.MOUSE) {
        cursorPosition.copy(mouse);
        isPinching = isMouseDown;
        isFisting = isSpaceDown;
    }

    // å°„çº¿
    raycaster.setFromCamera(cursorPosition, camera);

    // --- çŠ¶æ€æœºé€»è¾‘ ---

    // çŠ¶æ€ A: å¾…æœº/æ‚¬åœ
    if (currentState === GameState.IDLE || currentState === GameState.HOVER) {
        const intersects = raycaster.intersectObject(currentCardMesh);
        if (intersects.length > 0) {
            document.body.style.cursor = 'pointer';
            currentCardMesh.scale.setScalar(1.05);
            currentState = GameState.HOVER;

            if (isPinching) {
                currentState = GameState.GRABBED;
                updateUI("å·²æŠ“å–", isReversed ? "???" : "???", "âœŠ æ¡æ‹³ç¡®è®¤æŠ½å–");
            }
        } else {
            document.body.style.cursor = 'default';
            currentCardMesh.scale.setScalar(1);
            currentState = GameState.IDLE;
        }
    }
    
    // çŠ¶æ€ B: æŠ“å–ä¸­
    else if (currentState === GameState.GRABBED) {
        if (!isPinching) {
            // æ¾å¼€ -> å›åˆ°åŸä½
            currentState = GameState.IDLE;
            new TWEEN_Pos(currentCardMesh.position, new THREE.Vector3(0,0,0), 300);
            updateUI("å‡†å¤‡æŠ½å–", "è¯·ä½¿ç”¨æ‰‹åŠ¿æˆ–é¼ æ ‡æŠ“å–å¡ç‰Œ", "");
        } else {
            // è·Ÿéšå…‰æ ‡ (é™åˆ¶è·ç¦»)
            const dist = 3.5; 
            const targetPos = raycaster.ray.origin.clone().add(raycaster.ray.direction.clone().multiplyScalar(dist));
            currentCardMesh.position.lerp(targetPos, 0.2);
            currentCardMesh.rotation.x = (targetPos.y - currentCardMesh.position.y) * 0.5;
            currentCardMesh.rotation.z = -(targetPos.x - currentCardMesh.position.x) * 0.5;

            // è§¦å‘æ­ç¤º
            if (isFisting) {
                revealCard();
            }
        }
    }

    // çŠ¶æ€ C: å·²æ­ç¤º (ç­‰å¾…å¼ å¼€æ‰‹æŒ)
    else if (currentState === GameState.REVEALED) {
        // å¡ç‰Œæ‚¬æµ®å¾®åŠ¨
        currentCardMesh.position.y += Math.sin(Date.now() * 0.002) * 0.002;

        // æ£€æµ‹"å¼ å¼€æ‰‹æŒ" = æ—¢ä¸æåˆä¹Ÿä¸æ¡æ‹³ (æˆ–è€…é¼ æ ‡æ¨¡å¼ä¸‹æ¾å¼€æŒ‰é”®)
        const isHandOpen = !isPinching && !isFisting;
        
        if (isHandOpen) {
            triggerDissolve();
        }
    }
}

function TWEEN_Pos(obj, target, ms) {
    const start = obj.clone();
    const startTime = Date.now();
    function loop() {
        const p = Math.min((Date.now() - startTime) / ms, 1);
        const e = 1 - Math.pow(1-p, 3);
        obj.lerpVectors(start, target, e);
        if (p < 1) requestAnimationFrame(loop);
    }
    loop();
}

// ----------------------
// é˜¶æ®µ1ï¼šæ­ç¤º (ç§»åŠ¨åˆ°ä¸­é—´ + ç¿»è½¬)
// ----------------------
function revealCard() {
    if (currentState === GameState.REVEALING) return;
    currentState = GameState.REVEALING;

    // æ›´æ–°UI
    updateUI(currentCardData.name + (isReversed ? " (é€†ä½)" : ""), 
             isReversed ? currentCardData.rev : currentCardData.up,
             "ğŸ– å¼ å¼€æ‰‹æŒ é‡Šæ”¾èƒ½é‡");

    // è®°å½•å†å²
    deck = deck.filter(c => c.id !== currentCardData.id);
    addHistoryLog({
        name: currentCardData.name,
        url: currentCardData.url,
        reversed: isReversed,
        meaning: isReversed ? currentCardData.rev : currentCardData.up
    });

    // åŠ¨ç”»ç›®æ ‡: å±å¹•æ­£ä¸­å¿ƒï¼Œè·ç¦»æ‘„åƒå¤´è¿‘ä¸€ç‚¹ (Z=2)
    // æ‘„åƒæœº Z=5, å¡ç‰Œå» Z=2, çœ‹èµ·æ¥æ¯”è¾ƒå¤§
    const targetPos = new THREE.Vector3(0, 0, 2);
    
    // æ—‹è½¬ç›®æ ‡: Y=0 (æ­£é¢æœæ‘„åƒæœº), Z = 0 or PI (é€†ä½)
    const targetRotZ = isReversed ? Math.PI : 0;
    
    const startPos = currentCardMesh.position.clone();
    const startRot = currentCardMesh.rotation.clone();
    const startTime = Date.now();
    const duration = 1000;

    function animateReveal() {
        const now = Date.now();
        const p = Math.min((now - startTime) / duration, 1);
        // EaseOutBack for position implies arriving firmly
        const ease = 1 - Math.pow(1 - p, 3);
        
        // ç§»åŠ¨
        currentCardMesh.position.lerpVectors(startPos, targetPos, ease);
        
        // æ—‹è½¬ (å¹³æ»‘æ’å€¼)
        currentCardMesh.rotation.x = THREE.MathUtils.lerp(startRot.x, 0, ease);
        currentCardMesh.rotation.y = THREE.MathUtils.lerp(startRot.y, 0, ease);
        currentCardMesh.rotation.z = THREE.MathUtils.lerp(startRot.z, targetRotZ, ease);

        if (p < 1) {
            requestAnimationFrame(animateReveal);
        } else {
            // åŠ¨ç”»å®Œæˆï¼Œè¿›å…¥ç­‰å¾…é‡Šæ”¾çŠ¶æ€
            currentState = GameState.REVEALED;
        }
    }
    animateReveal();
}

// ----------------------
// é˜¶æ®µ2ï¼šæ¶ˆæ•£ (ç°çƒ¬)
// ----------------------
function triggerDissolve() {
    if (currentState === GameState.DISSOLVING) return;
    currentState = GameState.DISSOLVING;
    
    updateUI("...", "å‘½è¿å·²å®š", "");

    particles.push(new AshEffect(currentCardMesh));
    scene.remove(currentCardMesh);
    currentCardMesh = null;
    
    // è‡ªåŠ¨ç”Ÿæˆä¸‹ä¸€å¼ 
    setTimeout(spawnCard, 2500);
}

// ----------------------
// UI ä¸ è¾“å…¥å¤„ç†
// ----------------------
function updateUI(title, subtitle, action) {
    document.getElementById('card-name').innerText = title;
    document.getElementById('card-meaning').innerText = subtitle;
    document.getElementById('action-hint').innerText = action;
}

function addHistoryLog(item) {
    const list = document.getElementById('history-list');
    const div = document.createElement('div');
    div.className = 'history-item';
    
    if (item.isMsg) {
        div.innerText = item.name;
        div.style.justifyContent = "center";
        div.style.fontStyle = "italic";
    } else {
        const img = document.createElement('img');
        img.src = item.url;
        if (item.reversed) img.className = 'reversed';
        
        const text = document.createElement('span');
        text.innerHTML = `${item.name} ${item.reversed ? '<span class="rev-tag">(é€†)</span>' : ''}`;
        
        div.appendChild(img);
        div.appendChild(text);
    }
    list.insertBefore(div, list.firstChild);
}

// é¼ æ ‡äº‹ä»¶
window.addEventListener('mousemove', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
});
window.addEventListener('mousedown', () => { isMouseDown = true; });
window.addEventListener('mouseup', () => { isMouseDown = false; });
window.addEventListener('keydown', (e) => { if(e.code === 'Space') isSpaceDown = true; });
window.addEventListener('keyup', (e) => { if(e.code === 'Space') isSpaceDown = false; });

const toggleBtn = document.getElementById('mode-toggle');
toggleBtn.addEventListener('click', () => {
    if (currentMode === InputMode.HAND) enableMouseMode();
    else location.reload();
});

function enableMouseMode() {
    currentMode = InputMode.MOUSE;
    document.getElementById('mode-label').innerText = "é¼ æ ‡ Mouse";
    document.getElementById('gesture-hint').style.display = 'none';
    document.getElementById('mouse-hint').style.display = 'block';
    
    if (cameraUtils) {
        const video = document.getElementById('input_video');
        if(video.srcObject) {
            video.srcObject.getTracks().forEach(track => track.stop());
        }
    }
}

// ----------------------
// MediaPipe
// ----------------------
function onResults(results) {
    document.getElementById('loader').style.display = 'none';
    if (currentMode !== InputMode.HAND) return;
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handLandmarks = results.multiHandLandmarks[0];
    } else {
        handLandmarks = null;
    }
}

function initMediaPipe() {
    const videoElement = document.getElementById('input_video');
    
    hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);
    
    cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            if (currentMode === InputMode.HAND) await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    
    cameraUtils.start()
        .then(() => {
            document.getElementById('mode-label').innerText = "æ‰‹åŠ¿ Hand (Webcam)";
        })
        .catch(err => {
            console.error(err);
            document.getElementById('loading-text').innerText = "æ‘„åƒå¤´å¤±è´¥ï¼Œåˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼...";
            setTimeout(() => {
                document.getElementById('loader').style.display = 'none';
                enableMouseMode();
            }, 1000);
        });
}

// ----------------------
// å¯åŠ¨
// ----------------------
initThree();
initMediaPipe();
spawnCard();
function animate() {
    requestAnimationFrame(animate);
    updateGameLogic();
    renderer.render(scene, camera);
}
animate();

</script>
</body>
</html>
