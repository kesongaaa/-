<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js å¡”ç½—æ‰‹åŠ¿å åœ (MediaPipe)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: #ddd; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* Loading */
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #444; border-radius: 8px; text-align: center; pointer-events: auto; }
        
        /* Header & Controls */
        #header { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); }
        .hud-box { background: rgba(0, 0, 0, 0.5); padding: 10px 15px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); backdrop-filter: blur(4px); }
        
        /* Mode Switcher */
        #controls button { background: #333; color: #fff; border: 1px solid #666; padding: 8px 12px; cursor: pointer; border-radius: 4px; transition: 0.2s; }
        #controls button:hover { background: #555; }
        #controls button.active { background: #8b7d28; border-color: #ffd700; }
        
        /* Webcam Preview */
        #webcam-container { width: 160px; height: 120px; border: 2px solid #333; border-radius: 8px; overflow: hidden; position: relative; margin-top: 10px; transform: scaleX(-1); }
        #input_video { width: 100%; height: 100%; object-fit: cover; }
        
        /* Card Info */
        #card-display { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; opacity: 0; transition: opacity 0.5s; pointer-events: none; }
        #card-display.show { opacity: 1; }
        #card-display h1 { font-size: 2.5rem; margin: 0; text-shadow: 0 0 10px #ffd700; color: #ffd700; }
        #card-display h2 { font-size: 1.2rem; color: #aaa; margin: 5px 0; font-style: italic; }
        #card-display p { max-width: 400px; margin: 10px auto; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 4px; }
        
        /* History Panel */
        #history-panel { position: absolute; top: 80px; right: 20px; width: 220px; max-height: 70vh; overflow-y: auto; background: rgba(10, 10, 10, 0.85); border-left: 2px solid #333; padding: 10px; pointer-events: auto; }
        #history-panel h3 { margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 5px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
        .history-item { display: flex; align-items: center; margin-bottom: 8px; font-size: 12px; border-bottom: 1px solid #222; padding-bottom: 4px; }
        .history-thumb { width: 30px; height: 50px; background-size: cover; margin-right: 8px; border-radius: 2px; }
        .history-info { display: flex; flex-direction: column; }
        .history-name { color: #ffd700; font-weight: bold; }
        .history-meaning { color: #aaa; font-size: 10px; }
        .reversed { color: #ff6b6b; }

        /* Gesture Icons */
        .gesture-guide { display: flex; gap: 15px; margin-top: 10px; font-size: 12px; color: #888; }
        .g-icon { font-weight: bold; color: #ccc; }
    </style>

    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ–ç¥ç§˜å­¦å¼•æ“...<br><small>è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥ä½“éªŒæ‰‹åŠ¿æ“ä½œ</small></div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="header">
            <div class="hud-box pointer-events-auto" id="controls">
                <div>æ¨¡å¼é€‰æ‹©ï¼š</div>
                <button id="btn-hand" class="active">ğŸ– æ‰‹åŠ¿æ¨¡å¼</button>
                <button id="btn-mouse">ğŸ–±ï¸ é¼ æ ‡æ¨¡å¼</button>
                <div id="webcam-container">
                    <video id="input_video"></video>
                </div>
                <div class="gesture-guide">
                    <div><span class="g-icon">ğŸ– å¼ å¼€</span><br>å¯»æ‰¾</div>
                    <div><span class="g-icon">ğŸ‘Œ æåˆ</span><br>æŠ“å–</div>
                    <div><span class="g-icon">âœŠ æ¡æ‹³</span><br>ç¡®è®¤/åŒ–ç°</div>
                </div>
            </div>
            
            <div class="hud-box">
                <div id="status-text">ç­‰å¾…æŒ‡ä»¤...</div>
            </div>
        </div>

        <div id="card-display">
            <h1 id="card-name">The Fool</h1>
            <h2 id="card-orientation">æ­£ä½ (Upright)</h2>
            <p id="card-desc">æ–°çš„å¼€å§‹ï¼Œå†’é™©ï¼Œæ— ç•...</p>
        </div>

        <div id="history-panel">
            <h3>æŠ½å¡è®°å½•</h3>
            <div id="history-list"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration & Data ---
        const TAROT_DATA = [
            { id: 0, name: "The Fool", img: "m00.jpg", up: "æ–°çš„å¼€å§‹ï¼Œçº¯çœŸï¼Œè‡ªå‘æ€§ï¼Œè‡ªç”±ç²¾ç¥ã€‚", rev: "é²è½ï¼Œå†’é™©ï¼Œä¸è€ƒè™‘åæœï¼Œæ„šè ¢ã€‚" },
            { id: 1, name: "The Magician", img: "m01.jpg", up: "æ„å¿—åŠ›ï¼Œæ¬²æœ›ï¼Œåˆ›é€ ï¼Œæ˜¾åŒ–ã€‚", rev: "æ“çºµï¼Œè®¡åˆ’ä¸å‘¨ï¼Œæ½œèƒ½æœªå‘ï¼Œå¹»è§‰ã€‚" },
            { id: 2, name: "The High Priestess", img: "m02.jpg", up: "ç›´è§‰ï¼Œæ½œæ„è¯†ï¼Œå†…åœ¨å£°éŸ³ï¼Œç¥ç§˜ã€‚", rev: "å‹æŠ‘æƒ…æ„Ÿï¼Œç”±äºï¼Œç§˜å¯†è¢«æ­éœ²ã€‚" },
            { id: 3, name: "The Empress", img: "m03.jpg", up: "ä¸°é¥¶ï¼Œå¥³æ€§ç‰¹è´¨ï¼Œè‡ªç„¶ï¼Œå…»è‚²ã€‚", rev: "åˆ›é€ åŠ›å—é˜»ï¼Œä¾èµ–ï¼Œç©ºè™šã€‚" },
            { id: 4, name: "The Emperor", img: "m04.jpg", up: "æƒå¨ï¼Œç»“æ„ï¼Œæ§åˆ¶ï¼Œçˆ¶æ€§ã€‚", rev: "æš´æ”¿ï¼ŒåƒµåŒ–ï¼Œå†·é…·ï¼Œç¼ºä¹çºªå¾‹ã€‚" },
            { id: 5, name: "The Hierophant", img: "m05.jpg", up: "ä¼ ç»Ÿï¼Œä¸€è‡´æ€§ï¼Œé“å¾·ï¼Œæ•™è‚²ã€‚", rev: "åå›ï¼Œéä¼ ç»Ÿï¼Œæ–°çš„ä¿¡ä»°ï¼Œé™åˆ¶ã€‚" },
            { id: 6, name: "The Lovers", img: "m06.jpg", up: "çˆ±ï¼Œå’Œè°ï¼Œå…³ç³»ï¼Œä»·å€¼è§‚ä¸€è‡´ã€‚", rev: "ä¸å’Œè°ï¼Œä¸å¹³è¡¡ï¼Œä»·å€¼è§‚å†²çªã€‚" },
            { id: 7, name: "The Chariot", img: "m07.jpg", up: "æ§åˆ¶ï¼Œæ„å¿—åŠ›ï¼ŒæˆåŠŸï¼Œè¡ŒåŠ¨ã€‚", rev: "å¤±å»æ§åˆ¶ï¼Œç¼ºä¹æ–¹å‘ï¼Œæ”»å‡»æ€§ã€‚" },
            { id: 8, name: "Strength", img: "m08.jpg", up: "åŠ›é‡ï¼Œå‹‡æ°”ï¼Œè¯´æœåŠ›ï¼Œå½±å“åŠ›ã€‚", rev: "è‡ªæˆ‘æ€€ç–‘ï¼Œè½¯å¼±ï¼Œä¸å®‰å…¨æ„Ÿã€‚" },
            { id: 9, name: "The Hermit", img: "m09.jpg", up: "å¯»æ‰¾çµé­‚ï¼Œåæ€ï¼Œç‹¬å¤„ï¼Œå†…åœ¨æŒ‡å¼•ã€‚", rev: "å­¤ç‹¬ï¼Œå­¤ç«‹ï¼Œåæ‰§ï¼Œé€€ç¼©ã€‚" },
            { id: 10, name: "Wheel of Fortune", img: "m10.jpg", up: "ä¸šåŠ›ï¼Œå¥½è¿ï¼Œç”Ÿå‘½å‘¨æœŸï¼Œå‘½è¿ã€‚", rev: "å„è¿ï¼ŒæŠµæŠ—å˜åŒ–ï¼Œç ´åå¾ªç¯ã€‚" },
            { id: 11, name: "Justice", img: "m11.jpg", up: "æ­£ä¹‰ï¼Œå…¬å¹³ï¼ŒçœŸç†ï¼Œå› æœã€‚", rev: "ä¸å…¬ï¼Œç¼ºä¹è´£ä»»ï¼Œä¸è¯šå®ã€‚" },
            { id: 12, name: "The Hanged Man", img: "m12.jpg", up: "æš‚åœï¼ŒæŠ•é™ï¼Œæ”¾æ‰‹ï¼Œæ–°è§†è§’ã€‚", rev: "æ‹–å»¶ï¼ŒæŠµæŠ—ï¼Œåœæ»ï¼Œæ— è°“ç‰ºç‰²ã€‚" },
            { id: 13, name: "Death", img: "m13.jpg", up: "ç»“æŸï¼Œè½¬å˜ï¼Œè¿‡æ¸¡ï¼Œæ”¾æ‰‹ã€‚", rev: "æŠµæŠ—æ”¹å˜ï¼Œæ— æ³•å‰è¿›ï¼Œä¾èµ–è¿‡å»ã€‚" },
            { id: 14, name: "Temperance", img: "m14.jpg", up: "å¹³è¡¡ï¼Œé€‚åº¦ï¼Œè€å¿ƒï¼Œç›®æ ‡ã€‚", rev: "ä¸å¹³è¡¡ï¼Œè¿‡åº¦ï¼Œç¼ºä¹é•¿æœŸè§†é‡ã€‚" },
            { id: 15, name: "The Devil", img: "m15.jpg", up: "æŸç¼šï¼Œä¸Šç˜¾ï¼Œç‰©è´¨ä¸»ä¹‰ï¼Œæ€§ã€‚", rev: "æŒ£è„±æŸç¼šï¼Œæ¢å¤åŠ›é‡ï¼Œæ‰“ç ´æ·é”ã€‚" },
            { id: 16, name: "The Tower", img: "m16.jpg", up: "çªå˜ï¼Œæ··ä¹±ï¼Œå¯ç¤ºï¼Œè§‰é†’ã€‚", rev: "é¿å…ç¾éš¾ï¼Œææƒ§æ”¹å˜ï¼Œæ¨è¿Ÿä¸å¯é¿å…ã€‚" },
            { id: 17, name: "The Star", img: "m17.jpg", up: "å¸Œæœ›ï¼Œä¿¡ä»°ï¼Œç›®çš„ï¼Œæ›´æ–°ï¼Œçµæ€§ã€‚", rev: "ç¼ºä¹ä¿¡å¿ƒï¼Œç»æœ›ï¼Œç°å¿ƒã€‚" },
            { id: 18, name: "The Moon", img: "m18.jpg", up: "å¹»è§‰ï¼Œææƒ§ï¼Œç„¦è™‘ï¼Œæ½œæ„è¯†ã€‚", rev: "é‡Šæ”¾ææƒ§ï¼Œå‹æŠ‘æƒ…æ„Ÿï¼Œæ¸…æ™°ã€‚" },
            { id: 19, name: "The Sun", img: "m19.jpg", up: "ç§¯æï¼Œæ¸©æš–ï¼ŒæˆåŠŸï¼Œæ´»åŠ›ã€‚", rev: "å†…å¿ƒå­©ç«¥ï¼Œè¿‡åº¦ä¹è§‚ï¼Œä¸åˆ‡å®é™…ã€‚" },
            { id: 20, name: "Judgement", img: "m20.jpg", up: "å®¡åˆ¤ï¼Œé‡ç”Ÿï¼Œå†…åœ¨å¬å”¤ï¼Œå®½æ•ã€‚", rev: "è‡ªæˆ‘æ€€ç–‘ï¼Œæ‹’ç»å¬å”¤ï¼Œå¿½è§†å› æœã€‚" },
            { id: 21, name: "The World", img: "m21.jpg", up: "å®Œæˆï¼Œæ•´åˆï¼Œæˆå°±ï¼Œæ—…è¡Œã€‚", rev: "æœªå®Œæˆï¼Œç¼ºä¹å°é—­ï¼Œèµ°æ·å¾„ã€‚" }
        ];

        // Using Wikipedia commons or GitHub hosted RWS deck
        const IMG_BASE_URL = "https://raw.githubusercontent.com/tobyleft/tarot-images/main/rws/";
        const BACK_IMG_URL = "https://i.imgur.com/P4Mh00o.jpeg"; // Generic pattern

        // --- Game State & Variables ---
        let scene, camera, renderer, raycaster;
        let cardMesh, cardBackMesh, particles;
        let cursorMesh, glowLight;
        
        let availableCards = [...TAROT_DATA];
        let currentCardData = null;
        let isReversed = false;

        let interactionMode = 'HAND'; // 'HAND' or 'MOUSE'
        let mouse = new THREE.Vector2();
        let handCursorPos = new THREE.Vector3(); // Normalized -1 to 1
        
        // Gesture State
        let gestureState = 'OPEN'; // OPEN, PINCH, FIST, POINT
        let isHolding = false;
        let isConfirmed = false;
        
        // Animation Vars
        let cardTargetPos = new THREE.Vector3(0, 0, 0);
        let cardTargetRot = new THREE.Euler(0, 0, 0);
        let clock = new THREE.Clock();

        // --- Init Three.js ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.FogExp2(0x111111, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(2, 5, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            glowLight = new THREE.PointLight(0xffd700, 0, 5);
            scene.add(glowLight);

            // Raycaster
            raycaster = new THREE.Raycaster();

            // Cursor Visual
            const cursorGeo = new THREE.SphereGeometry(0.05, 16, 16);
            const cursorMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, opacity: 0.7, transparent: true });
            cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
            scene.add(cursorMesh);

            // Initial Card Spawn
            spawnNewCard();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', () => { if(interactionMode === 'MOUSE') { gestureState = 'PINCH'; checkInteraction(); } });
            document.addEventListener('mouseup', () => { if(interactionMode === 'MOUSE') { gestureState = 'OPEN'; releaseCard(); } });
            document.addEventListener('contextmenu', (e) => { 
                e.preventDefault(); 
                if(interactionMode === 'MOUSE' && isHolding) { gestureState = 'FIST'; confirmSelection(); }
            });

            animate();
        }

        // --- Card Logic ---
        function spawnNewCard() {
            if (availableCards.length === 0) {
                availableCards = [...TAROT_DATA]; // Reset deck if empty
            }

            // Remove old mesh if exists
            if (cardMesh) { scene.remove(cardMesh); cardMesh = null; }
            if (particles) { scene.remove(particles); particles = null; }

            // Random Pick
            const idx = Math.floor(Math.random() * availableCards.length);
            currentCardData = availableCards[idx];
            availableCards.splice(idx, 1);

            // Orientation
            isReversed = Math.random() < 0.5;

            // Texture Loading
            const loader = new THREE.TextureLoader();
            const texFront = loader.load(IMG_BASE_URL + currentCardData.img, undefined, undefined, (err) => {
                 // Fallback color if load fails
                 if(cardMesh) cardMesh.material[4].color.setHex(0x550000);
            });
            const texBack = loader.load(BACK_IMG_URL);
            texFront.colorSpace = THREE.SRGBColorSpace;
            texBack.colorSpace = THREE.SRGBColorSpace;

            // Geometry (Box for thickness)
            const geometry = new THREE.BoxGeometry(1.5, 2.6, 0.02);
            
            // Materials: Right, Left, Top, Bottom, Front, Back
            const sideMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const faceMat = new THREE.MeshStandardMaterial({ map: texFront, roughness: 0.4, metalness: 0.1 });
            const backMat = new THREE.MeshStandardMaterial({ map: texBack, roughness: 0.6 });
            
            // Note: BoxGeometry face indices: 0,1 (x), 2,3 (y), 4 (+z Front), 5 (-z Back)
            const materials = [sideMat, sideMat, sideMat, sideMat, faceMat, backMat];

            cardMesh = new THREE.Mesh(geometry, materials);
            
            // Initial Position (Deck pile position, slightly random)
            cardMesh.position.set((Math.random()-0.5)*0.5, -1.5, -1);
            cardMesh.rotation.set(-Math.PI/4, 0, Math.PI); // Face down initially

            scene.add(cardMesh);

            // Reset States
            isHolding = false;
            isConfirmed = false;
            document.getElementById('card-display').classList.remove('show');
            document.getElementById('status-text').innerText = interactionMode === 'HAND' ? "æ‰‹æŒå¼ å¼€ï¼šå¯»æ‰¾ | æåˆï¼šæŠ“å–" : "é¼ æ ‡æ‚¬åœï¼šå¯»æ‰¾ | å·¦é”®ï¼šæŠ“å–";
            
            // Apply logic for orientation when revealed
            // We store the target rotation for the "Reveal" phase
        }

        // --- Interaction Logic ---
        function checkInteraction() {
            if (isConfirmed || !cardMesh) return;

            // Raycast from camera to cursor position
            // Update Raycaster
            if (interactionMode === 'MOUSE') {
                raycaster.setFromCamera(mouse, camera);
            } else {
                // Map 3D cursor position back to screen space for raycaster (approx) or cast from camera to world pos
                const direction = cursorMesh.position.clone().sub(camera.position).normalize();
                raycaster.set(camera.position, direction);
            }

            const intersects = raycaster.intersectObject(cardMesh);
            const isHover = intersects.length > 0;

            if (isHover) {
                document.body.style.cursor = 'pointer';
                if (!isHolding) {
                    glowLight.position.copy(cardMesh.position);
                    glowLight.intensity = 2;
                }
            } else {
                document.body.style.cursor = 'default';
                if (!isHolding) glowLight.intensity = 0;
            }

            // Logic: GRAB
            if (gestureState === 'PINCH' && isHover && !isHolding) {
                isHolding = true;
                glowLight.color.setHex(0x00ff00);
            }
        }

        function updateCardPhysics() {
            if (!cardMesh || isConfirmed) return;

            if (isHolding) {
                // Card follows cursor
                // We want the card to float in front of the camera
                const targetPos = cursorMesh.position.clone();
                // Add a little offset towards camera
                // targetPos.z += 0.5; 
                
                // Lerp Position
                cardMesh.position.lerp(targetPos, 0.1);

                // Lerp Rotation: Face the camera upright
                const targetQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0));
                
                // If it was face down, we flip it to face up (Front side is +Z)
                // If isReversed is true, we rotate 180 on Z
                
                let revRot = isReversed ? Math.PI : 0;
                
                // Basic look at camera
                cardMesh.lookAt(camera.position);
                
                // Adjust for upright/reverse and ensure front face is visible
                // Initial geometry: Front is +Z. lookAt makes +Z point to camera.
                // If reversed, rotate around Z axis local
                cardMesh.rotateZ(revRot);

                document.getElementById('status-text').innerText = interactionMode === 'HAND' ? "âœŠ æ¡æ‹³ï¼šç¡®è®¤æŠ½ç‰Œ" : "ğŸ–±ï¸ å³é”®ï¼šç¡®è®¤æŠ½ç‰Œ";
            } else {
                // Float gently back to idle or drift
                cardMesh.position.y += Math.sin(clock.getElapsedTime()) * 0.002;
                // If not held, maybe rotate slowly or lie on table? 
                // For this game, let's keep it floating near where it was left or drift down
                if (cardMesh.position.y < -1.5) cardMesh.position.y = -1.5;
            }
        }

        function releaseCard() {
            isHolding = false;
            glowLight.color.setHex(0xffd700);
        }

        function confirmSelection() {
            if (!isHolding || isConfirmed) return;
            isConfirmed = true;
            isHolding = false;

            // UI Update
            const uiDisp = document.getElementById('card-display');
            document.getElementById('card-name').innerText = currentCardData.name;
            const orientationText = isReversed ? "é€†ä½ (Reversed)" : "æ­£ä½ (Upright)";
            document.getElementById('card-orientation').innerText = orientationText;
            document.getElementById('card-orientation').className = isReversed ? "reversed" : "";
            document.getElementById('card-desc').innerText = isReversed ? currentCardData.rev : currentCardData.up;
            uiDisp.classList.add('show');

            document.getElementById('status-text').innerText = "å‘½è¿å·²å®šã€‚";

            // Add to history
            addToHistory(currentCardData, isReversed);

            // Trigger Ash Effect
            createAshEffect();

            // Auto reset timer
            setTimeout(() => {
                spawnNewCard();
            }, 6000);
        }

        function addToHistory(data, reversed) {
            const list = document.getElementById('history-list');
            const item = document.createElement('div');
            item.className = 'history-item';
            
            // Creating a small thumbnail style
            const imgUrl = IMG_BASE_URL + data.img;
            
            item.innerHTML = `
                <div class="history-thumb" style="background-image: url('${imgUrl}'); transform: ${reversed ? 'rotate(180deg)' : 'none'}"></div>
                <div class="history-info">
                    <span class="history-name">${data.name}</span>
                    <span class="history-meaning ${reversed ? 'reversed' : ''}">${reversed ? 'é€†ä½' : 'æ­£ä½'}</span>
                </div>
            `;
            list.prepend(item);
        }

        // --- Ash Particle Effect ---
        function createAshEffect() {
            // Sampling points from the box volume/surface
            const particleCount = 3000;
            const geo = new THREE.BufferGeometry();
            const positions = [];
            const speeds = [];
            const opacity = [];
            const sizes = [];

            // Get card current world transform
            cardMesh.updateMatrixWorld();
            const center = cardMesh.position.clone();
            const rotation = cardMesh.rotation.clone();

            const width = 1.5; const height = 2.6;
            
            for(let i=0; i<particleCount; i++) {
                // Local random pos
                let x = (Math.random() - 0.5) * width;
                let y = (Math.random() - 0.5) * height;
                let z = (Math.random() - 0.5) * 0.05;

                // Apply card rotation/pos manually or just spawn cloud at location
                // Simple version: Spawn cloud at card position, no complex matrix math for demo brevity
                // Better: transform local point to world
                let vec = new THREE.Vector3(x, y, z);
                vec.applyEuler(rotation);
                vec.add(center);

                positions.push(vec.x, vec.y, vec.z);
                
                // Velocity: Up + Noise
                speeds.push(
                    (Math.random() - 0.5) * 0.02, // vx
                    Math.random() * 0.05 + 0.01,  // vy (up)
                    (Math.random() - 0.5) * 0.02  // vz
                );
                
                opacity.push(1.0);
                sizes.push(Math.random() * 0.05 + 0.02);
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(speeds, 3));
            geo.setAttribute('alpha', new THREE.Float32BufferAttribute(opacity, 1));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            // Custom Shader Material for fading points
            // Using standard PointsMaterial for simplicity in single file, manipulating alpha in loop
            const mat = new THREE.PointsMaterial({
                color: 0xcccccc,
                size: 0.05,
                transparent: true,
                opacity: 1,
                map: new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/disc.png'),
                depthWrite: false,
                vertexColors: false
            });

            particles = new THREE.Points(geo, mat);
            scene.add(particles);

            // Hide original card
            cardMesh.visible = false;
        }

        function updateParticles() {
            if (!particles) return;

            const positions = particles.geometry.attributes.position.array;
            const vels = particles.geometry.attributes.velocity.array;
            const alphas = particles.geometry.attributes.alpha.array;
            let alive = false;

            for (let i = 0; i < positions.length / 3; i++) {
                // Update Pos
                positions[i*3] += vels[i*3];
                positions[i*3+1] += vels[i*3+1]; // Y
                positions[i*3+2] += vels[i*3+2];

                // Add Turbulence
                vels[i*3] += (Math.random()-0.5) * 0.001;
                vels[i*3+2] += (Math.random()-0.5) * 0.001;

                // Decay Alpha
                if (alphas[i] > 0) {
                    alphas[i] -= 0.01 + Math.random() * 0.01;
                    if (alphas[i] < 0) alphas[i] = 0;
                    else alive = true;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            // Hacky alpha fade via material opacity since vertex alpha requires ShaderMaterial
            // For simple demo, we just fade the whole material or custom shader.
            // Let's use the material opacity global decay for simplicity + scale up
            particles.material.opacity -= 0.005;
            
            if (particles.material.opacity <= 0) {
                scene.remove(particles);
                particles = null;
            }
        }

        // --- Render Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();

            // Cursor smoothing
            if (interactionMode === 'HAND') {
                // handCursorPos is updated by MediaPipe (0-1), map to 3D Viewport
                // Z=0 plane (approx)
                const vector = new THREE.Vector3(handCursorPos.x, handCursorPos.y, 0.5);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z; // Intersection with Z=0
                // We want interactions closer to camera usually
                const targetPos = camera.position.clone().add(dir.multiplyScalar(4)); 
                
                cursorMesh.position.lerp(targetPos, 0.2);
            } else {
                 // Mouse logic handled in raycaster update, cursor mesh follows mouse ray
                 raycaster.setFromCamera(mouse, camera);
                 const dist = 4;
                 const target = new THREE.Vector3().copy(raycaster.ray.direction).multiplyScalar(dist).add(raycaster.ray.origin);
                 cursorMesh.position.lerp(target, 0.2);
            }
            
            // Visual feedback for gesture
            if (gestureState === 'PINCH') cursorMesh.material.color.setHex(0x00ff00);
            else if (gestureState === 'FIST') cursorMesh.material.color.setHex(0xff0000);
            else cursorMesh.material.color.setHex(0x00ffff);

            // Interaction
            if (!isConfirmed) {
                checkInteraction();
                updateCardPhysics();
            }

            // Particles
            updateParticles();

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            if (interactionMode !== 'MOUSE') return;
            // Normalize mouse -1 to 1
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // --- MediaPipe Hands Setup ---
        const videoElement = document.getElementById('input_video');
        const loading = document.getElementById('loading');

        function onResults(results) {
            loading.style.display = 'none';
            if (interactionMode !== 'HAND') return;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Position Mapping (Index Finger Tip #8)
                // MediaPipe x is 0(left) to 1(right), y is 0(top) to 1(bottom)
                // We flip X because selfie view
                const x = (1 - landmarks[8].x) * 2 - 1; 
                const y = -(landmarks[8].y) * 2 + 1;
                
                // Smoothly update global var
                handCursorPos.set(x, y, 0);

                // 2. Gesture Recognition
                detectGesture(landmarks);
            }
        }

        function distance(lm, i, j) {
            const dx = lm[i].x - lm[j].x;
            const dy = lm[i].y - lm[j].y;
            const dz = lm[i].z - lm[j].z;
            return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }

        function detectGesture(lm) {
            // Thumb Tip 4, Index Tip 8, Middle 12, Ring 16, Pinky 20
            // PIP Joints: 6, 10, 14, 18
            
            const thumbTip = lm[4];
            const indexTip = lm[8];
            const pinchDist = distance(lm, 4, 8);

            // Check if fingers are folded (Tip below PIP in y-axis? No, distance to palm base 0)
            // Simplified: Distance tip to wrist(0) < PIP to wrist
            const isFolded = (idx) => distance(lm, idx, 0) < distance(lm, idx-2, 0);

            const middleFold = isFolded(12);
            const ringFold = isFolded(16);
            const pinkyFold = isFolded(20);
            const indexFold = isFolded(8);

            let newState = 'OPEN';

            // FIST: All fingers folded (Index, Middle, Ring, Pinky)
            if (indexFold && middleFold && ringFold && pinkyFold) {
                newState = 'FIST';
            }
            // PINCH: Index close to thumb, others open or loose
            else if (pinchDist < 0.05) {
                newState = 'PINCH';
            }
            // POINT: Index open, others folded
            else if (!indexFold && middleFold && ringFold && pinkyFold) {
                newState = 'POINT'; // Not used heavily logic-wise, but good visual
            }
            
            // State Change Logic
            if (newState !== gestureState) {
                // Debounce simple
                gestureState = newState;
                
                // Trigger Logic
                if (gestureState === 'PINCH') {
                    // Start Grab handled in loop
                } else if (gestureState === 'OPEN') {
                    releaseCard();
                } else if (gestureState === 'FIST') {
                    confirmSelection();
                }
            }
        }

        // Initialize MediaPipe
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        // Webcam CamUtils
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });

        // Start Logic
        async function startApp() {
            initThree();
            
            try {
                await cameraUtils.start();
            } catch(e) {
                console.warn("Camera failed or denied, switching to mouse mode.", e);
                setMouseMode();
                loading.style.display = 'none';
                alert("æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œå·²è‡ªåŠ¨é™çº§ä¸ºé¼ æ ‡æ¨¡å¼ã€‚");
            }
        }

        // Mode Switching UI
        const btnHand = document.getElementById('btn-hand');
        const btnMouse = document.getElementById('btn-mouse');

        function setMouseMode() {
            interactionMode = 'MOUSE';
            btnHand.classList.remove('active');
            btnMouse.classList.add('active');
            videoElement.pause();
            document.getElementById('webcam-container').style.opacity = 0.3;
        }

        function setHandMode() {
            interactionMode = 'HAND';
            btnMouse.classList.remove('active');
            btnHand.classList.add('active');
            videoElement.play();
            document.getElementById('webcam-container').style.opacity = 1;
        }

        btnMouse.addEventListener('click', setMouseMode);
        btnHand.addEventListener('click', () => {
            setHandMode();
            // Re-trigger camera start if needed
            cameraUtils.start().catch(e => {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥");
                setMouseMode();
            });
        });

        startApp();

    </script>
</body>
</html>
