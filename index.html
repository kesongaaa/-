<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle of Fate - Immersive Tarot</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; }
        canvas { display: block; }
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-size: 20px; letter-spacing: 5px; text-align: center;
            pointer-events: none; transition: opacity 0.5s; z-index: 999;
        }
        #debug-video {
            position: absolute; bottom: 10px; right: 10px; width: 120px; height: 90px;
            opacity: 0.2; transform: scaleX(-1); border-radius: 5px; pointer-events: none;
        }
        #ui-layer {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.4); font-size: 14px; pointer-events: none;
            text-shadow: 0 0 10px rgba(0,0,0,1); letter-spacing: 2px;
        }
        .key-point { color: #d4af37; font-weight: bold; }
    </style>
    <!-- ä¾èµ–åº“ CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">INITIALIZING THE RITUAL...</div>
    <video id="debug-video" playsinline></video>
    <div id="ui-layer">
        <span class="key-point">ğŸ‘‹ æŒ¥åŠ¨</span> æ—‹è½¬å‘½è¿ &nbsp;|&nbsp; 
        <span class="key-point">â˜ï¸ æŒ‡å‘</span> é€‰æ‹© &nbsp;|&nbsp; 
        <span class="key-point">ğŸ‘Œ æåˆ</span> æ­ç¤º &nbsp;|&nbsp; 
        <span class="key-point">ğŸ– å¼ å¼€</span> æ¶ˆæ•£
    </div>

<script>
/**
 * ============================================================================
 * å…¨å±€é…ç½®ä¸çŠ¶æ€æœº
 * ============================================================================
 */
const CONFIG = {
    cardCount: 22,
    radius: 6.5,          // ç‰Œé˜µåŠå¾„
    cardWidth: 1.4,
    cardHeight: 2.3,
    bloomStrength: 1.5,
    bloomThreshold: 0.1,
    friction: 0.96,       // æ—‹è½¬é˜»å°¼
    maxVelocity: 0.08     // æœ€å¤§æ—‹è½¬é€Ÿåº¦
};

const STATE = {
    mode: 'RING',         // æ¨¡å¼: RING(è½¬ç›˜), DRAWING(æŠ½ç‰Œä¸­), VIEWING(å±•ç¤ºä¸­), DISSOLVING(æ¶ˆæ•£ä¸­)
    rotVelocity: 0.002,   // åˆå§‹å¾®åŠ¨
    handX: 0,             // å½’ä¸€åŒ–æ‰‹éƒ¨åæ ‡
    handY: 0,
    isHandVisible: false,
    gesture: 'NONE',      // WAVE, HOVER, BRAKE, PINCH, OPEN
    hoveredCard: null,    // å½“å‰æŒ‡å‘çš„ Mesh
    viewingCard: null,    // å½“å‰æŠ½å‡ºçš„ Mesh
    lastPalmX: 0,
    pinchTimer: 0         // æåˆè®¡æ—¶å™¨é˜²è¯¯è§¦
};

// ============================================================================
// 1. çº¹ç†ç”Ÿæˆå™¨ (Canvas Procedural Textures)
// ============================================================================

// ç”Ÿæˆç¥ç§˜å­¦å¡èƒŒ
function createBackTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 800;
    const ctx = canvas.getContext('2d');
    
    // æ·±é‚ƒèƒŒæ™¯
    const grad = ctx.createRadialGradient(256, 400, 50, 256, 400, 500);
    grad.addColorStop(0, '#1a0b2e');
    grad.addColorStop(1, '#05000a');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,512,800);

    // é‡‘è‰²å‡ ä½•çº¹è·¯
    ctx.strokeStyle = '#8a6d3b';
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.arc(256, 400, 150, 0, Math.PI*2);
    ctx.stroke();
    
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(256, 100); ctx.lineTo(256, 700);
    ctx.moveTo(100, 400); ctx.lineTo(412, 400);
    ctx.stroke();

    // éšæœºå™ªç‚¹å¢åŠ è´¨æ„Ÿ
    ctx.fillStyle = 'rgba(255,215,0,0.1)';
    for(let i=0; i<1000; i++) {
        ctx.fillRect(Math.random()*512, Math.random()*800, 2, 2);
    }

    return new THREE.CanvasTexture(canvas);
}

// ç”Ÿæˆå¡é¢ (æ— æ•°å­—ï¼Œåªæœ‰æŠ½è±¡ç¬¦å·)
function createFrontTexture(index) {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 800;
    const ctx = canvas.getContext('2d');

    // ç¾Šçš®çº¸åº•è‰²
    ctx.fillStyle = '#e3dac9';
    ctx.fillRect(0,0,512,800);
    
    // è¾¹æ¡†
    ctx.strokeStyle = '#2c1e0f';
    ctx.lineWidth = 15;
    ctx.strokeRect(30,30,452,740);

    // æŠ½è±¡ç¬¦å· (æ ¹æ®ç´¢å¼•ç”Ÿæˆä¸åŒå›¾å½¢)
    ctx.save();
    ctx.translate(256, 400);
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 8;
    ctx.beginPath();
    // ç®€å•çš„ç¨‹åºåŒ–å›¾å½¢ç”Ÿæˆ
    for(let i=0; i<5; i++) {
        const angle = (Math.PI * 2 * i) / 5 + (index * 0.5);
        const r = 100 + (index % 5) * 20;
        ctx.lineTo(Math.cos(angle)*r, Math.sin(angle)*r);
    }
    ctx.closePath();
    ctx.stroke();
    
    // å†…éƒ¨å¡«å……
    ctx.fillStyle = `rgba(0,0,0,${0.1 + (index%3)*0.1})`;
    ctx.fill();
    ctx.restore();

    return new THREE.CanvasTexture(canvas);
}

// ç²’å­çº¹ç†
function createParticleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const g = ctx.createRadialGradient(32,32,0,32,32,32);
    g.addColorStop(0, 'rgba(255, 220, 100, 1)');
    g.addColorStop(1, 'rgba(255, 220, 100, 0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,64,64);
    return new THREE.CanvasTexture(canvas);
}

// ============================================================================
// 2. Three.js åœºæ™¯æ„å»º
// ============================================================================
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.05); // å¢åŠ æ·±é‚ƒæ„Ÿ

const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
// ç›¸æœºä½äºä¸­å¿ƒç•¥é åï¼Œè§‚å¯Ÿåœ†ç¯
camera.position.set(0, 0, 0); 

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

// ç¯å…‰
const ambientLight = new THREE.AmbientLight(0x404040, 1);
scene.add(ambientLight);

// ä¸­å¿ƒç‚¹å…‰æº (åƒæ˜¯ä¸€æ ¹èœ¡çƒ›åœ¨ä¸­é—´)
const centerLight = new THREE.PointLight(0xffaa00, 1, 20);
centerLight.position.set(0, 0, 0);
scene.add(centerLight);

// ç‰Œç»„å®¹å™¨ (Ring)
const carouselGroup = new THREE.Group();
carouselGroup.position.set(0, -1, 0); // ç¨å¾®æ”¾ä½ä¸€ç‚¹ï¼Œæ–¹ä¾¿å¹³è§†
scene.add(carouselGroup);

// åˆ›å»ºå¡ç‰Œ
const backMat = new THREE.MeshStandardMaterial({ 
    map: createBackTexture(), 
    roughness: 0.6, metalness: 0.1 
});
const sideMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
const cards = [];

const cardGeo = new THREE.BoxGeometry(CONFIG.cardWidth, CONFIG.cardHeight, 0.05);

for (let i = 0; i < CONFIG.cardCount; i++) {
    const frontMat = new THREE.MeshStandardMaterial({ 
        map: createFrontTexture(i),
        roughness: 0.8
    });
    
    // æè´¨é¡ºåº: right, left, top, bottom, front(Z+), back(Z-)
    // æˆ‘ä»¬çº¦å®š Z+ ä¸ºæ­£é¢ï¼ŒZ- ä¸ºèƒŒé¢
    const materials = [sideMat, sideMat, sideMat, sideMat, frontMat, backMat];
    
    const card = new THREE.Mesh(cardGeo, materials);
    
    // æåæ ‡æ’åˆ—
    const angle = (i / CONFIG.cardCount) * Math.PI * 2;
    card.position.x = Math.sin(angle) * CONFIG.radius;
    card.position.z = Math.cos(angle) * CONFIG.radius;
    
    // æœå‘åœ†å¿ƒ (ä½†è¦èƒŒé¢æœå†…ï¼Œå› ä¸ºç›¸æœºåœ¨åœ†å¿ƒ)
    // åˆå§‹ï¼šZ+ æ˜¯æ­£é¢ã€‚æˆ‘ä»¬å¸Œæœ›èƒŒé¢æœå‘ç›¸æœº(0,0,0)ã€‚
    // æ‰€ä»¥è®© Z- æŒ‡å‘åœ†å¿ƒã€‚
    card.lookAt(0, 0, 0);
    
    // ä¿å­˜åˆå§‹æ•°æ®ç”¨äºåŠ¨ç”»å¤ä½
    card.userData = {
        id: i,
        basePos: card.position.clone(),
        baseRot: card.rotation.clone(),
        angle: angle
    };

    carouselGroup.add(card);
    cards.push(card);
}

// ç²’å­ç³»ç»Ÿå®¹å™¨
const particleGeo = new THREE.BufferGeometry();
const pCount = 3000;
const pPos = new Float32Array(pCount * 3);
const pVel = new Float32Array(pCount * 3);
const pSizes = new Float32Array(pCount);
particleGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
particleGeo.setAttribute('size', new THREE.BufferAttribute(pSizes, 1));
const particleMat = new THREE.PointsMaterial({
    map: createParticleTexture(),
    color: 0xffd700,
    size: 0.1,
    transparent: true,
    opacity: 0,
    depthWrite: false,
    blending: THREE.AdditiveBlending
});
const particles = new THREE.Points(particleGeo, particleMat);
scene.add(particles);

// åå¤„ç† (Bloom)
const composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));
const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
bloomPass.threshold = CONFIG.bloomThreshold;
bloomPass.strength = CONFIG.bloomStrength;
bloomPass.radius = 0.5;
composer.addPass(bloomPass);

// æŒ‡ç¤ºå™¨å…‰æ ‡ (è®©ç”¨æˆ·çŸ¥é“æ‰‹åœ¨å“ªé‡Œ)
const cursor = new THREE.Mesh(
    new THREE.SphereGeometry(0.05, 16, 16),
    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })
);
scene.add(cursor);

// ============================================================================
// 3. äº¤äº’é€»è¾‘ (æ‰‹åŠ¿ + Raycaster)
// ============================================================================

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function updateGestureLogic(landmarks) {
    // åæ ‡è½¬æ¢ (MediaPipe 0..1 -> WebGL -1..1)
    // æ³¨æ„ï¼švideo æ˜¯é•œåƒçš„ï¼Œx éœ€è¦åè½¬
    const indexTip = landmarks[8];
    const thumbTip = landmarks[4];
    const palm = landmarks[0];
    const middleTip = landmarks[12];
    
    STATE.handX = (1 - indexTip.x) * 2 - 1;
    STATE.handY = (1 - indexTip.y) * 2 - 1;

    // æ›´æ–°å…‰æ ‡ä½ç½® (æŠ•å°„åˆ°å‰æ–¹ä¸€ä¸ªå¹³é¢)
    const vector = new THREE.Vector3(STATE.handX, STATE.handY, 0.5);
    vector.unproject(camera);
    const dir = vector.sub(camera.position).normalize();
    const distance = 4; // å…‰æ ‡åœ¨ç›¸æœºå‰æ–¹4ç±³å¤„
    cursor.position.copy(camera.position).add(dir.multiplyScalar(distance));

    // 1. è®¡ç®—æ‰‹æŒç§»åŠ¨é€Ÿåº¦ (ç”¨äºæ—‹è½¬åœ†ç¯)
    const palmX = 1 - palm.x;
    const deltaX = palmX - STATE.lastPalmX;
    STATE.lastPalmX = palmX;

    // 2. è¯†åˆ«æ‰‹åŠ¿ç±»å‹
    const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
    const openDist = Math.hypot(indexTip.x - middleTip.x, indexTip.y - middleTip.y);

    if (STATE.mode === 'RING') {
        // æŒ¥åŠ¨æ£€æµ‹
        if (Math.abs(deltaX) > 0.015) {
            STATE.gesture = 'WAVE';
            // ç‰©ç†åŠ¨é‡ä¼ é€’
            STATE.rotVelocity += deltaX * 0.5; 
        } 
        // å±…ä¸­åœæ­¢æ£€æµ‹ (æ‰‹æŒå¼ å¼€ä¸”åœ¨ä¸­é—´)
        else if (openDist > 0.15 && Math.abs(STATE.handX) < 0.2) {
            STATE.gesture = 'BRAKE';
            STATE.rotVelocity *= 0.85; // å¼ºåŠ›åˆ¹è½¦
        }
        // æåˆæ£€æµ‹
        else if (pinchDist < 0.05) {
            STATE.gesture = 'PINCH';
            if (STATE.hoveredCard) {
                // é˜²æŠ–åŠ¨
                STATE.pinchTimer++;
                if (STATE.pinchTimer > 10) { // è¿ç»­10å¸§ä¿æŒæåˆ
                    drawCard(STATE.hoveredCard);
                    STATE.pinchTimer = 0;
                }
            }
        } 
        // æŒ‡å‘ / æ‚¬åœ
        else {
            STATE.gesture = 'HOVER';
            STATE.pinchTimer = 0;
            checkIntersection();
        }
    } else if (STATE.mode === 'VIEWING') {
        // å¼ æ‰‹æ£€æµ‹ -> æ¶ˆæ•£
        if (openDist > 0.15) {
            STATE.gesture = 'OPEN';
            dissolveCard();
        }
    }
}

// å°„çº¿æ£€æµ‹
function checkIntersection() {
    raycaster.setFromCamera({ x: STATE.handX, y: STATE.handY }, camera);
    // æ£€æµ‹ carouselGroup ä¸‹çš„æ‰€æœ‰å¡ç‰Œ
    const intersects = raycaster.intersectObjects(cards);

    if (intersects.length > 0) {
        const object = intersects[0].object;
        if (STATE.hoveredCard !== object) {
            STATE.hoveredCard = object;
        }
    } else {
        STATE.hoveredCard = null;
    }
}

// æ ¸å¿ƒåŠ¨ä½œï¼šæŠ½ç‰Œ
function drawCard(cardMesh) {
    if (STATE.mode !== 'RING') return;
    STATE.mode = 'DRAWING';
    STATE.viewingCard = cardMesh;
    STATE.hoveredCard = null;

    // 1. å°†å¡ç‰Œä» Group ä¸­å‰¥ç¦»ï¼Œè½¬æ¢åˆ° Scene åæ ‡ç³»ï¼Œä¿æŒè§†è§‰ä½ç½®ä¸å˜
    const worldPos = new THREE.Vector3();
    cardMesh.getWorldPosition(worldPos);
    const worldQuat = new THREE.Quaternion();
    cardMesh.getWorldQuaternion(worldQuat);

    scene.attach(cardMesh); // Three.js æ ¸å¿ƒé­”æ³•ï¼šä¿æŒä¸–ç•Œå˜æ¢çš„åŒæ—¶åˆ‡æ¢çˆ¶çº§

    // 2. åŠ¨ç”»åºåˆ— (GSAP)
    const tl = gsap.timeline({
        onComplete: () => {
            STATE.mode = 'VIEWING';
        }
    });

    // é£å‘ç›¸æœºå‰æ–¹
    const targetPos = new THREE.Vector3(0, 0, -3); // ç›¸æœºå‰æ–¹3ç±³
    targetPos.applyQuaternion(camera.quaternion);
    targetPos.add(camera.position);

    // ç¿»è½¬å¹¶ç§»åŠ¨
    tl.to(cardMesh.position, {
        x: targetPos.x,
        y: targetPos.y,
        z: targetPos.z,
        duration: 1.5,
        ease: "power2.inOut"
    }, 0);

    // æ—‹è½¬ï¼šZ+æœ¬æ¥æ˜¯æ­£é¢ï¼Œç°åœ¨æˆ‘ä»¬è¦è®© Z+ æœå‘ç›¸æœº
    // ç›¸æœºçœ‹ç€ -Z æ–¹å‘ã€‚æ‰€ä»¥å¡ç‰Œåº”è¯¥æ­£é¢æœå‘ +Z (å³ LookAt Camera)
    // ç®€å•çš„åšæ³•ï¼šè®©å¡ç‰Œ LookAt Camera
    
    // æˆ‘ä»¬æ‰‹åŠ¨è®¡ç®—ç›®æ ‡æ—‹è½¬ï¼š
    // å½“å‰èƒŒé¢æœå†…ï¼Œæˆ‘ä»¬å¸Œæœ›ç¿»è½¬ 180 åº¦ã€‚
    // è¿™é‡Œä½¿ç”¨ç›¸å¯¹æ—‹è½¬æ›´ç®€å•ï¼šç»• Y è½´è½¬ 180 åº¦
    const targetRotY = cardMesh.rotation.y + Math.PI; 

    tl.to(cardMesh.rotation, {
        x: 0, // ä¿®æ­£å€¾è§’
        y: targetRotY, 
        z: 0,
        duration: 1.2,
        ease: "back.out(1.2)"
    }, 0.2);

    // è¾‰å…‰å¢å¼º
    tl.to(bloomPass, { strength: 3.0, duration: 0.5, yoyo: true, repeat: 1 }, 0.5);
}

// æ ¸å¿ƒåŠ¨ä½œï¼šæ¶ˆæ•£
function dissolveCard() {
    if (STATE.mode !== 'VIEWING' || !STATE.viewingCard) return;
    STATE.mode = 'DISSOLVING';
    
    const card = STATE.viewingCard;
    const center = card.position.clone();

    // æ¿€æ´»ç²’å­ç³»ç»Ÿ
    const positions = particleGeo.attributes.position.array;
    const velocities = pVel;
    const sizes = particleGeo.attributes.size.array;

    for(let i=0; i<pCount; i++) {
        // é‡ç½®ç²’å­ä½ç½®åˆ°å¡ç‰Œä¸­å¿ƒé™„è¿‘
        positions[i*3] = center.x + (Math.random()-0.5)*1.4;
        positions[i*3+1] = center.y + (Math.random()-0.5)*2.3;
        positions[i*3+2] = center.z + (Math.random()-0.5)*0.1;
        
        // éšæœºçˆ†ç‚¸é€Ÿåº¦
        velocities[i*3] = (Math.random()-0.5) * 0.1;
        velocities[i*3+1] = (Math.random()-0.5) * 0.1;
        velocities[i*3+2] = (Math.random()-0.5) * 0.1;
        
        sizes[i] = Math.random() * 0.2;
    }
    
    particleMat.opacity = 1;
    particleGeo.attributes.position.needsUpdate = true;
    particleGeo.attributes.size.needsUpdate = true;
    
    // éšè—å¡ç‰Œå®ä½“
    card.visible = false;

    // å»¶è¿Ÿé‡ç½®
    setTimeout(resetRitual, 2500);
}

function resetRitual() {
    // å¤ä½å¡ç‰Œ
    const card = STATE.viewingCard;
    if (card) {
        carouselGroup.attach(card); // æ”¾å›è½¬ç›˜ç»„
        card.visible = true;
        // æ¢å¤åŸå§‹å±€éƒ¨åæ ‡
        card.position.copy(card.userData.basePos);
        card.rotation.copy(card.userData.baseRot);
        // æ¸…é™¤å‘å…‰çŠ¶æ€
        card.scale.set(1,1,1);
        card.material[5].emissive.setHex(0x000000);
    }

    STATE.viewingCard = null;
    STATE.mode = 'RING';
    STATE.rotVelocity = 0.002; // æ¢å¤å¾®åŠ¨
    bloomPass.strength = CONFIG.bloomStrength;
}

// ============================================================================
// 4. åŠ¨ç”»å¾ªç¯
// ============================================================================
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);

    // --- A. ç‰©ç†æ¨¡æ‹Ÿ (è½¬ç›˜) ---
    if (STATE.mode === 'RING') {
        // é˜»å°¼
        STATE.rotVelocity *= CONFIG.friction;
        
        // é™åˆ¶æœ€å¤§é€Ÿåº¦
        STATE.rotVelocity = THREE.MathUtils.clamp(STATE.rotVelocity, -CONFIG.maxVelocity, CONFIG.maxVelocity);
        
        // æœ€å°ä¿æŒä¸€ç‚¹ç‚¹è‡ªè½¬ï¼ˆç¥ç§˜æ„Ÿï¼‰
        if (Math.abs(STATE.rotVelocity) < 0.0005) {
            STATE.rotVelocity += (0.0005 - Math.abs(STATE.rotVelocity)) * 0.01 * Math.sign(STATE.rotVelocity || 1);
        }

        // åº”ç”¨æ—‹è½¬
        carouselGroup.rotation.y += STATE.rotVelocity;

        // --- B. å¡ç‰Œä¸ªä½“åŠ¨ç”» (Hover) ---
        cards.forEach(card => {
            if (card === STATE.hoveredCard) {
                // æ‚¬åœæ•ˆæœï¼šè½»å¾®æ”¾å¤§ï¼Œæœå‘åœ†å¿ƒè½»å¾®ç§»åŠ¨ï¼Œå‘å…‰
                const targetScale = 1.15;
                card.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                
                // é¢œè‰²é«˜äº® (Index 5 æ˜¯èƒŒé¢æè´¨)
                card.material[5].emissive.setHex(0x443300);
            } else {
                card.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                card.material[5].emissive.lerp(new THREE.Color(0x000000), 0.1);
            }
        });
    }

    // --- C. å±•ç¤ºæ¨¡å¼å¾®åŠ¨ ---
    if (STATE.mode === 'VIEWING' && STATE.viewingCard) {
        const t = clock.getElapsedTime();
        STATE.viewingCard.position.y += Math.sin(t * 2) * 0.001; // æ‚¬æµ®å‘¼å¸
        STATE.viewingCard.rotation.z = Math.sin(t) * 0.05;
    }

    // --- D. ç²’å­ç³»ç»Ÿæ›´æ–° ---
    if (STATE.mode === 'DISSOLVING') {
        const positions = particleGeo.attributes.position.array;
        const velocities = pVel;
        
        for(let i=0; i<pCount; i++) {
            positions[i*3] += velocities[i*3];
            positions[i*3+1] += velocities[i*3+1];
            positions[i*3+2] += velocities[i*3+2];
            
            // é˜»åŠ›
            velocities[i*3] *= 0.98;
            velocities[i*3+1] *= 0.98;
            velocities[i*3+2] *= 0.98;
        }
        particleGeo.attributes.position.needsUpdate = true;
        particleMat.opacity -= 0.015;
    }

    composer.render();
}

// ============================================================================
// 5. MediaPipe åˆå§‹åŒ–
// ============================================================================
const videoElement = document.getElementById('debug-video');
const loader = document.getElementById('loader');

const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
});

hands.onResults(results => {
    if (loader.style.opacity !== '0') loader.style.opacity = '0';
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        STATE.isHandVisible = true;
        cursor.visible = true;
        updateGestureLogic(results.multiHandLandmarks[0]);
    } else {
        STATE.isHandVisible = false;
        cursor.visible = false;
        STATE.gesture = 'NONE';
        STATE.hoveredCard = null;
    }
});

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 640,
    height: 480
});

// å¯åŠ¨
cameraUtils.start();
animate();

// çª—å£é€‚é…
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
