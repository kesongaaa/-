<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarot AR Experience</title>
    <style>
        :root {
            --gold: #d4af37;
            --bg: #050505;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Segoe UI', sans-serif;
            color: #fff;
            user-select: none;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI Layer */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        /* Result Overlay */
        #result-overlay {
            position: absolute; top: 15%; left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        #card-title { font-size: 2.5em; color: var(--gold); font-weight: bold; margin: 0; letter-spacing: 2px; }
        #card-desc { font-size: 1.2em; color: #ddd; margin-top: 10px; max-width: 600px; }
        
        /* Bottom Controls */
        #controls {
            padding: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: flex-end;
            pointer-events: auto;
        }
        .mode-btn {
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid var(--gold);
            color: var(--gold);
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
        }
        .mode-btn:hover { background: var(--gold); color: #000; }
        
        /* History Sidebar */
        #history {
            position: absolute; right: 0; top: 0; bottom: 0;
            width: 80px;
            background: rgba(0,0,0,0.5);
            overflow-y: auto;
            display: flex; flex-direction: column; align-items: center;
            padding-top: 20px;
            scrollbar-width: none;
        }
        .hist-img {
            width: 50px; height: 85px;
            margin-bottom: 15px;
            border: 1px solid #444;
            border-radius: 4px;
            opacity: 0.7;
            transition: 0.3s;
        }
        .hist-img:hover { opacity: 1; transform: scale(1.1); }
        .hist-rev { transform: rotate(180deg); }

        /* Loader */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
        }
        .loading-bar { width: 200px; height: 2px; background: #333; margin-top: 20px; }
        .progress { width: 0%; height: 100%; background: var(--gold); transition: width 0.2s; }
        
        #input_video { display: none; }
    </style>
    <!-- Imports -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loader">
    <div style="color:var(--gold); letter-spacing:3px;">INITIALIZING ORACLE</div>
    <div class="loading-bar"><div class="progress" id="load-progress"></div></div>
</div>

<div id="canvas-container"></div>
<video id="input_video"></video>

<div id="ui-layer">
    <div id="result-overlay">
        <div id="card-title"></div>
        <div id="card-desc"></div>
    </div>
    <div id="history"></div>
    <div id="controls">
        <div style="font-size:0.9em; opacity:0.8;">
            <span id="input-status">Detecting...</span><br>
            Gesture: Point to Hover • Pinch to Select
        </div>
        <button class="mode-btn" id="toggle-mode">Switch to Mouse</button>
    </div>
</div>

<script>
// --- Configuration ---
const CARD_WIDTH = 2.0;
const CARD_HEIGHT = 3.5;
const GAP = 0.5;
const TOTAL_CARDS = 5;
const MAX_PARTICLES = 4000;

// Tarot Data (Simplified RWS)
const TAROT_DB = [
    { name: "The Fool", url: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg", up: "新的开始, 冒险", rev: "鲁莽, 愚蠢" },
    { name: "The Magician", url: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg", up: "创造, 意志", rev: "欺骗, 混乱" },
    { name: "The Empress", url: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg", up: "丰饶, 母性", rev: "匮乏, 依赖" },
    { name: "The Emperor", url: "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg", up: "权威, 结构", rev: "暴政, 僵化" },
    { name: "The Lovers", url: "https://upload.wikimedia.org/wikipedia/commons/3/3a/TheLovers.jpg", up: "爱, 结合", rev: "分离, 冲突" },
    { name: "Death", url: "https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg", up: "结束, 转变", rev: "停滞, 恐惧" },
    { name: "The Moon", url: "https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg", up: "幻觉, 潜意识", rev: "混乱, 困惑" },
    { name: "The Sun", url: "https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg", up: "快乐, 成功", rev: "消沉, 失败" },
    { name: "The World", url: "https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg", up: "圆满, 完成", rev: "未完成, 遗憾" },
    { name: "Wheel of Fortune", url: "https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg", up: "命运, 周期", rev: "厄运, 阻碍" }
];

// --- Global Variables ---
let scene, camera, renderer, raycaster;
let cursorRing;
let cardSlots = new Array(TOTAL_CARDS).fill(null);
let particlesSystems = [];
let cursor3D = new THREE.Vector3();
let inputMode = 'hand'; // 'hand' or 'mouse'
let isPinching = false;
let mouse = new THREE.Vector2();
let hands, cameraUtils;

// --- Assets ---
const textureLoader = new THREE.TextureLoader();
const cardBackTexture = createProceduralTexture('#222', '#d4af37');

function createProceduralTexture(bgColor, patternColor) {
    const cvs = document.createElement('canvas');
    cvs.width = 256; cvs.height = 512;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = bgColor; ctx.fillRect(0,0,256,512);
    ctx.strokeStyle = patternColor; ctx.lineWidth = 5;
    ctx.strokeRect(10,10,236,492);
    ctx.beginPath(); ctx.arc(128,256,40,0,Math.PI*2); ctx.stroke();
    // Add some noise
    for(let i=0; i<100; i++) {
        ctx.fillStyle = patternColor;
        ctx.fillRect(Math.random()*256, Math.random()*512, 2, 2);
    }
    return new THREE.CanvasTexture(cvs);
}

// --- Initialization ---
function init() {
    // Scene Setup
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.03);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 8);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambient);
    
    const spot = new THREE.SpotLight(0xffeebb, 1);
    spot.position.set(0, 10, 5);
    spot.angle = 0.5;
    spot.penumbra = 0.5;
    spot.castShadow = true;
    scene.add(spot);

    const point = new THREE.PointLight(0xd4af37, 0.8, 20);
    point.position.set(0, 2, 5);
    scene.add(point);

    // Cursor Ring (The Glowing Ring from video)
    const ringGeo = new THREE.RingGeometry(0.15, 0.18, 32);
    const ringMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ffff, 
        transparent: true, 
        opacity: 0.8, 
        side: THREE.DoubleSide 
    });
    cursorRing = new THREE.Mesh(ringGeo, ringMat);
    cursorRing.position.z = 2; // In front of cards
    scene.add(cursorRing);

    raycaster = new THREE.Raycaster();

    // Initial Cards
    for (let i = 0; i < TOTAL_CARDS; i++) {
        spawnCard(i, true);
    }

    // Event Listeners
    window.addEventListener('resize', onResize);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mousedown', () => { if(inputMode==='mouse') isPinching = true; });
    document.addEventListener('mouseup', () => { if(inputMode==='mouse') isPinching = false; });
    document.getElementById('toggle-mode').addEventListener('click', toggleInputMode);

    // Finish Load
    document.getElementById('loader').style.display = 'none';
    animate();
}

// --- Card Logic ---
class Card {
    constructor(slotIndex, xPos) {
        this.slotIndex = slotIndex;
        this.state = 'idle'; // idle, hover, flipping, dead
        this.data = TAROT_DB[Math.floor(Math.random() * TAROT_DB.length)];
        this.isReversed = Math.random() < 0.5;
        
        // Geometry
        const geo = new THREE.BoxGeometry(CARD_WIDTH, CARD_HEIGHT, 0.05);
        const mats = [
            new THREE.MeshStandardMaterial({ color: 0x111 }), // sides
            new THREE.MeshStandardMaterial({ color: 0x111 }),
            new THREE.MeshStandardMaterial({ color: 0x111 }),
            new THREE.MeshStandardMaterial({ color: 0x111 }),
            new THREE.MeshStandardMaterial({ color: 0x111 }), // Front (initially blank)
            new THREE.MeshStandardMaterial({ map: cardBackTexture, metalness: 0.5, roughness: 0.5 }) // Back
        ];
        
        this.mesh = new THREE.Mesh(geo, mats);
        this.mesh.position.set(xPos, -8, 0); // Start below screen
        this.mesh.rotation.y = Math.PI; // Back facing
        this.targetY = 0;
        
        // Preload Image
        textureLoader.load(this.data.url, (tex) => {
            tex.encoding = THREE.sRGBEncoding;
            this.mesh.material[4].map = tex;
            this.mesh.material[4].needsUpdate = true;
        });

        scene.add(this.mesh);
        
        // Entry Animation
        this.animSpeed = 0.05 + Math.random() * 0.02;
    }

    update(dt, cursorIntersects) {
        if (this.state === 'dead') return;

        // Entry Float Up
        if (this.mesh.position.y < this.targetY) {
            this.mesh.position.y += (this.targetY - this.mesh.position.y) * 0.1;
        }

        // Logic based on state
        if (this.state === 'idle' || this.state === 'hover') {
            const isHovered = cursorIntersects && cursorIntersects.object === this.mesh;
            
            if (isHovered) {
                this.state = 'hover';
                this.mesh.position.z = THREE.MathUtils.lerp(this.mesh.position.z, 0.5, 0.2); // Pop out
                this.mesh.scale.setScalar(1.05);
                cursorRing.material.color.setHex(0xd4af37); // Gold cursor on hover
                cursorRing.scale.setScalar(1.2);

                if (isPinching) {
                    this.reveal();
                }
            } else {
                this.state = 'idle';
                this.mesh.position.z = THREE.MathUtils.lerp(this.mesh.position.z, 0, 0.1);
                this.mesh.scale.setScalar(1);
            }
        }
    }

    reveal() {
        if (this.state === 'flipping' || this.state === 'dead') return;
        this.state = 'flipping';
        
        // UI Update
        const title = this.data.name + (this.isReversed ? " (逆位)" : "");
        const desc = this.isReversed ? this.data.rev : this.data.up;
        
        const ui = document.getElementById('result-overlay');
        document.getElementById('card-title').innerText = title;
        document.getElementById('card-desc').innerText = desc;
        ui.style.opacity = 1;

        // Add to sidebar
        const img = document.createElement('img');
        img.src = this.data.url;
        img.className = 'hist-img' + (this.isReversed ? ' hist-rev' : '');
        document.getElementById('history').prepend(img);

        // Animation: Flip
        const targetRotZ = this.isReversed ? Math.PI : 0;
        const startRot = this.mesh.rotation.clone();
        let p = 0;
        
        const animateFlip = () => {
            p += 0.04;
            // Ease out cubic
            const ease = 1 - Math.pow(1 - p, 3);
            
            this.mesh.rotation.y = THREE.MathUtils.lerp(startRot.y, 0, ease); // Flip to front
            this.mesh.rotation.z = THREE.MathUtils.lerp(startRot.z, targetRotZ, ease);
            
            // Move closer to camera for inspection
            this.mesh.position.z = THREE.MathUtils.lerp(0.5, 2.5, ease);
            this.mesh.position.y = THREE.MathUtils.lerp(0, 1, ease);

            if (p < 1) requestAnimationFrame(animateFlip);
            else {
                // Wait then destroy
                setTimeout(() => this.disintegrate(), 2000);
            }
        };
        animateFlip();
    }

    disintegrate() {
        this.state = 'dead';
        document.getElementById('result-overlay').style.opacity = 0; // Hide text
        createAshEffect(this.mesh);
        scene.remove(this.mesh);
        
        // Respawn logic
        setTimeout(() => {
            cardSlots[this.slotIndex] = null;
            spawnCard(this.slotIndex);
        }, 1000);
    }
}

function spawnCard(index, immediate = false) {
    // Calculate X Position based on index (centered)
    // 0 1 2 3 4 -> -5 -2.5 0 2.5 5
    const totalW = (CARD_WIDTH * TOTAL_CARDS) + (GAP * (TOTAL_CARDS - 1));
    const startX = -(totalW / 2) + (CARD_WIDTH / 2);
    const x = startX + index * (CARD_WIDTH + GAP);
    
    cardSlots[index] = new Card(index, x);
}

// --- Ash Effect (Shader Particles) ---
function createAshEffect(mesh) {
    const geom = mesh.geometry.clone();
    const count = geom.attributes.position.count;
    
    // Create particle geometry
    const pGeo = new THREE.BufferGeometry();
    const positions = [];
    const speeds = [];
    
    // Sample points from the mesh box
    const matWorld = mesh.matrixWorld;
    
    // Increase density for better look
    for(let i=0; i<MAX_PARTICLES; i++) {
        // Random point inside volume roughly
        const x = (Math.random() - 0.5) * CARD_WIDTH;
        const y = (Math.random() - 0.5) * CARD_HEIGHT;
        const z = (Math.random() - 0.5) * 0.1;
        
        const v = new THREE.Vector3(x,y,z).applyMatrix4(matWorld);
        positions.push(v.x, v.y, v.z);
        
        speeds.push(
            (Math.random()-0.5)*0.05, // vx
            Math.random()*0.1 + 0.02, // vy (up)
            (Math.random()-0.5)*0.05  // vz
        );
    }
    
    pGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    pGeo.setAttribute('velocity', new THREE.Float32BufferAttribute(speeds, 3));
    
    const pMat = new THREE.PointsMaterial({
        color: 0xffaa00,
        size: 0.08,
        transparent: true,
        opacity: 1,
        blending: THREE.AdditiveBlending
    });
    
    const system = new THREE.Points(pGeo, pMat);
    scene.add(system);
    particlesSystems.push({ mesh: system, age: 0 });
}

function updateParticles() {
    for (let i = particlesSystems.length - 1; i >= 0; i--) {
        const sys = particlesSystems[i];
        sys.age += 0.02;
        
        const positions = sys.mesh.geometry.attributes.position.array;
        const velocities = sys.mesh.geometry.attributes.velocity.array;
        
        for(let j=0; j < positions.length / 3; j++) {
            // Update pos
            positions[j*3] += velocities[j*3];     // x
            positions[j*3+1] += velocities[j*3+1]; // y
            positions[j*3+2] += velocities[j*3+2]; // z
            
            // Turbulence
            velocities[j*3] += Math.sin(sys.age * 5 + j) * 0.001;
        }
        
        sys.mesh.geometry.attributes.position.needsUpdate = true;
        sys.mesh.material.opacity = 1 - sys.age;
        
        if (sys.age >= 1) {
            scene.remove(sys.mesh);
            particlesSystems.splice(i, 1);
        }
    }
}

// --- Input & MediaPipe ---
function initMediaPipe() {
    const video = document.getElementById('input_video');
    hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    
    hands.onResults((results) => {
        if(inputMode !== 'hand') return;
        if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            
            // Map Index finger tip to screen
            const x = (1 - lm[8].x) * 2 - 1;
            const y = (1 - lm[8].y) * 2 - 1;
            
            // Smooth lerp
            mouse.x += (x - mouse.x) * 0.3;
            mouse.y += (y - mouse.y) * 0.3;
            
            // Pinch detection (Thumb tip vs Index tip)
            const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            isPinching = dist < 0.05;
            
            document.getElementById('input-status').innerText = "Hand Detected";
            document.getElementById('input-status').style.color = "#0f0";
        } else {
            document.getElementById('input-status').innerText = "Searching Hand...";
            document.getElementById('input-status').style.color = "#888";
        }
    });

    cameraUtils = new Camera(video, {
        onFrame: async () => { if(inputMode === 'hand') await hands.send({image: video}); },
        width: 640, height: 480
    });
    cameraUtils.start();
}

function toggleInputMode() {
    const btn = document.getElementById('toggle-mode');
    if (inputMode === 'hand') {
        inputMode = 'mouse';
        btn.innerText = "Switch to Hand";
        document.getElementById('input-status').innerText = "Mouse Mode";
    } else {
        inputMode = 'hand';
        btn.innerText = "Switch to Mouse";
        // Reload page to reset camera cleanly if needed, or just resume
        if(!cameraUtils) initMediaPipe(); 
    }
}

function onMouseMove(e) {
    if (inputMode === 'mouse') {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    }
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// --- Main Loop ---
function animate() {
    requestAnimationFrame(animate);

    // Update Raycaster
    raycaster.setFromCamera(mouse, camera);
    
    // Update Cursor Ring Position
    // Project ray to a plane at z=0 (or slightly in front of cards)
    const targetZ = 0.5;
    const vec = new THREE.Vector3(mouse.x, mouse.y, 0.5);
    vec.unproject(camera);
    const dir = vec.sub(camera.position).normalize();
    const distance = (targetZ - camera.position.z) / dir.z;
    const pos = camera.position.clone().add(dir.multiplyScalar(distance));
    
    // Lerp cursor
    cursorRing.position.lerp(pos, 0.2);
    cursorRing.rotation.z += 0.02; // Spin effect
    cursorRing.rotation.x = (mouse.y * 0.5); // Tilt effect
    cursorRing.rotation.y = (mouse.x * 0.5);

    // Check Intersections
    // Only check active meshes
    const activeMeshes = cardSlots.filter(c => c && c.state !== 'dead').map(c => c.mesh);
    const intersects = raycaster.intersectObjects(activeMeshes);
    const hit = intersects.length > 0 ? intersects[0] : null;

    // Reset cursor color if no hit
    if (!hit) {
        cursorRing.material.color.setHex(0x00ffff);
        cursorRing.scale.setScalar(1);
    }

    // Update Cards
    cardSlots.forEach(card => {
        if (card) card.update(0.016, hit);
    });
    
    // Update Particles
    updateParticles();

    renderer.render(scene, camera);
}

// Boot
init();
initMediaPipe();

</script>
</body>
</html>
