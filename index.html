<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI æ‰‹åŠ¿æé€Ÿç‹‚é£™ (WebGL + MediaPipe)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        /* æ¸¸æˆç”»å¸ƒ */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ */
        }

        /* ä»ªè¡¨ç›˜ */
        .hud-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }
        
        .speed-box {
            font-size: 48px;
            font-weight: bold;
        }
        
        .label {
            font-size: 14px;
            opacity: 0.8;
        }

        /* çŠ¶æ€æ˜¾ç¤º */
        .status-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ (å³ä¸Šè§’) */
        .cam-preview {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #0ff;
            background: #000;
            z-index: 11;
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤º */
            border-radius: 8px;
            overflow: hidden;
        }

        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* å¼•å¯¼æç¤º */
        .guide {
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: right;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }

        /* åŠ è½½é®ç½© */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            color: #fff;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #0ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
    
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- å¼•å…¥ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

</head>
<body>

    <!-- åŠ è½½ç•Œé¢ -->
    <div id="loader">
        <div class="spinner"></div>
        <h2 id="loader-text">æ­£åœ¨åˆå§‹åŒ–å¼•æ“...</h2>
        <p>è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥ä½“éªŒæ‰‹åŠ¿æ§åˆ¶</p>
    </div>

    <!-- UI å±‚ -->
    <div id="ui-layer">
        <div class="status-panel">
            <div>ç³»ç»ŸçŠ¶æ€: <span id="sys-status" style="color:yellow">åˆå§‹åŒ–ä¸­...</span></div>
            <div>æ§åˆ¶æ¨¡å¼: <span id="ctrl-mode">ç­‰å¾…è¾“å…¥...</span></div>
            <div>è½¬å‘è§’åº¦: <span id="steer-val">0.00</span></div>
        </div>

        <div class="cam-preview">
            <video id="input_video" autoplay playsinline muted></video>
            <!-- Canvas ç”¨äºç»˜åˆ¶æ‰‹åŠ¿éª¨æ¶è°ƒè¯• (å¯é€‰ï¼Œä¸ºäº†æ€§èƒ½æ­¤å¤„ä¸ç»˜åˆ¶å¤æ‚éª¨æ¶) -->
        </div>

        <div class="hud-panel">
            <div class="label">SPEED (KM/H)</div>
            <div class="speed-box"><span id="speed-display">0</span></div>
        </div>

        <div class="guide">
            <h3>é©¾é©¶æŒ‡å—</h3>
            <p>ğŸ–ï¸ ä¸¾èµ·å•æ‰‹</p>
            <p>â¬…ï¸ æ‰‹å‘å·¦å€¾æ–œ = å·¦è½¬</p>
            <p>â¡ï¸ æ‰‹å‘å³å€¾æ–œ = å³è½¬</p>
            <p>âŒ¨ï¸ å¤‡ç”¨: é”®ç›˜å·¦å³é”®</p>
        </div>
    </div>

    <!-- æ¸¸æˆç”»å¸ƒå®¹å™¨ -->
    <div id="gameCanvas"></div>

<script>
/**
 * ============================================================================
 * ç¬¬ä¸€éƒ¨åˆ†ï¼šå…¨å±€å˜é‡ä¸é…ç½®
 * ============================================================================
 */
const CONFIG = {
    maxSpeed: 280,           // æœ€å¤§æ˜¾ç¤ºé€Ÿåº¦
    acceleration: 0.5,       // åŠ é€Ÿåº¦
    friction: 0.2,           // æ‘©æ“¦åŠ›
    turnSpeed: 0.08,         // è½¬å‘çµæ•åº¦
    roadWidth: 20,           // èµ›é“å®½åº¦é™åˆ¶
    cameraHeight: 2.5,       // æ‘„åƒæœºé«˜åº¦ï¼ˆæ¨¡æ‹Ÿé©¾é©¶ä½ï¼‰
    fovBase: 75,             // åŸºç¡€ FOV
    fovMax: 100,             // æé€Ÿæ—¶çš„ FOV
    colors: {
        skyTop: 0x000000,
        skyBottom: 0x220033,
        grid: 0xff00ff,
        road: 0x111111
    }
};

// æ¸¸æˆçŠ¶æ€
let gameState = {
    speed: 0,             // å½“å‰é€»è¾‘é€Ÿåº¦ (0 - 100)
    displaySpeed: 0,      // UIæ˜¾ç¤ºé€Ÿåº¦
    playerX: 0,           // ç©å®¶æ¨ªå‘ä½ç½®
    steerInput: 0,        // è½¬å‘è¾“å…¥ (-1 åˆ° 1)
    distance: 0,          // è¡Œé©¶è·ç¦»
    isCameraActive: false // æ‘„åƒå¤´æ˜¯å¦å¯ç”¨
};

// DOM å…ƒç´ 
const elSpeed = document.getElementById('speed-display');
const elStatus = document.getElementById('sys-status');
const elMode = document.getElementById('ctrl-mode');
const elSteer = document.getElementById('steer-val');
const elLoader = document.getElementById('loader');
const elLoaderText = document.getElementById('loader-text');

/**
 * ============================================================================
 * ç¬¬äºŒéƒ¨åˆ†ï¼šThree.js 3D åœºæ™¯æ„å»º
 * ============================================================================
 */
let scene, camera, renderer;
let roadMesh, gridMesh;
let roadsideObjects = [];
const OBJECT_POOL_SIZE = 40; // è·¯è¾¹ç‰©ä½“æ± å¤§å°

function initThreeJS() {
    // 1. åœºæ™¯ä¸ç›¸æœº
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(CONFIG.colors.skyBottom, 0.015); // é›¾æ•ˆå¢å¼ºé€Ÿåº¦æ„Ÿå’Œé®æŒ¡è¿œæ–¹
    scene.background = new THREE.Color(CONFIG.colors.skyBottom);

    camera = new THREE.PerspectiveCamera(CONFIG.fovBase, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, CONFIG.cameraHeight, 0);

    // 2. æ¸²æŸ“å™¨
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // æ€§èƒ½ä¼˜åŒ–
    document.getElementById('gameCanvas').appendChild(renderer.domElement);

    // 3. ç¯å…‰ (èµ›åšæœ‹å…‹ä¸éœ€è¦å¤ªé˜³å…‰ï¼Œä¸»è¦æ˜¯è‡ªå‘å…‰å’Œç¯å¢ƒå…‰)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    // 4. åˆ›å»ºè·¯é¢ (ä½¿ç”¨ç¨‹åºåŒ–çº¹ç†)
    const roadGeometry = new THREE.PlaneGeometry(40, 400, 10, 100);
    // ç”Ÿæˆæ²¥é’çº¹ç†
    const roadTexture = createProceduralTexture(); 
    roadTexture.wrapS = THREE.RepeatWrapping;
    roadTexture.wrapT = THREE.RepeatWrapping;
    roadTexture.repeat.set(1, 20);
    
    const roadMaterial = new THREE.MeshStandardMaterial({ 
        map: roadTexture, 
        color: 0x888888,
        roughness: 0.8 
    });
    roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
    roadMesh.rotation.x = -Math.PI / 2;
    roadMesh.position.z = -100; // å¾€å‰å»¶ä¼¸
    scene.add(roadMesh);

    // 5. åœ°é¢ç½‘æ ¼ (Retro Grid æ•ˆæœ)
    const gridHelper = new THREE.GridHelper(200, 100, CONFIG.colors.grid, 0x220044);
    gridHelper.position.y = -0.1;
    gridHelper.position.z = -50;
    scene.add(gridHelper);
    gridMesh = gridHelper;

    // 6. è·¯è¾¹ç‰©ä½“æ±  (å»ºç­‘ç‰©/æŸ±å­)
    const boxGeo = new THREE.BoxGeometry(1, 1, 1);
    const boxMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

    for(let i = 0; i < OBJECT_POOL_SIZE; i++) {
        const mesh = new THREE.Mesh(boxGeo, boxMat);
        // éšæœºåˆå§‹åŒ–ä½ç½® (åœ¨è§†é‡å¤–)
        resetObject(mesh, true);
        scene.add(mesh);
        roadsideObjects.push(mesh);
    }

    // ç›‘å¬çª—å£è°ƒæ•´
    window.addEventListener('resize', onWindowResize, false);
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºç¨‹åºåŒ–çº¹ç†ï¼ˆä»£æ›¿å›¾ç‰‡æ–‡ä»¶ï¼‰
function createProceduralTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    // èƒŒæ™¯è‰²
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, 512, 512);
    
    // æ‚è‰² (æ²¥é’æ„Ÿ)
    for(let i=0; i<5000; i++) {
        ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.1})`;
        ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
    }
    
    // è½¦é“çº¿
    ctx.fillStyle = '#fff';
    ctx.fillRect(250, 0, 12, 256); // è™šçº¿çš„ä¸€éƒ¨åˆ†
    ctx.fillRect(250, 300, 12, 212);

    // è¾¹ç¼˜çº¿
    ctx.fillStyle = '#ff0055';
    ctx.fillRect(10, 0, 10, 512);
    ctx.fillRect(492, 0, 10, 512);

    const texture = new THREE.CanvasTexture(canvas);
    return texture;
}

function resetObject(mesh, initial = false) {
    // å°†ç‰©ä½“æ”¾å›è¿œæ–¹
    mesh.position.z = initial ? -Math.random() * 300 : -300;
    // éšæœºæ”¾åœ¨å·¦ä¾§æˆ–å³ä¾§
    const side = Math.random() > 0.5 ? 1 : -1;
    mesh.position.x = side * (15 + Math.random() * 20); 
    mesh.position.y = Math.random() * 5; // éšæœºé«˜åº¦
    
    // éšæœºå¤§å°
    const scaleY = 2 + Math.random() * 10;
    const scaleXZ = 1 + Math.random() * 2;
    mesh.scale.set(scaleXZ, scaleY, scaleXZ);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/**
 * ============================================================================
 * ç¬¬ä¸‰éƒ¨åˆ†ï¼šMediaPipe Hands AI æ§åˆ¶
 * ============================================================================
 */
let handKeypoints = null;

function initMediaPipe() {
    elLoaderText.innerText = "åŠ è½½ AI æ¨¡å‹ä¸­ (å¯èƒ½éœ€è¦å‡ åç§’)...";
    
    const videoElement = document.getElementById('input_video');
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0, // 0 æ€§èƒ½æœ€å¥½ï¼Œ1 ç²¾åº¦æœ€å¥½ã€‚æ¸¸æˆç”¨0è¶³å¤Ÿ
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onHandsResults);

    // å¯åŠ¨æ‘„åƒå¤´
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    
    cameraUtils.start()
        .then(() => {
            elStatus.innerText = "æ‘„åƒå¤´å·²è¿æ¥";
            elStatus.style.color = "#0f0";
            gameState.isCameraActive = true;
            // éšè—åŠ è½½å±‚
            setTimeout(() => {
                elLoader.style.opacity = 0;
                setTimeout(() => elLoader.style.display = 'none', 500);
            }, 1000);
        })
        .catch(err => {
            console.error(err);
            elStatus.innerText = "æ‘„åƒå¤´å¤±è´¥ - åˆ‡æ¢è‡³é”®ç›˜æ¨¡å¼";
            elStatus.style.color = "#f00";
            gameState.isCameraActive = false;
            elMode.innerText = "é”®ç›˜ (æ–¹å‘é”®)";
            // å³ä½¿å¤±è´¥ä¹Ÿéšè—åŠ è½½å±‚
            elLoader.style.display = 'none';
        });
}

function onHandsResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handKeypoints = results.multiHandLandmarks[0];
        updateSteeringFromHand(handKeypoints);
        elMode.innerText = "AI æ‰‹åŠ¿æ§åˆ¶";
        elMode.style.color = "#0ff";
    } else {
        // å¦‚æœæ‰‹ç§»å‡ºç”»é¢ï¼Œç¼“æ…¢å›æ­£
        if (gameState.isCameraActive) {
            gameState.steerInput *= 0.9;
        }
    }
}

/**
 * æ ¸å¿ƒé€»è¾‘ï¼šä»æ‰‹éƒ¨å…³é”®ç‚¹è®¡ç®—è½¬å‘
 * é€»è¾‘ï¼šè®¡ç®—æ‰‹è…•(0)åˆ°ä¸­æŒ‡æŒ‡æ ¹(9)çš„å‘é‡è§’åº¦
 */
function updateSteeringFromHand(landmarks) {
    const wrist = landmarks[0];
    const middleBase = landmarks[9];

    // è®¡ç®—æ–œç‡å¸¦æ¥çš„è§’åº¦å˜åŒ–
    // x è½´æ–¹å‘å·®å¼‚ vs y è½´æ–¹å‘å·®å¼‚
    const dx = middleBase.x - wrist.x;
    const dy = middleBase.y - wrist.y;
    
    // è®¡ç®—æ—‹è½¬è§’ (å¼§åº¦)
    // æ­£å¸¸ç«–ç›´æ‰‹æŒæ—¶ï¼Œdy åº”è¯¥æ˜¯è´Ÿæ•° (yå‘ä¸‹ä¸ºæ­£)ï¼Œdxæ¥è¿‘0
    // æˆ‘ä»¬ç”¨ atan2 è®¡ç®—è§’åº¦ï¼Œç„¶åæ˜ å°„åˆ° -1 åˆ° 1
    // æ³¨æ„ï¼šMediaPipe x æ˜¯ 0(å·¦)-1(å³)ï¼Œy æ˜¯ 0(ä¸Š)-1(ä¸‹)
    
    // ç®€åŒ–ç®—æ³•ï¼šä»…ä»…æ ¹æ® x çš„åç§»é‡æ¥åˆ¤æ–­å€¾æ–œæ˜¯ä¸å¤Ÿçš„ï¼Œå› ä¸ºæ‰‹å¯ä»¥åœ¨å±å¹•ä»»ä½•ä½ç½®ã€‚
    // æˆ‘ä»¬éœ€è¦çš„æ˜¯æ‰‹æŒæœ¬èº«çš„å±€éƒ¨æ—‹è½¬ã€‚
    
    // è§’åº¦è®¡ç®—ï¼šä»¥æ‰‹è…•ä¸ºåŸç‚¹
    // å‚ç›´å‘ä¸Šæ—¶ angle çº¦ä¸º -PI/2 (-90åº¦)
    let angle = Math.atan2(dy, dx); 
    
    // è½¬æ¢åˆ°åº¦æ•°æ–¹ä¾¿è°ƒè¯•
    let degrees = angle * (180 / Math.PI);
    
    // æ­£å¸¸å‚ç›´æ˜¯ -90åº¦ã€‚
    // å‘å·¦å€¾æ–œï¼ˆé€†æ—¶é’ˆï¼‰ä¼šå˜æˆ -100, -120 ç­‰ã€‚
    // å‘å³å€¾æ–œï¼ˆé¡ºæ—¶é’ˆï¼‰ä¼šå˜æˆ -80, -60 ç­‰ã€‚
    
    // è®¾å®šé˜ˆå€¼ï¼š+- 45åº¦èŒƒå›´å†…æœ‰æ•ˆ
    // æ ‡å‡†å€¼ -90ã€‚ 
    // -45 (å³æé™) < -90 < -135 (å·¦æé™)
    
    let rawSteer = 0;
    const centerDeg = -90;
    const range = 45;

    // ç®€å•çš„æ­»åŒºå¤„ç†å’Œå½’ä¸€åŒ–
    let diff = degrees - centerDeg;
    
    // é’³åˆ¶èŒƒå›´
    if (diff > range) diff = range;
    if (diff < -range) diff = -range;
    
    // æ˜ å°„åˆ° -1 (å·¦) åˆ° 1 (å³)
    // æ³¨æ„ï¼šè§’åº¦å¢åŠ æ˜¯é¡ºæ—¶é’ˆ(å³)ï¼Œè§’åº¦å‡å°‘æ˜¯é€†æ—¶é’ˆ(å·¦)
    // diff positive -> Right turn
    // diff negative -> Left turn
    rawSteer = diff / range; 

    // å¢åŠ ä¸€ç‚¹æ­»åŒºï¼Œé˜²æ­¢æ‰‹æŠ–
    if (Math.abs(rawSteer) < 0.1) rawSteer = 0;

    // å¹³æ»‘æ’å€¼ (Lerp)
    gameState.steerInput += (rawSteer - gameState.steerInput) * 0.2;
}


/**
 * ============================================================================
 * ç¬¬å››éƒ¨åˆ†ï¼šé”®ç›˜ Fallback æ§åˆ¶
 * ============================================================================
 */
const keys = { left: false, right: false };
document.addEventListener('keydown', (e) => {
    if(e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if(e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if(!gameState.isCameraActive) elMode.innerText = "é”®ç›˜æ§åˆ¶ç”Ÿæ•ˆ";
});
document.addEventListener('keyup', (e) => {
    if(e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if(e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
});

function updateKeyboardSteer() {
    if (gameState.isCameraActive && handKeypoints) return; // å¦‚æœæœ‰æ‘„åƒå¤´ä¸”è¯†åˆ«åˆ°æ‰‹ï¼Œå¿½ç•¥é”®ç›˜

    let target = 0;
    if (keys.left) target = -1;
    if (keys.right) target = 1;

    // é”®ç›˜æ¨¡æ‹Ÿå¹³æ»‘
    gameState.steerInput += (target - gameState.steerInput) * 0.1;
}

/**
 * ============================================================================
 * ç¬¬äº”éƒ¨åˆ†ï¼šæ¸¸æˆä¸»å¾ªç¯ä¸ç‰©ç†
 * ============================================================================
 */

function updatePhysics() {
    // 1. è‡ªåŠ¨åŠ é€Ÿé€»è¾‘
    if (gameState.speed < 100) {
        gameState.speed += CONFIG.acceleration;
    }
    
    // è½¬å‘å¸¦æ¥çš„å‡é€Ÿ
    if (Math.abs(gameState.steerInput) > 0.3) {
        gameState.speed -= CONFIG.friction * Math.abs(gameState.steerInput);
    }
    if (gameState.speed < 0) gameState.speed = 0;

    // 2. æ›´æ–°æ˜¾ç¤ºé€Ÿåº¦
    gameState.displaySpeed = Math.floor((gameState.speed / 100) * CONFIG.maxSpeed);
    
    // 3. æ›´æ–°ç©å®¶æ¨ªå‘ä½ç½®
    // é€Ÿåº¦è¶Šå¿«ï¼Œè½¬å‘è¶Šæ•æ„Ÿï¼Œä½†å¹…åº¦é™åˆ¶
    let moveAmount = gameState.steerInput * CONFIG.turnSpeed * (gameState.speed / 50);
    gameState.playerX -= moveAmount; // æ³¨æ„ Three.js åæ ‡ç³»ï¼Œ-x æ˜¯å·¦
    
    // é™åˆ¶åœ¨èµ›é“å†…
    if (gameState.playerX > CONFIG.roadWidth) gameState.playerX = CONFIG.roadWidth;
    if (gameState.playerX < -CONFIG.roadWidth) gameState.playerX = -CONFIG.roadWidth;

    // 4. è®¡ç®—è¡Œé©¶è·ç¦»ï¼ˆç”¨äºçº¹ç†æ»šåŠ¨ï¼‰
    // ç®€å•ç´¯åŠ 
    gameState.distance += gameState.speed * 0.05;
}

function updateVisuals() {
    // 1. ç›¸æœºè·Ÿéš
    // ç›¸æœºä½ç½® = åŸºç¡€ä½ç½® + ç©å®¶åç§» (å»¶è¿Ÿè·Ÿéšæ•ˆæœ)
    camera.position.x += (gameState.playerX * 0.8 - camera.position.x) * 0.1;
    
    // 2. ç›¸æœºéœ‡åŠ¨ (åŸºäºé€Ÿåº¦)
    const shake = (gameState.speed / 100) * 0.05;
    camera.position.y = CONFIG.cameraHeight + (Math.random() - 0.5) * shake;
    
    // 3. FOV åŠ¨æ€å˜åŒ– (é€Ÿåº¦æ„Ÿæ ¸å¿ƒ)
    const targetFov = CONFIG.fovBase + (gameState.speed / 100) * (CONFIG.fovMax - CONFIG.fovBase);
    camera.fov += (targetFov - camera.fov) * 0.05;
    camera.updateProjectionMatrix();

    // 4. æ—‹è½¬ç›¸æœºæ¨¡æ‹Ÿè½¦è¾†å€¾æ–œ (Roll)
    camera.rotation.z = -gameState.steerInput * 0.1; // è½¬å‘æ—¶é•œå¤´å¾®å€¾
    // æ¨¡æ‹Ÿè½¦å¤´æŠ¬èµ·/ç‚¹å¤´ (Pitch) - æ²¡åŠ é€Ÿæ—¶ä¸ç®¡ï¼Œè¿™é‡Œç®€åŒ–
    
    // 5. åœ°é¢çº¹ç†æ»šåŠ¨
    if (roadMesh) {
        roadMesh.material.map.offset.y = -gameState.distance * 0.02; 
    }
    
    // 6. ç§»åŠ¨è·¯è¾¹ç‰©ä½“ (åˆ¶é€ ç›¸å¯¹è¿åŠ¨)
    roadsideObjects.forEach(obj => {
        // ç‰©ä½“å‘ç›¸æœºç§»åŠ¨ (Zè½´å¢åŠ )
        obj.position.z += gameState.speed * 0.8; 
        
        // å¦‚æœç‰©ä½“è·‘åˆ°ç›¸æœºåé¢äº†ï¼Œé‡ç½®åˆ°è¿œæ–¹
        if (obj.position.z > 10) {
            resetObject(obj);
        }
    });

    // 7. ç§»åŠ¨ Grid
    if(gridMesh) {
         gridMesh.position.z = -50 + (gameState.distance * 2) % 10;
    }
}

function updateUI() {
    elSpeed.innerText = gameState.displaySpeed;
    // ç®€å•çš„é¢œè‰²å˜åŒ–
    if (gameState.displaySpeed > 200) elSpeed.style.color = '#ff0055';
    else elSpeed.style.color = '#0ff';

    elSteer.innerText = gameState.steerInput.toFixed(2);
}

function animate() {
    requestAnimationFrame(animate);

    updateKeyboardSteer();
    updatePhysics();
    updateVisuals();
    updateUI();

    renderer.render(scene, camera);
}

/**
 * ============================================================================
 * å¯åŠ¨ç¨‹åº
 * ============================================================================
 */
(function main() {
    initThreeJS();
    initMediaPipe();
    animate();
})();

</script>
</body>
</html>
