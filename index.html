<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Tarot - Close Orbit</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg-color: #000000;
            --tech-green: #00ff9d;
            /* 1. 卡牌尺寸大幅增加，还原视频里的“巨大感” */
            --card-width: 260px;
            --card-height: 440px;
            /* 2. 半径缩小，把卡牌拉近到眼前 */
            --radius: 650px; 
        }

        body {
            margin: 0;
            background: var(--bg-color);
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: none;
            /* 3. 视距匹配，产生强烈的广角透视感 */
            perspective: 800px; 
        }

        /* 沉浸式暗角 */
        #vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, #000 100%);
            pointer-events: none; z-index: 50;
        }

        /* 画布层 */
        canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #bg-canvas { z-index: 0; }
        #effect-canvas { z-index: 60; }
        #hand-canvas { z-index: 70; opacity: 0.8; }

        /* 世界容器：你就在圆心 */
        #world-container {
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            transform-style: preserve-3d;
            z-index: 10;
        }

        .card-wrapper {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            left: calc(var(--card-width) * -0.5);
            top: calc(var(--card-height) * -0.5);
            transform-style: preserve-3d;
            /* 关键：确保背面对着圆心时可见 */
            backface-visibility: hidden; 
        }

        .card-face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden;
            border-radius: 16px; /* 更圆润的边角 */
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
        }

        /* 卡背 */
        .card-back {
            background: #0a0a0a;
            border: 3px solid #444; /* 加粗边框 */
            display: flex; justify-content: center; align-items: center;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        /* 卡背纹理 */
        .card-back::after {
            content: ''; width: 80%; height: 80%;
            border: 2px solid rgba(255,255,255,0.05);
            border-radius: 8px;
        }

        /* 选中状态：上浮 + 变大 + 绿光 */
        .card-wrapper.locked .card-back {
            border-color: var(--tech-green);
            box-shadow: 0 0 100px var(--tech-green), inset 0 0 30px var(--tech-green);
            /* 关键：不仅上浮(Y)，还向你靠近(Z) */
            transform: translateY(-80px) scale(1.1) translateZ(50px);
        }

        /* 卡面 */
        .card-front {
            background: #111;
            /* 预先旋转180度，因为它是背面朝你的 */
            transform: rotateY(180deg);
        }
        .card-front img { width: 100%; height: 100%; object-fit: cover; border-radius: 16px; }

        /* 抽出的卡牌 (UI层) */
        #active-card {
            position: fixed;
            width: var(--card-width);
            height: var(--card-height);
            top: 0; left: 0;
            transform-style: preserve-3d;
            z-index: 100;
            display: none;
            pointer-events: none;
        }
        
        #active-card .inner {
            width: 100%; height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1);
        }

        /* 翻转动画：绕Y轴转180 */
        #active-card.flipped .inner {
            transform: rotateY(180deg); 
        }

        #status-text {
            position: fixed; bottom: 12%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-size: 14px; letter-spacing: 2px;
            text-shadow: 0 0 10px #000; z-index: 80; font-weight: bold;
        }

        #webcam { display: none; }
    </style>
</head>
<body>

    <div id="status-text">SYSTEM READY</div>
    <div id="vignette"></div>

    <canvas id="bg-canvas"></canvas>
    <canvas id="effect-canvas"></canvas>
    <canvas id="hand-canvas"></canvas>
    
    <!-- 世界容器 -->
    <div id="world-container"></div>
    
    <!-- 抓取层 -->
    <div id="active-card">
        <div class="inner">
            <div class="card-face card-back"></div>
            <div class="card-face card-front"><img id="active-img" src=""></div>
        </div>
    </div>

    <video id="webcam" autoplay playsinline></video>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js";

        // 16 张牌，数量适中，配合较小的半径，刚好围成一圈
        const tarotImages = [
            "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Wands05.jpg/352px-Wands05.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/RWS_Tarot_07_Chariot.jpg/353px-RWS_Tarot_07_Chariot.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/RWS_Tarot_08_Strength.jpg/344px-RWS_Tarot_08_Strength.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Swords03.jpg/347px-Swords03.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/TheLovers.jpg/337px-TheLovers.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/RWS_Tarot_13_Death.jpg/327px-RWS_Tarot_13_Death.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/RWS_Tarot_15_Devil.jpg/337px-RWS_Tarot_15_Devil.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/RWS_Tarot_16_Tower.jpg/331px-RWS_Tarot_16_Tower.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/RWS_Tarot_17_Star.jpg/340px-RWS_Tarot_17_Star.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/RWS_Tarot_18_Moon.jpg/334px-RWS_Tarot_18_Moon.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/17/RWS_Tarot_19_Sun.jpg/336px-RWS_Tarot_19_Sun.jpg"
        ];

        let handLandmarker;
        const video = document.getElementById("webcam");
        const statusText = document.getElementById("status-text");
        const worldContainer = document.getElementById("world-container");
        const activeCard = document.getElementById("active-card");
        const activeImg = document.getElementById("active-img");
        const handCtx = document.getElementById("hand-canvas").getContext("2d");
        const effectCtx = document.getElementById("effect-canvas").getContext("2d");

        // 旋转参数
        let cameraAngle = 0;
        let rotateSpeed = 0;
        const MAX_ROTATE_SPEED = 2.0;
        
        // 游戏状态
        let handX = 0.5, handY = 0.5;
        let isPinching = false;
        let pinchLocked = false;
        
        const STATE = { IDLE: 0, GRABBED: 2, DISSOLVING: 3 };
        let gameState = STATE.IDLE;
        
        let cards = [];
        // 半径：650px (拉近了距离)
        const RADIUS = 650; 
        const ANGLE_STEP = 360 / tarotImages.length;

        async function init() {
            // 1. 构建世界
            tarotImages.forEach((url, i) => {
                const el = document.createElement("div");
                el.className = "card-wrapper";
                // 注意：卡牌是 rotateY(180deg) 的卡背，所以这里放卡背
                el.innerHTML = `<div class="card-face card-back"></div>`; 
                worldContainer.appendChild(el);
                
                const angle = i * ANGLE_STEP;
                // 先旋转角度，再推出去。由于我们站在圆心看，背对着圆心
                // 默认 0度 是 Z轴正向。
                el.style.transform = `rotateY(${angle}deg) translateZ(${RADIUS}px)`;
                
                cards.push({ el, angle, url });
            });

            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
            video.srcObject = stream;
            video.addEventListener("loadeddata", () => {
                resizeCanvas();
                animate();
                predict();
            });
        }

        let lastVideoTime = -1;
        async function predict() {
            let now = performance.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, now);
                
                handCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);

                if (results.landmarks && results.landmarks.length > 0) {
                    const lm = results.landmarks[0];
                    drawSkeleton(lm);

                    const indexTip = lm[8];
                    const thumbTip = lm[4];
                    // 镜像
                    handX = 1 - indexTip.x;
                    handY = indexTip.y;
                    
                    const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    isPinching = dist < 0.05;

                    handleInput();
                } else {
                    rotateSpeed *= 0.9;
                    isPinching = false;
                    unlockCard();
                }
            }
            requestAnimationFrame(predict);
        }

        /* --- 交互逻辑 --- */
        let lockedCardIndex = -1;

        function handleInput() {
            if (gameState === STATE.GRABBED) {
                handleGrabbed();
                return;
            }

            // 1. 旋转控制 (头控模拟)
            // 手放两边 -> 旋转
            if (handX < 0.3) {
                // 手在左，世界顺时针转 (感觉像往左看)
                const strength = (0.3 - handX) / 0.3;
                rotateSpeed = -strength * MAX_ROTATE_SPEED; 
                statusText.innerText = "<<< PANNING LEFT";
            } else if (handX > 0.7) {
                // 手在右，世界逆时针转
                const strength = (handX - 0.7) / 0.3;
                rotateSpeed = strength * MAX_ROTATE_SPEED;
                statusText.innerText = "PANNING RIGHT >>>";
            } else {
                rotateSpeed = 0;
            }

            // 2. 锁定与上浮 (Pointing)
            // 手在中间区域
            if (Math.abs(rotateSpeed) < 0.1 && handX >= 0.3 && handX <= 0.7) {
                rotateSpeed = 0;

                // 计算正前方的角度 ( -cameraAngle )
                let facingAngle = -cameraAngle % 360;
                if (facingAngle < 0) facingAngle += 360;

                // 找最近的牌
                let closestIdx = -1;
                let minDiff = 1000;

                cards.forEach((card, i) => {
                    let diff = Math.abs(card.angle - facingAngle);
                    if (diff > 180) diff = 360 - diff;
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIdx = i;
                    }
                });

                // 角度对准了，还要看食指是否指着它 (Y轴高度)
                // 容差 15度，高度在屏幕中部
                if (minDiff < 15 && handY > 0.3 && handY < 0.7) {
                    statusText.innerText = "LOCKED // PINCH TO PULL";
                    lockCard(closestIdx);
                } else {
                    statusText.innerText = "POINT TO SELECT";
                    unlockCard();
                }
            } else {
                unlockCard();
            }

            if (!isPinching) pinchLocked = false;
        }

        function lockCard(index) {
            if (lockedCardIndex !== index) {
                unlockCard();
                lockedCardIndex = index;
                cards[index].el.classList.add('locked');
            }
            // 捏合抽取
            if (isPinching && !pinchLocked) {
                extractCard(index);
            }
        }

        function unlockCard() {
            if (lockedCardIndex !== -1) {
                cards[lockedCardIndex].el.classList.remove('locked');
                lockedCardIndex = -1;
            }
        }

        function extractCard(index) {
            gameState = STATE.GRABBED;
            pinchLocked = true;
            statusText.innerText = "FATE REVEALED // OPEN HAND TO DISSOLVE";

            const data = cards[index];
            activeImg.src = data.url;
            activeCard.style.display = 'block';
            
            // 隐藏原位置卡牌
            data.el.style.opacity = 0;

            // 翻转并展示
            setTimeout(() => activeCard.classList.add('flipped'), 50);
        }

        function handleGrabbed() {
            // 卡牌跟随
            const x = handX * window.innerWidth;
            const y = handY * window.innerHeight;
            // 调整偏移，让卡牌在指尖下方一点，且放大
            activeCard.style.transform = `translate(${x - 130}px, ${y - 220}px) scale(1.1)`;

            // 释放检测
            if (!isPinching) {
                dissolve();
            }
        }

        function dissolve() {
            gameState = STATE.DISSOLVING;
            const rect = activeCard.getBoundingClientRect();
            spawnParticles(rect.left + rect.width/2, rect.top + rect.height/2);
            
            activeCard.style.display = 'none';
            activeCard.classList.remove('flipped');
            
            // 恢复原卡牌
            if (lockedCardIndex !== -1) {
                const el = cards[lockedCardIndex].el;
                setTimeout(() => {
                    el.style.opacity = 1;
                    el.classList.remove('locked');
                }, 300);
            }
            
            setTimeout(() => {
                gameState = STATE.IDLE;
                lockedCardIndex = -1;
            }, 500);
        }

        function animate() {
            // 旋转世界
            cameraAngle += rotateSpeed;
            // 关键：旋转世界容器，模拟自己在转
            worldContainer.style.transform = `rotateY(${cameraAngle}deg)`;
            
            updateParticles();
            requestAnimationFrame(animate);
        }

        /* --- 视觉特效 --- */
        let particles = [];
        function spawnParticles(x, y) {
            for(let i=0; i<80; i++) {
                const a = Math.random()*Math.PI*2, v = Math.random()*20+5;
                particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:1,color:'#00ff9d'});
            }
        }
        function updateParticles() {
            effectCtx.clearRect(0,0,window.innerWidth,window.innerHeight);
            for(let i=particles.length-1;i>=0;i--) {
                let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=0.03;
                if(p.life<=0) particles.splice(i,1);
                else { effectCtx.globalAlpha=p.life; effectCtx.fillStyle=p.color; effectCtx.beginPath(); effectCtx.arc(p.x,p.y,3,0,Math.PI*2); effectCtx.fill(); }
            }
            effectCtx.globalAlpha=1;
        }

        const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];
        function drawSkeleton(lm) {
            handCtx.lineWidth = 2; handCtx.lineCap = "round";
            handCtx.strokeStyle = "rgba(0, 255, 157, 0.4)";
            connections.forEach(([i,j])=>{
                const p1=lm[i],p2=lm[j];
                handCtx.beginPath();
                handCtx.moveTo((1-p1.x)*window.innerWidth,p1.y*window.innerHeight);
                handCtx.lineTo((1-p2.x)*window.innerWidth,p2.y*window.innerHeight);
                handCtx.stroke();
            });
            const cx=(1-lm[8].x)*window.innerWidth, cy=lm[8].y*window.innerHeight;
            handCtx.beginPath(); handCtx.arc(cx,cy,6,0,Math.PI*2); handCtx.fillStyle=isPinching?"#fff":"#00ff9d"; handCtx.fill();
        }

        function resizeCanvas() {
            const w=window.innerWidth, h=window.innerHeight;
            document.getElementById("bg-canvas").width=w; document.getElementById("bg-canvas").height=h;
            document.getElementById("effect-canvas").width=w; document.getElementById("effect-canvas").height=h;
            document.getElementById("hand-canvas").width=w; document.getElementById("hand-canvas").height=h;
        }
        window.onresize = resizeCanvas;

        init();
    </script>
</body>
</html>
