<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synthwave Horizon - AI æ‰‹åŠ¿ç«é€Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* æ¸¸æˆç”»å¸ƒ */
        #gameCanvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }

        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }

        /* é¡¶éƒ¨ HUD */
        .top-hud {
            position: absolute; top: 20px; left: 0; width: 100%;
            display: flex; justify-content: space-between; padding: 0 40px; box-sizing: border-box;
        }
        .status-box {
            background: rgba(0,0,0,0.6); border: 1px solid rgba(255, 0, 255, 0.5);
            padding: 10px 20px; border-radius: 4px; color: #fff; backdrop-filter: blur(4px);
        }
        .status-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: #555; margin-right: 8px; }
        .status-active { background: #0f0; box-shadow: 0 0 8px #0f0; }

        /* ä»ªè¡¨ç›˜ */
        .dashboard {
            position: absolute; bottom: 40px; right: 40px;
            text-align: right; transform: skewX(-10deg);
        }
        .speed-val { font-size: 80px; font-weight: 900; color: #fff; text-shadow: 4px 4px 0px #ff0055; line-height: 1; }
        .speed-unit { font-size: 20px; color: #0ff; letter-spacing: 2px; }
        
        /* æ‘„åƒå¤´å°çª— */
        .cam-frame {
            position: absolute; bottom: 40px; left: 40px;
            width: 160px; height: 120px;
            border: 2px solid #ff0055; background: #000;
            border-radius: 10px; overflow: hidden;
            transform: scaleX(-1); /* é•œåƒ */
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.3);
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }

        /* ä¸­å¿ƒæç¤º */
        .center-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; text-shadow: 0 0 10px #0ff;
            opacity: 0; transition: opacity 0.5s;
        }

        /* åŠ è½½é¡µ */
        #loader {
            position: absolute; inset: 0; background: #050510; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #0ff; font-family: monospace;
        }
        .loading-bar { width: 200px; height: 4px; background: #333; margin-top: 20px; border-radius: 2px; overflow: hidden; }
        .loading-fill { height: 100%; width: 0%; background: #ff0055; transition: width 0.3s; box-shadow: 0 0 10px #ff0055; }
    </style>

    <!-- ä¾èµ–åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <h1 style="text-shadow: 0 0 20px #0ff;">SYNTHWAVE RACER</h1>
        <p id="load-text">Initializing Neural Engine...</p>
        <div class="loading-bar"><div class="loading-fill" id="load-fill"></div></div>
    </div>

    <div id="ui-layer">
        <div class="top-hud">
            <div class="status-box">
                <span id="cam-dot" class="status-indicator"></span>
                <span id="ctrl-mode">WAITING...</span>
            </div>
            <div class="status-box" style="border-color: #0ff;">
                DISTANCE: <span id="dist-val">0</span> KM
            </div>
        </div>

        <div class="center-msg" id="msg-box">
            <h2>âš  SHARP CURVE AHEAD âš </h2>
        </div>

        <div class="cam-frame">
            <video id="input_video" autoplay playsinline muted></video>
        </div>

        <div class="dashboard">
            <div class="speed-val" id="speed-display">0</div>
            <div class="speed-unit">KM/H</div>
        </div>
    </div>

    <div id="gameCanvas"></div>

    <!-- é¡¶ç‚¹ç€è‰²å™¨ï¼šå¤„ç†é“è·¯å¼¯æ›² -->
    <script type="x-shader/x-vertex" id="roadVertexShader">
        uniform float uTime;
        uniform float uCurve;     // å¼¯é“å¼¯æ›²ç¨‹åº¦
        uniform float uOffset;    // çº¹ç†æ»šåŠ¨åç§»
        
        varying vec2 vUv;
        varying float vFogDepth;

        void main() {
            vUv = uv + vec2(0.0, uOffset); // çº¹ç†æ»šåŠ¨
            
            vec3 pos = position;
            
            // æ ¸å¿ƒå¼¯æ›²é€»è¾‘ï¼š
            // è·ç¦»æ‘„åƒæœºè¶Šè¿œ (zè½´è´Ÿæ–¹å‘)ï¼Œxè½´åç§»è¶Šå¤§
            // è¿™æ˜¯ä¸€ä¸ªæŠ›ç‰©çº¿åç§»ï¼š x += curve * z^2
            // æˆ‘ä»¬åªåœ¨ä¸–ç•Œåæ ‡çš„è´ŸZè½´æ–¹å‘å¼¯æ›²
            
            // æŠŠæ¨¡å‹ç©ºé—´çš„Zè½¬ä¸ºä¸–ç•Œç©ºé—´çš„ç›¸å¯¹è·ç¦»
            float zDist = abs(pos.z);
            
            // å¼¯æ›²å…¬å¼
            float curveAmount = uCurve * (zDist * zDist) * 0.0002;
            pos.x += curveAmount;

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            
            // ç®€å•çš„é›¾æ•ˆæ·±åº¦
            vFogDepth = -mvPosition.z;
        }
    </script>

    <!-- ç‰‡å…ƒç€è‰²å™¨ï¼šé“è·¯çº¹ç†æ··åˆ -->
    <script type="x-shader/x-fragment" id="roadFragmentShader">
        uniform sampler2D uMap;
        varying vec2 vUv;
        varying float vFogDepth;

        void main() {
            vec4 texColor = texture2D(uMap, vUv);
            
            // é›¾æ•ˆé¢œè‰² (æ·±ç´«è‰²)
            vec3 fogColor = vec3(0.1, 0.0, 0.2);
            float fogDensity = 0.015;
            float fogFactor = 1.0 - exp( -fogDensity * fogDensity * vFogDepth * vFogDepth );
            
            gl_FragColor = mix(texColor, vec4(fogColor, 1.0), fogFactor);
        }
    </script>

<script>
/**
 * å…¨å±€é…ç½®
 */
const CONFIG = {
    roadWidth: 20,
    segmentLength: 400,
    speedMax: 320,
    accel: 0.8,
    brake: 0.3,
    colors: {
        sky: 0x0b0015,
        grid: 0xff00cc,
        fog: 0x180025
    }
};

/**
 * æ¸¸æˆçŠ¶æ€
 */
const GAME = {
    speed: 0,          // 0-100 é€»è¾‘é€Ÿåº¦
    realSpeed: 0,      // æ˜¾ç¤ºé€Ÿåº¦
    playerX: 0,        // ç©å®¶ä½ç½®
    steer: 0,          // è½¬å‘è¾“å…¥ (-1 left, 1 right)
    curve: 0,          // å½“å‰å®é™…è·¯é¢å¼¯æ›²åº¦
    targetCurve: 0,    // ç›®æ ‡å¼¯æ›²åº¦ (éšæœºç”Ÿæˆ)
    distance: 0,       // æ€»é‡Œç¨‹
    time: 0,
    mode: 'keyboard'   // 'keyboard' | 'camera'
};

let scene, camera, renderer;
let roadMaterial, roadMesh;
let envMeshes = []; // è£…é¥°ç‰© InstancedMeshes
let terrainMesh;

// DOM
const uiSpeed = document.getElementById('speed-display');
const uiDist = document.getElementById('dist-val');
const uiMode = document.getElementById('ctrl-mode');
const uiCamDot = document.getElementById('cam-dot');
const loadBar = document.getElementById('load-fill');
const loader = document.getElementById('loader');

/**
 * 1. åˆå§‹åŒ– 3D åœºæ™¯ (Synthwave é£æ ¼)
 */
function initScene() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(CONFIG.colors.sky);
    // é›¾æ•ˆé…åˆç€è‰²å™¨é›¾æ•ˆ
    scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.01);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 0); // åå§¿

    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('gameCanvas').appendChild(renderer.domElement);

    // --- A. é“è·¯ (Shader Material) ---
    const roadGeo = new THREE.PlaneGeometry(30, CONFIG.segmentLength, 20, 100);
    roadGeo.rotateX(-Math.PI / 2);
    // å°†é“è·¯å‡ ä½•ä½“å‘å‰æ¨ï¼Œä¿è¯åŸç‚¹åœ¨è½¦åº•ä¸‹
    roadGeo.translate(0, 0, -CONFIG.segmentLength / 2);

    const roadTexture = createRoadTexture();
    
    roadMaterial = new THREE.ShaderMaterial({
        uniforms: {
            uMap: { value: roadTexture },
            uTime: { value: 0 },
            uOffset: { value: 0 },
            uCurve: { value: 0 }
        },
        vertexShader: document.getElementById('roadVertexShader').textContent,
        fragmentShader: document.getElementById('roadFragmentShader').textContent,
    });

    roadMesh = new THREE.Mesh(roadGeo, roadMaterial);
    scene.add(roadMesh);

    // --- B. èƒŒæ™¯è£…é¥° (InstancedMesh ç²’å­æµ) ---
    // æˆ‘ä»¬åˆ›å»ºä¸¤ä¸ªInstancedMeshï¼šä¸€ä¸ªåšåœ°é¢çš„ç½‘æ ¼çº¿/ç¢ç‰‡ï¼Œä¸€ä¸ªåšç©ºä¸­çš„éœ“è™¹æŸ±
    createEnvironmentObjects();

    // --- C. è¿œæ™¯å¤å¤å¤ªé˜³ ---
    const sunGeo = new THREE.CircleGeometry(40, 32);
    const sunMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    sun.position.set(0, 20, -300);
    scene.add(sun);
    
    // å¤ªé˜³å…‰æ™•
    const sunLight = new THREE.PointLight(0xff0055, 1, 500);
    sunLight.position.set(0, 30, -200);
    scene.add(sunLight);

    // --- D. åœ°å½¢ (Wireframe Terrain) ---
    const terrGeo = new THREE.PlaneGeometry(400, 400, 40, 40);
    terrGeo.rotateX(-Math.PI/2);
    terrGeo.translate(0, -5, -150);
    
    // åˆ¶é€ èµ·ä¼
    const pos = terrGeo.attributes.position;
    for(let i=0; i<pos.count; i++) {
        const x = pos.getX(i);
        const z = pos.getZ(i);
        if(Math.abs(x) < 20) {
             pos.setY(i, -10); // æŒ–ç©ºé“è·¯éƒ¨åˆ†
        } else {
             pos.setY(i, Math.sin(x*0.1) * 5 + Math.cos(z*0.05)*5);
        }
    }
    terrGeo.computeVertexNormals();
    
    const terrMat = new THREE.MeshBasicMaterial({ 
        color: 0x440066, 
        wireframe: true,
        transparent: true,
        opacity: 0.3
    });
    terrainMesh = new THREE.Mesh(terrGeo, terrMat);
    scene.add(terrainMesh);

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function createRoadTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');

    // æ²¥é’åº•è‰²
    ctx.fillStyle = '#111';
    ctx.fillRect(0,0,512,512);

    // æ‚è‰²
    for(let i=0;i<2000;i++){
        ctx.fillStyle = Math.random()>0.5 ? '#222' : '#000';
        ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
    }

    // å·¦å³è¾¹ç¼˜å‘å…‰å¸¦
    ctx.fillStyle = '#ff00aa';
    ctx.fillRect(0,0,10,512);
    ctx.fillRect(502,0,10,512);

    // ä¸­é—´è½¦é“çº¿
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.fillRect(250, 0, 12, 256); // åªæœ‰ä¸ŠåŠéƒ¨åˆ†ï¼Œrepeatæ—¶å½¢æˆè™šçº¿

    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.anisotropy = 16;
    return tex;
}

/**
 * åˆ›å»ºå¤§é‡è·¯è¾¹ç‰©ä½“ (æ€§èƒ½ä¼˜åŒ–å…³é”®)
 */
function createEnvironmentObjects() {
    // 1. éœ“è™¹æŸ±å­ (Cube)
    const count = 400;
    const geo = new THREE.BoxGeometry(1, 10, 1);
    geo.translate(0, 5, 0); // æ¢è½´åœ¨åº•éƒ¨
    const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
    const mesh = new THREE.InstancedMesh(geo, mat, count);
    
    const dummy = new THREE.Object3D();
    const data = []; // å­˜å‚¨è‡ªå®šä¹‰æ•°æ® {x, z, speed}

    for(let i=0; i<count; i++) {
        // éšæœºåˆ†å¸ƒåœ¨é“è·¯ä¸¤ä¾§
        const side = Math.random() > 0.5 ? 1 : -1;
        const xStr = 20 + Math.random() * 80;
        const x = side * xStr;
        const z = -Math.random() * 500; // æ·±åº¦åˆ†å¸ƒ
        
        dummy.position.set(x, 0, z);
        dummy.scale.set(1, 0.5 + Math.random()*2, 1); // éšæœºé«˜åº¦
        dummy.updateMatrix();
        mesh.setMatrixAt(i, dummy.matrix);
        
        // å­˜å‚¨åˆå§‹ç›¸å¯¹ä½ç½®ï¼Œç”¨äºå¾ªç¯æ»šåŠ¨
        data.push({ x: x, z: z, initialX: x });
    }
    
    mesh.userData = { items: data }; // ç»‘å®šæ•°æ®
    scene.add(mesh);
    envMeshes.push(mesh);
}


/**
 * 2. MediaPipe é€»è¾‘
 */
let handLandmarks = null;
async function initAI() {
    loadBar.style.width = '30%';
    
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0, // Lite æ¨¡å‹
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
        if(results.multiHandLandmarks.length > 0) {
            handLandmarks = results.multiHandLandmarks[0];
            GAME.mode = 'camera';
            uiMode.innerText = "AI CONTROL ACTIVE";
            uiMode.style.color = "#0f0";
            uiCamDot.classList.add('status-active');
        } else {
            // å¦‚æœæ‰‹åŠ¿ä¸¢å¤±ï¼Œç¼“æ…¢å›æ­£
            if(GAME.mode === 'camera') GAME.steer *= 0.9;
            uiCamDot.classList.remove('status-active');
        }
    });

    const video = document.getElementById('input_video');
    const camera = new Camera(video, {
        onFrame: async () => {
            await hands.send({image: video});
        },
        width: 320, height: 240
    });

    loadBar.style.width = '70%';
    try {
        await camera.start();
        loadBar.style.width = '100%';
        setTimeout(() => {
            loader.style.opacity = '0';
            setTimeout(()=>loader.style.display='none', 500);
        }, 500);
    } catch(e) {
        console.error(e);
        uiMode.innerText = "CAMERA FAILED - USE KEYBOARD";
        loader.style.display='none';
    }
}

/**
 * 3. æ¸¸æˆæ ¸å¿ƒé€»è¾‘
 */

// é”®ç›˜è¾“å…¥
const keys = { Left: false, Right: false, Up: false, Down: false };
document.addEventListener('keydown', e => {
    if(e.code === 'ArrowLeft' || e.code === 'KeyA') keys.Left = true;
    if(e.code === 'ArrowRight' || e.code === 'KeyD') keys.Right = true;
    if(e.code === 'ArrowUp' || e.code === 'KeyW') keys.Up = true;
    
    // æŒ‰é”®ç›˜è‡ªåŠ¨åˆ‡æ¨¡å¼
    if(GAME.mode === 'camera') {
        GAME.mode = 'keyboard';
        uiMode.innerText = "KEYBOARD OVERRIDE";
        uiMode.style.color = "yellow";
    }
});
document.addEventListener('keyup', e => {
    if(e.code === 'ArrowLeft' || e.code === 'KeyA') keys.Left = false;
    if(e.code === 'ArrowRight' || e.code === 'KeyD') keys.Right = false;
    if(e.code === 'ArrowUp' || e.code === 'KeyW') keys.Up = false;
});

function updatePhysics() {
    // --- 1. é€Ÿåº¦æ§åˆ¶ ---
    // è‡ªåŠ¨åŠ é€Ÿ + é”®ç›˜åŠ é€Ÿ
    let targetSpeed = 100; // åŸºç¡€å·¡èˆªé€Ÿåº¦
    if (keys.Up) targetSpeed = 150; // æŒ‰ä½ä¸Šé”®æé€Ÿ
    
    if (GAME.speed < targetSpeed) GAME.speed += CONFIG.accel;
    
    // è½¬å‘å‡é€Ÿ
    if (Math.abs(GAME.steer) > 0.3) GAME.speed -= CONFIG.brake * Math.abs(GAME.steer);
    
    // æ˜¾ç¤ºé€Ÿåº¦ (åŠ ç‚¹éšæœºæŠ–åŠ¨æ¨¡æ‹ŸçœŸå®åº¦)
    GAME.realSpeed = Math.floor(GAME.speed * 2.5 + Math.random()*2);
    
    // --- 2. è½¬å‘è¾“å…¥è®¡ç®— ---
    let input = 0;
    
    if (GAME.mode === 'camera' && handLandmarks) {
        // AI æ‰‹åŠ¿é€»è¾‘ï¼šè®¡ç®—æ‰‹è…•(0)åˆ°ä¸­æŒ‡(9)çš„è§’åº¦
        const p0 = handLandmarks[0];
        const p9 = handLandmarks[9];
        const dx = p9.x - p0.x;
        const dy = p9.y - p0.y;
        
        // è®¡ç®—å€¾æ–œè§’ (0 æ˜¯å‚ç›´å‘ä¸Š)
        // atan2(dy, dx) -> å‚ç›´å‘ä¸Šæ˜¯ -PI/2
        const angle = Math.atan2(dy, dx); 
        const deg = angle * (180/Math.PI);
        
        // æ ‡å‡†å‚ç›´æ˜¯ -90åº¦
        // å‘å·¦å€¾ < -100, å‘å³å€¾ > -80
        const diff = deg - (-90);
        
        // æ˜ å°„å¹¶é™åˆ¶å¹…åº¦ (-45åº¦ åˆ° +45åº¦)
        input = diff / 45; 
        if(input > 1) input = 1;
        if(input < -1) input = -1;
        if(Math.abs(input) < 0.1) input = 0; // æ­»åŒº
        
    } else {
        // é”®ç›˜
        if(keys.Left) input = -1;
        if(keys.Right) input = 1;
    }
    
    // å¹³æ»‘è½¬å‘
    GAME.steer += (input - GAME.steer) * 0.1;

    // --- 3. å¼¯é“ç”Ÿæˆé€»è¾‘ ---
    GAME.time += 0.01;
    // æ¯éš”ä¸€æ®µæ—¶é—´æ”¹å˜å¼¯é“ç›®æ ‡
    if (Math.floor(GAME.time) % 8 === 0 && Math.random() < 0.05) {
        GAME.targetCurve = (Math.random() - 0.5) * 60; // éšæœºå¼¯åº¦
    }
    // å¼¯é“æ’å€¼
    GAME.curve += (GAME.targetCurve - GAME.curve) * 0.01;

    // --- 4. ç¦»å¿ƒåŠ›ä¸ä½ç§» ---
    // æ ¸å¿ƒç©æ³•ï¼šå¦‚æœå¼¯é“å‘å³(Curve>0)ï¼Œç©å®¶ä¼šè¢«æ¨å‘å·¦è¾¹(-X)
    // ç©å®¶éœ€è¦å‘å³è½¬å‘(Steer>0)æ¥æŠµæ¶ˆ
    
    const centrifugalForce = -GAME.curve * (GAME.speed / 100) * 0.8;
    const turnForce = GAME.steer * (GAME.speed / 100) * 1.5;
    
    GAME.playerX += turnForce + centrifugalForce;
    
    // é™åˆ¶åœ¨è·¯é¢ä¸Š
    if(GAME.playerX > CONFIG.roadWidth) GAME.playerX = CONFIG.roadWidth;
    if(GAME.playerX < -CONFIG.roadWidth) GAME.playerX = -CONFIG.roadWidth;

    GAME.distance += GAME.speed * 0.001;
}

function updateVisuals() {
    // 1. æ›´æ–° HUD
    uiSpeed.innerText = GAME.realSpeed;
    uiDist.innerText = GAME.distance.toFixed(1);

    // 2. æ›´æ–°é“è·¯ Shader
    // çº¹ç†æ»šåŠ¨ (æ¨¡æ‹Ÿå‰è¿›)
    roadMaterial.uniforms.uOffset.value -= GAME.speed * 0.001; 
    // å¼¯é“å‚æ•°
    roadMaterial.uniforms.uCurve.value = GAME.curve;

    // 3. æ‘„åƒæœºåŠ¨æ€
    // ä½ç½®ï¼šè·Ÿéšç©å®¶Xï¼Œä½†æœ‰å»¶è¿Ÿ
    camera.position.x += (GAME.playerX * 0.5 - camera.position.x) * 0.1;
    
    // FOVï¼šé€Ÿåº¦è¶Šå¿« FOV è¶Šå¤§
    const targetFov = 60 + (GAME.speed / 100) * 30;
    camera.fov += (targetFov - camera.fov) * 0.1;
    camera.updateProjectionMatrix();

    // éœ‡åŠ¨
    const shake = (GAME.speed/200) * 0.05;
    camera.position.y = 3 + (Math.random()-0.5)*shake;
    // å€¾æ–œ (Roll): è½¬å‘æ—¶é•œå¤´å€¾æ–œ
    camera.rotation.z = -GAME.steer * 0.15 - (GAME.curve * 0.002);

    // 4. æ›´æ–°ç¯å¢ƒç‰©ä½“ (å¼¯æ›²æ•ˆæœåŒæ­¥)
    const dummy = new THREE.Object3D();
    const curveStrength = GAME.curve * 0.0002; // å¿…é¡»ä¸ Shader ä¸­çš„ç³»æ•°ä¸€è‡´
    
    envMeshes.forEach(mesh => {
        const data = mesh.userData.items;
        
        for(let i=0; i<mesh.count; i++) {
            const item = data[i];
            
            // æ¨¡æ‹Ÿ Z è½´ç§»åŠ¨
            item.z += GAME.speed * 0.5; // ç‰©ä½“å‘ç›¸æœºè·‘æ¥
            
            // å¾ªç¯é‡ç½®
            if(item.z > 10) {
                item.z = -500; // æ”¾åˆ°æœ€è¿œå¤„
                // é‡ç½®æ—¶å¯ä»¥éšæœºå¾®è°ƒä¸€ä¸‹ä½ç½®ï¼Œå¢åŠ å˜åŒ–
                item.initialX = (Math.random()>0.5?1:-1) * (20 + Math.random()*80);
            }
            
            // è®¡ç®—å¼¯æ›²åçš„ X ä½ç½®
            // X = åŸå§‹X + å¼¯æ›²åç§»(åŸºäºZè·ç¦»)
            // è¿™é‡Œçš„ item.z æ˜¯ä¸–ç•Œåæ ‡ã€‚å› ä¸ºç‰©ä½“å‘æˆ‘ä»¬è·‘æ¥ï¼Œz ä» -500 å˜åˆ° 0ã€‚
            // Shader é‡Œæ˜¯ dist = abs(z)ã€‚
            const zDist = Math.abs(item.z);
            const xOffset = GAME.curve * (zDist * zDist) * 0.0002;
            
            dummy.position.set(item.initialX + xOffset, 0, item.z);
            
            // ç¨å¾®æ ¹æ®å¼¯æ›²æ—‹è½¬ä¸€ç‚¹ç‰©ä½“
            dummy.rotation.y = GAME.curve * zDist * 0.00005;
            
            // è·å–ä¹‹å‰ä¿å­˜çš„ scale (è¿™é‡Œç®€å•å¤„ç†ï¼Œé‡æ–°è®¾ä¸€ä¸‹)
            // ä¸ºäº†æ›´ä¸°å¯Œçš„æ•ˆæœï¼Œåº”è¯¥åœ¨ data é‡Œå­˜ scaleï¼Œè¿™é‡Œç®€åŒ–äº†
            dummy.scale.set(1, 4 + Math.sin(i)*2, 1);
            
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
        }
        mesh.instanceMatrix.needsUpdate = true;
    });

    // 5. åœ°å½¢åŒæ­¥ (ç®€å•ç§»åŠ¨ï¼Œä¸åšå¤æ‚å¼¯æ›²ï¼ŒåªåšèƒŒæ™¯)
    if(terrainMesh) {
        // è®©åœ°å½¢ç¼“ç¼“åé€€
        terrainMesh.position.z += GAME.speed * 0.5;
        if(terrainMesh.position.z > -50) terrainMesh.position.z = -250;
        
        // ç¨å¾®æ ¹æ®å¼¯é“å€¾æ–œåœ°å½¢
        terrainMesh.rotation.z = -GAME.curve * 0.001;
    }

    // 6. è­¦å‘Šæç¤º
    const msgBox = document.getElementById('msg-box');
    if(Math.abs(GAME.curve) > 20) {
        msgBox.style.opacity = 1;
        msgBox.innerHTML = GAME.curve > 0 ? "ğŸ‘‰ RIGHT TURN ğŸ‘‰" : "ğŸ‘ˆ LEFT TURN ğŸ‘ˆ";
    } else {
        msgBox.style.opacity = 0;
    }
}

function animate() {
    requestAnimationFrame(animate);
    updatePhysics();
    updateVisuals();
    renderer.render(scene, camera);
}

// å¯åŠ¨
initScene();
initAI(); // å¼‚æ­¥åŠ è½½
animate();

</script>
</body>
</html>
