<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Tarot - Ultimate</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>
    <style>
        /* --- 1. 极致黑夜美学 --- */
        :root {
            --bg-color: #000000;
            --card-glow: rgba(255, 255, 255, 0.15);
            --accent-green: #00ff9d; /* 视频同款荧光绿 */
            --card-width: 160px;
            --card-height: 280px;
        }

        body {
            margin: 0;
            background: var(--bg-color);
            color: #fff;
            font-family: 'Courier New', monospace; /* 科技感字体 */
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: none; /* 隐藏鼠标 */
        }

        /* --- 2. 沉浸式背景星空 --- */
        #stars-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* --- 3. 荧光绿光圈 (仿视频核心) --- */
        #cursor-ring {
            position: fixed;
            width: 50px;
            height: 50px;
            border: 3px solid var(--accent-green);
            border-radius: 50%;
            box-shadow: 0 0 15px var(--accent-green), inset 0 0 5px var(--accent-green);
            pointer-events: none;
            z-index: 999;
            transform: translate(-50%, -50%);
            transition: width 0.1s, height 0.1s, background 0.1s;
        }
        
        /* 捏合时的状态 */
        #cursor-ring.pinching {
            width: 20px;
            height: 20px;
            background: var(--accent-green);
            box-shadow: 0 0 30px var(--accent-green);
        }

        /* --- 4. 极简卡牌容器 --- */
        #card-container {
            display: flex;
            gap: 30px;
            perspective: 1200px;
            z-index: 10;
        }

        .card-wrapper {
            width: var(--card-width);
            height: var(--card-height);
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .card-wrapper.flipped { transform: rotateY(180deg); }

        .card-face {
            position: absolute;
            width: 100%; height: 100%;
            backface-visibility: hidden;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        /* 卡背：纯黑 + 微光边框 (视频风格) */
        .card-back {
            background: #050505;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 0 15px var(--card-glow);
            transition: box-shadow 0.3s, border-color 0.3s;
        }

        /* 选中态 */
        .card-wrapper.hovered .card-back {
            border-color: var(--accent-green);
            box-shadow: 0 0 30px var(--accent-green);
        }

        /* 卡面 */
        .card-front {
            background: #111;
            transform: rotateY(180deg);
            border: 1px solid #333;
        }
        .card-front img {
            width: 100%; height: 100%;
            object-fit: cover;
            border-radius: 4px;
            filter: contrast(1.1) brightness(1.1); /* 增强质感 */
        }

        /* --- 5. UI文字 --- */
        #status-text {
            position: fixed;
            top: 20%;
            text-align: center;
            width: 100%;
            font-size: 14px;
            letter-spacing: 4px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            z-index: 20;
        }

        #webcam { position: fixed; opacity: 0; pointer-events: none; } /* 完全隐藏摄像头画面 */
    </style>
</head>
<body>

    <div id="status-text">System Initializing...</div>
    <div id="cursor-ring"></div>
    <canvas id="stars-canvas"></canvas>
    
    <div id="card-container"></div>
    <video id="webcam" autoplay playsinline></video>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js";

        /* --- 数据配置 --- */
        const cards = [
            { img: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg" },
            { img: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg" },
            { img: "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg" },
            { img: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg" },
            { img: "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg" }
        ];

        /* --- 核心变量 --- */
        let handLandmarker;
        const video = document.getElementById("webcam");
        const cursor = document.getElementById("cursor-ring");
        const statusText = document.getElementById("status-text");
        
        // 平滑移动变量 (Lerp)
        let targetX = window.innerWidth / 2;
        let targetY = window.innerHeight / 2;
        let currentX = window.innerWidth / 2;
        let currentY = window.innerHeight / 2;
        
        // 粒子系统
        const canvas = document.getElementById("stars-canvas");
        const ctx = canvas.getContext("2d");
        let particles = [];

        /* --- 1. 初始化系统 --- */
        async function init() {
            // 生成卡牌
            const container = document.getElementById("card-container");
            cards.forEach((c, i) => {
                const el = document.createElement("div");
                el.className = "card-wrapper";
                el.innerHTML = `
                    <div class="card-face card-back"></div>
                    <div class="card-face card-front"><img src="${c.img}"></div>
                `;
                container.appendChild(el);
            });

            // 启动视觉模型
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU" // 强制开启GPU加速
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            // 启动摄像头
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    statusText.innerText = "SYSTEM READY // DETECTING HAND";
                    resizeCanvas();
                    animate();
                    predict();
                });
            } catch(e) {
                statusText.innerText = "ERROR: CAMERA ACCESS DENIED";
            }
        }

        /* --- 2. 核心：手势追踪与平滑 --- */
        async function predict() {
            let now = performance.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, now);

                if (results.landmarks && results.landmarks.length > 0) {
                    const lm = results.landmarks[0];
                    const indexTip = lm[8]; // 食指
                    const thumbTip = lm[4]; // 拇指

                    // 计算目标坐标 (添加镜像翻转)
                    targetX = (1 - indexTip.x) * window.innerWidth;
                    targetY = indexTip.y * window.innerHeight;

                    // 计算捏合距离
                    const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    const isPinching = dist < 0.06; // 捏合阈值

                    handleInteraction(currentX, currentY, isPinching);
                }
            }
            requestAnimationFrame(predict);
        }
        let lastVideoTime = -1;

        /* --- 3. 交互与动画循环 --- */
        function animate() {
            // A. 光标平滑插值 (关键：让光标看起来像视频里那样稳定)
            // 0.15 是平滑系数，越小越慢越平滑
            currentX += (targetX - currentX) * 0.15;
            currentY += (targetY - currentY) * 0.15;

            cursor.style.left = `${currentX}px`;
            cursor.style.top = `${currentY}px`;

            // B. 粒子更新
            updateParticles();

            requestAnimationFrame(animate);
        }

        /* --- 4. 逻辑判断 --- */
        let pinchTriggered = false;

        function handleInteraction(x, y, isPinching) {
            const wrappers = document.querySelectorAll('.card-wrapper');
            let hovering = false;

            // 捏合视觉反馈
            if (isPinching) cursor.classList.add("pinching");
            else cursor.classList.remove("pinching");

            wrappers.forEach(card => {
                const rect = card.getBoundingClientRect();
                // 简单的AABB碰撞检测
                if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {
                    hovering = true;
                    if (!card.classList.contains("flipped")) {
                        card.classList.add("hovered");
                        
                        // 触发翻牌：必须在卡片上做出捏合动作
                        if (isPinching && !pinchTriggered) {
                            flipCard(card);
                            pinchTriggered = true; // 防止连续触发
                        }
                    }
                } else {
                    card.classList.remove("hovered");
                }
            });

            if (!isPinching) pinchTriggered = false; // 松开手后重置触发器
            
            if (hovering) statusText.innerText = "TARGET LOCKED // PINCH TO REVEAL";
            else statusText.innerText = "SEARCHING...";
        }

        function flipCard(card) {
            if (card.classList.contains("flipped")) return;
            card.classList.remove("hovered");
            card.classList.add("flipped");
            
            // 触发爆炸特效
            const rect = card.getBoundingClientRect();
            explode(rect.left + rect.width/2, rect.top + rect.height/2);
        }

        /* --- 5. 粒子爆炸引擎 (Canvas) --- */
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.onresize = resizeCanvas;

        function explode(x, y) {
            // 瞬间生成100个粒子
            for (let i = 0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 2; // 高速
                particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    size: Math.random() * 4 + 1,
                    color: `rgba(255, 255, 255, ${Math.random()})`
                });
            }
            // 混入一些绿色粒子
            for (let i = 0; i < 30; i++) {
                 const angle = Math.random() * Math.PI * 2;
                 const speed = Math.random() * 10 + 5; 
                 particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    size: 2,
                    color: `rgba(0, 255, 157, ${Math.random()})` // 荧光绿
                });
            }
        }

        function updateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景微弱星尘
            if(Math.random() > 0.95) {
                ctx.fillStyle = "rgba(255,255,255,0.5)";
                ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, 1, 1);
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02; // 消失速度
                
                // 摩擦力
                p.vx *= 0.95;
                p.vy *= 0.95;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
        }

        init();
    </script>
</body>
</html>
