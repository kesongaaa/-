<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Tarot - Deep Space</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg-color: #000000;
            --tech-green: #00ff9d;
            --tech-dim: rgba(0, 255, 157, 0.15);
            
            /* 1. 基础尺寸 (这是背景里看起来的大小) */
            --card-width: 200px;
            --card-height: 350px;
            
            /* 2. 半径设置 (推得足够远，看起来就会小) */
            --radius: 900px; 
        }

        body {
            margin: 0;
            background: var(--bg-color);
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: none;
            /* 3. 视距 (决定了近大远小的程度，越小透视越强) */
            perspective: 800px; 
        }

        /* 辅助网格：帮你找回空间感 (很淡) */
        #grid-floor {
            position: fixed; top: 50%; left: 50%; width: 200vw; height: 200vw;
            transform: translate(-50%, -50%) rotateX(90deg) translateZ(300px);
            background: radial-gradient(circle, transparent 0%, #000 70%),
                        linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 100% 100%, 100px 100px, 100px 100px;
            pointer-events: none; z-index: 0;
        }

        canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #bg-canvas { z-index: 1; }
        #effect-canvas { z-index: 60; }
        #hand-canvas { z-index: 70; opacity: 0.8; }

        /* 世界容器 */
        #world-container {
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            transform-style: preserve-3d;
            z-index: 10;
        }

        .card-wrapper {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            left: calc(var(--card-width) * -0.5);
            top: calc(var(--card-height) * -0.5);
            transform-style: preserve-3d;
            /* 4. 关键修正：去掉 hidden，防止背面渲染丢失 */
            /* backface-visibility: hidden; */ 
        }

        .card-face {
            position: absolute; width: 100%; height: 100%;
            border-radius: 12px;
            backface-visibility: hidden; /* 这里保留 */
        }

        /* 5. 视觉修复：让卡背不再是纯黑，而是深灰 + 发光边框 */
        .card-back {
            background: linear-gradient(135deg, #151515 0%, #080808 100%);
            border: 2px solid rgba(255, 255, 255, 0.15); /* 默认有可见边框 */
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
            display: flex; justify-content: center; align-items: center;
            transition: all 0.3s ease;
        }
        
        /* 卡背纹理 - 让你能看清它的存在 */
        .card-back::after {
            content: '✦'; /* 符文 */
            font-size: 40px;
            color: rgba(255, 255, 255, 0.1);
        }

        /* 锁定状态：高亮 */
        .card-wrapper.locked .card-back {
            border-color: var(--tech-green);
            box-shadow: 0 0 50px var(--tech-green), inset 0 0 20px var(--tech-green);
            background: #1a1a1a;
            /* 稍微拉近一点，提示选中 */
            transform: translateZ(50px) scale(1.05); 
        }
        .card-wrapper.locked .card-back::after {
            color: var(--tech-green);
            text-shadow: 0 0 10px var(--tech-green);
        }

        .card-front {
            background: #111;
            transform: rotateY(180deg); /* 预置翻转 */
        }

        /* 6. 抓取层 (Active Card) */
        #active-card {
            position: fixed;
            width: var(--card-width);
            height: var(--card-height);
            top: 0; left: 0;
            transform-style: preserve-3d;
            z-index: 100;
            display: none;
            pointer-events: none;
        }
        
        #active-card .inner {
            width: 100%; height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }

        #active-card.flipped .inner {
            transform: rotateY(180deg);
        }
        
        /* 抓取后的放大效果：通过 JS 控制 scale，这里设置基础样式 */
        #active-card img {
            width: 100%; height: 100%; object-fit: cover; border-radius: 12px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border: 1px solid #444;
        }

        #status-text {
            position: fixed; bottom: 15%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-size: 14px; letter-spacing: 2px;
            text-shadow: 0 0 10px #000; z-index: 80;
        }

        #webcam { display: none; }
    </style>
</head>
<body>

    <div id="grid-floor"></div> <!-- 地板网格，增加空间参考 -->
    <div id="status-text">SYSTEM ONLINE // SCANNING CARDS</div>

    <canvas id="bg-canvas"></canvas>
    <canvas id="effect-canvas"></canvas>
    <canvas id="hand-canvas"></canvas>
    
    <div id="world-container"></div>
    
    <div id="active-card">
        <div class="inner">
            <div class="card-face card-back"></div>
            <div class="card-face card-front"><img id="active-img" src=""></div>
        </div>
    </div>

    <video id="webcam" autoplay playsinline></video>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js";

        // 20张牌
        const tarotImages = [
            "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Wands05.jpg/352px-Wands05.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/RWS_Tarot_07_Chariot.jpg/353px-RWS_Tarot_07_Chariot.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/RWS_Tarot_08_Strength.jpg/344px-RWS_Tarot_08_Strength.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Swords03.jpg/347px-Swords03.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/TheLovers.jpg/337px-TheLovers.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/RWS_Tarot_13_Death.jpg/327px-RWS_Tarot_13_Death.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/RWS_Tarot_15_Devil.jpg/337px-RWS_Tarot_15_Devil.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/RWS_Tarot_16_Tower.jpg/331px-RWS_Tarot_16_Tower.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/RWS_Tarot_17_Star.jpg/340px-RWS_Tarot_17_Star.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/RWS_Tarot_18_Moon.jpg/334px-RWS_Tarot_18_Moon.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/17/RWS_Tarot_19_Sun.jpg/336px-RWS_Tarot_19_Sun.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/ea/RWS_Tarot_20_Judgement.jpg/342px-RWS_Tarot_20_Judgement.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/RWS_Tarot_21_World.jpg/350px-RWS_Tarot_21_World.jpg",
             "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Wands05.jpg/352px-Wands05.jpg",
             "https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/TheLovers.jpg/337px-TheLovers.jpg"
        ];

        let handLandmarker;
        const video = document.getElementById("webcam");
        const statusText = document.getElementById("status-text");
        const worldContainer = document.getElementById("world-container");
        const activeCard = document.getElementById("active-card");
        const activeImg = document.getElementById("active-img");
        const handCtx = document.getElementById("hand-canvas").getContext("2d");
        const effectCtx = document.getElementById("effect-canvas").getContext("2d");

        let cameraAngle = 0;
        let rotateSpeed = 0;
        const MAX_ROTATE_SPEED = 1.5; // 稍微减慢旋转速度，更容易看清
        
        let handX = 0.5, handY = 0.5;
        let isPinching = false;
        let pinchLocked = false;
        
        const STATE = { IDLE: 0, GRABBED: 2, DISSOLVING: 3 };
        let gameState = STATE.IDLE;
        
        let cards = [];
        const RADIUS = 900; // 半径很大，所以看起来远、小
        const ANGLE_STEP = 360 / tarotImages.length;

        async function init() {
            // 构建世界
            tarotImages.forEach((url, i) => {
                const el = document.createElement("div");
                el.className = "card-wrapper";
                el.innerHTML = `<div class="card-face card-back"></div>`; 
                worldContainer.appendChild(el);
                
                const angle = i * ANGLE_STEP;
                // 注意：rotateY(angle + 180) 是为了让牌面（正面）朝内
                // 但我们显示的是 card-back，card-back 默认就是背面
                // 所以我们让正面朝外，背面朝圆心（朝向你）
                el.style.transform = `rotateY(${angle}deg) translateZ(${RADIUS}px)`;
                
                cards.push({ el, angle, url });
            });

            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
            video.srcObject = stream;
            video.addEventListener("loadeddata", () => {
                resizeCanvas();
                animate();
                predict();
            });
        }

        let lastVideoTime = -1;
        async function predict() {
            let now = performance.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, now);
                handCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);

                if (results.landmarks && results.landmarks.length > 0) {
                    const lm = results.landmarks[0];
                    drawSkeleton(lm);

                    const indexTip = lm[8];
                    const thumbTip = lm[4];
                    handX = 1 - indexTip.x;
                    handY = indexTip.y;
                    
                    const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    isPinching = dist < 0.05;

                    handleInput();
                } else {
                    rotateSpeed *= 0.95;
                    isPinching = false;
                    unlockCard();
                }
            }
            requestAnimationFrame(predict);
        }

        let lockedCardIndex = -1;

        function handleInput() {
            if (gameState === STATE.GRABBED) {
                handleGrabbed();
                return;
            }

            // 旋转逻辑
            if (handX < 0.35) {
                rotateSpeed = -((0.35 - handX) / 0.35) * MAX_ROTATE_SPEED; 
                statusText.innerText = "<< PANNING";
            } else if (handX > 0.65) {
                rotateSpeed = ((handX - 0.65) / 0.35) * MAX_ROTATE_SPEED;
                statusText.innerText = "PANNING >>";
            } else {
                rotateSpeed = 0;
            }

            // 锁定逻辑
            if (Math.abs(rotateSpeed) < 0.1 && handX >= 0.35 && handX <= 0.65) {
                statusText.innerText = "LOCKED // PINCH";
                rotateSpeed = 0;

                let facingAngle = -cameraAngle % 360;
                if (facingAngle < 0) facingAngle += 360;

                let closestIdx = -1;
                let minDiff = 1000;

                cards.forEach((card, i) => {
                    let diff = Math.abs(card.angle - facingAngle);
                    if (diff > 180) diff = 360 - diff;
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIdx = i;
                    }
                });

                if (minDiff < 12 && handY > 0.3 && handY < 0.7) {
                    lockCard(closestIdx);
                } else {
                    unlockCard();
                }
            } else {
                unlockCard();
            }

            if (!isPinching) pinchLocked = false;
        }

        function lockCard(index) {
            if (lockedCardIndex !== index) {
                unlockCard();
                lockedCardIndex = index;
                cards[index].el.classList.add('locked');
            }
            if (isPinching && !pinchLocked) {
                extractCard(index);
            }
        }

        function unlockCard() {
            if (lockedCardIndex !== -1) {
                cards[lockedCardIndex].el.classList.remove('locked');
                lockedCardIndex = -1;
            }
        }

        function extractCard(index) {
            gameState = STATE.GRABBED;
            pinchLocked = true;
            statusText.innerText = "FATE REVEALED";

            const data = cards[index];
            activeImg.src = data.url;
            activeCard.style.display = 'block';
            data.el.style.opacity = 0; // 隐藏原卡

            setTimeout(() => activeCard.classList.add('flipped'), 50);
        }

        function handleGrabbed() {
            const x = handX * window.innerWidth;
            const y = handY * window.innerHeight;
            
            // 关键：抓取时放大，对比背景的小卡牌
            // 这里的 scale(1.3) 是相对于 card-width 200px 的
            activeCard.style.transform = `translate(${x - 100}px, ${y - 175}px) scale(1.4)`;

            if (!isPinching) {
                dissolve();
            }
        }

        function dissolve() {
            gameState = STATE.DISSOLVING;
            const rect = activeCard.getBoundingClientRect();
            spawnParticles(rect.left + rect.width/2, rect.top + rect.height/2);
            
            activeCard.style.display = 'none';
            activeCard.classList.remove('flipped');
            
            if (lockedCardIndex !== -1) {
                const el = cards[lockedCardIndex].el;
                setTimeout(() => {
                    el.style.opacity = 1;
                    el.classList.remove('locked');
                }, 300);
            }
            
            setTimeout(() => {
                gameState = STATE.IDLE;
                lockedCardIndex = -1;
            }, 500);
        }

        function animate() {
            cameraAngle += rotateSpeed;
            worldContainer.style.transform = `rotateY(${cameraAngle}deg)`;
            updateParticles();
            requestAnimationFrame(animate);
        }

        let particles = [];
        function spawnParticles(x, y) {
            for(let i=0; i<60; i++) {
                const a = Math.random()*Math.PI*2, v = Math.random()*20+5;
                particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:1,color:'#00ff9d'});
            }
        }
        function updateParticles() {
            effectCtx.clearRect(0,0,window.innerWidth,window.innerHeight);
            for(let i=particles.length-1;i>=0;i--) {
                let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=0.03;
                if(p.life<=0) particles.splice(i,1);
                else { effectCtx.globalAlpha=p.life; effectCtx.fillStyle=p.color; effectCtx.beginPath(); effectCtx.arc(p.x,p.y,3,0,Math.PI*2); effectCtx.fill(); }
            }
            effectCtx.globalAlpha=1;
        }

        const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];
        function drawSkeleton(lm) {
            handCtx.lineWidth = 2; handCtx.lineCap = "round";
            handCtx.strokeStyle = "rgba(0, 255, 157, 0.4)";
            connections.forEach(([i,j])=>{
                const p1=lm[i],p2=lm[j];
                handCtx.beginPath();
                handCtx.moveTo((1-p1.x)*window.innerWidth,p1.y*window.innerHeight);
                handCtx.lineTo((1-p2.x)*window.innerWidth,p2.y*window.innerHeight);
                handCtx.stroke();
            });
            const cx=(1-lm[8].x)*window.innerWidth, cy=lm[8].y*window.innerHeight;
            handCtx.beginPath(); handCtx.arc(cx,cy,6,0,Math.PI*2); handCtx.fillStyle=isPinching?"#fff":"#00ff9d"; handCtx.fill();
        }

        function resizeCanvas() {
            const w=window.innerWidth, h=window.innerHeight;
            document.getElementById("bg-canvas").width=w; document.getElementById("bg-canvas").height=h;
            document.getElementById("effect-canvas").width=w; document.getElementById("effect-canvas").height=h;
            document.getElementById("hand-canvas").width=w; document.getElementById("hand-canvas").height=h;
        }
        window.onresize = resizeCanvas;

        init();
    </script>
</body>
</html>
