<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL Hand Gesture Racer - Obstacle Mode</title>
    <style>
        /* 页面基础样式 - 赛博朋克风格 */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* UI 层 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* 碰撞时的红屏闪烁效果 */
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, red 100%);
            opacity: 0; transition: opacity 0.1s; pointer-events: none; z-index: 5;
        }

        /* 顶部仪表盘 */
        .hud-top {
            padding: 20px;
            display: flex; justify-content: space-between; align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .speed-box { text-align: right; color: #0ff; text-shadow: 0 0 10px #0ff; }
        .speed-value { font-size: 60px; font-weight: bold; font-family: 'Courier New', monospace; }
        .speed-unit { font-size: 20px; opacity: 0.8; }

        .status-box { color: #fff; font-size: 14px; background: rgba(0, 50, 100, 0.5); padding: 10px; border-radius: 8px; border: 1px solid #0ff; backdrop-filter: blur(4px); }
        .status-item { margin-bottom: 5px; display: flex; align-items: center; }
        .dot { width: 10px; height: 10px; border-radius: 50%; background: #333; margin-right: 8px; display: inline-block; }
        .dot.active { background: #0f0; box-shadow: 0 0 8px #0f0; }
        .dot.error { background: #f00; }

        /* 摄像头小窗口 */
        #webcam-preview {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            border: 2px solid #333; background: #000;
            transform: scaleX(-1); /* 镜像 */
            z-index: 10; opacity: 0.7;
            border-radius: 8px;
        }

        /* 加载遮罩 */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #0ff; transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #0ff;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <!-- 引入 MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- 引入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div>LOADING SYSTEM...</div>
        <div style="font-size:12px; color:#666; margin-top:10px">请允许摄像头权限</div>
    </div>

    <!-- 伤害闪烁层 -->
    <div id="damage-overlay"></div>

    <div id="canvas-container"></div>
    <video id="webcam-preview" playsinline muted></video>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="status-box">
                <div class="status-item"><span class="dot" id="cam-dot"></span> 摄像头信号</div>
                <div class="status-item"><span class="dot" id="hand-dot"></span> 手势识别</div>
                <div style="font-size:12px; color:#aaa; margin-top:5px;">
                    单手左右倾斜 = 转向<br>
                    <span style="color:#ff3333">注意避开红色障碍物！</span>
                </div>
            </div>
            <div class="speed-box">
                <div class="speed-value" id="speed-display">0</div>
                <div class="speed-unit">KM/H</div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // =========================================
        // 1. 全局配置
        // =========================================
        const CONFIG = {
            maxSpeed: 280,        
            acceleration: 0.6,    
            steeringSensitivity: 0.08, 
            roadWidth: 50,
            cameraHeight: 2.0
        };

        const STATE = {
            speed: 0,
            steering: 0,
            targetSteering: 0,
            controlMode: 'keyboard',
            isHit: false // 是否发生碰撞
        };

        const UI = {
            loader: document.getElementById('loader'),
            speed: document.getElementById('speed-display'),
            camDot: document.getElementById('cam-dot'),
            handDot: document.getElementById('hand-dot'),
            video: document.getElementById('webcam-preview'),
            damage: document.getElementById('damage-overlay')
        };

        // =========================================
        // 2. Three.js 场景
        // =========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020008);
        scene.fog = new THREE.FogExp2(0x020008, 0.01); // 增加雾浓度，隐藏生成过程

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, CONFIG.cameraHeight, 5);
        camera.lookAt(0, CONFIG.cameraHeight, -20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        // 主光源
        const dirLight = new THREE.DirectionalLight(0x00f3ff, 1);
        dirLight.position.set(20, 50, 20);
        scene.add(dirLight);
        // 红色警示光（照亮障碍物）
        const redLight = new THREE.PointLight(0xff0000, 0.5, 50);
        redLight.position.set(0, 5, -10);
        scene.add(redLight);

        // --- 1. 道路 (网格地面) ---
        function createGridTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // 黑底
            ctx.fillStyle = '#050505';
            ctx.fillRect(0,0,512,512);
            
            // 亮青色边线
            ctx.strokeStyle = '#00f3ff';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.lineTo(0, 512);
            ctx.moveTo(512, 0); ctx.lineTo(512, 512);
            ctx.stroke();

            // 横向速度线
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.2)';
            ctx.lineWidth = 2;
            for(let i=0; i<512; i+=64) {
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(512, i); ctx.stroke();
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.anisotropy = 16;
            return tex;
        }

        const roadTexture = createGridTexture();
        const roadGeo = new THREE.PlaneGeometry(CONFIG.roadWidth, 1000);
        const roadMat = new THREE.MeshBasicMaterial({ map: roadTexture });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        scene.add(road);

        // --- 2. 路边建筑 (装饰) ---
        const buildings = [];
        const buildGeo = new THREE.BoxGeometry(2, 1, 2);
        
        for (let i = 0; i < 30; i++) {
            const mat = new THREE.MeshPhongMaterial({ 
                color: 0x110033, 
                emissive: 0x220055,
                shininess: 100
            });
            const mesh = new THREE.Mesh(buildGeo, mat);
            resetObj(mesh, -i * 15, true);
            scene.add(mesh);
            buildings.push(mesh);
        }

        // --- 3. 障碍物 (危险物体) ---
        const obstacles = [];
        // 使用八面体看起来更有攻击性
        const obstacleGeo = new THREE.OctahedronGeometry(1.5, 0); 
        const obstacleMat = new THREE.MeshPhongMaterial({ 
            color: 0xff0000, 
            emissive: 0x550000,
            shininess: 50,
            wireframe: false
        });
        
        // 线框外壳，增加科技感
        const wireGeo = new THREE.WireframeGeometry(obstacleGeo);
        const wireMat = new THREE.LineBasicMaterial({ color: 0xff3333 });

        for (let i = 0; i < 10; i++) {
            const group = new THREE.Group();
            
            const core = new THREE.Mesh(obstacleGeo, obstacleMat);
            const wire = new THREE.LineSegments(wireGeo, wireMat);
            
            group.add(core);
            group.add(wire);
            
            // 初始放置在很远的地方，避免开局就撞
            resetObj(group, -100 - i * 30, false); 
            
            scene.add(group);
            obstacles.push(group);
        }

        // 通用重置函数
        function resetObj(obj, zPos, isBuilding = false) {
            obj.position.z = zPos;
            
            if (isBuilding) {
                // 建筑在路两边
                const side = Math.random() > 0.5 ? 1 : -1;
                obj.position.x = side * (CONFIG.roadWidth / 2 + 5 + Math.random() * 10);
                obj.scale.set(1, 5 + Math.random() * 20, 1); // 随机高度
                obj.position.y = obj.scale.y / 2 - 2;
            } else {
                // 障碍物在路中间，随机 X
                // 留出一点边距，避免完全不可躲避
                const safeWidth = CONFIG.roadWidth - 10;
                obj.position.x = (Math.random() - 0.5) * safeWidth;
                obj.position.y = 1.5; // 悬浮
                
                // 随机旋转增加动感
                obj.rotation.set(Math.random(), Math.random(), Math.random());
            }
        }

        // --- 4. 粒子星空 ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1500; i++) {
            starPos.push((Math.random()-0.5)*400, (Math.random()-0.5)*200, (Math.random()-0.5)*400);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.4 });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);


        // =========================================
        // 3. 游戏逻辑
        // =========================================
        
        const keys = { left: false, right: false };
        window.addEventListener('keydown', (e) => {
            if(e.key === 'ArrowLeft') keys.left = true;
            if(e.key === 'ArrowRight') keys.right = true;
        });
        window.addEventListener('keyup', (e) => {
            if(e.key === 'ArrowLeft') keys.left = false;
            if(e.key === 'ArrowRight') keys.right = false;
        });

        // 碰撞闪烁函数
        function triggerDamage() {
            if (STATE.isHit) return; // 避免连续触发
            STATE.isHit = true;
            UI.damage.style.opacity = '0.8';
            setTimeout(() => {
                UI.damage.style.opacity = '0';
                STATE.isHit = false;
            }, 300);
        }

        function updatePhysics(dt) {
            // 1. 输入处理
            if (STATE.controlMode === 'keyboard') {
                if (keys.left) STATE.targetSteering = -1;
                else if (keys.right) STATE.targetSteering = 1;
                else STATE.targetSteering = 0;
            }

            // 2. 速度处理
            if (STATE.speed < CONFIG.maxSpeed) {
                STATE.speed += CONFIG.acceleration;
            }
            
            // 3. 转向平滑
            STATE.steering += (STATE.targetSteering - STATE.steering) * CONFIG.steeringSensitivity;

            // 4. 计算移动距离
            // 这个 moveDist 是场景物体向相机移动的距离（相对运动）
            const moveDist = (STATE.speed / 10) * dt * 10;
            
            // 纹理滚动
            roadTexture.offset.y -= moveDist * 0.05;

            // --- 物体移动与回收 ---
            
            // 移动建筑
            buildings.forEach(b => {
                b.position.z += moveDist;
                if(b.position.z > 10) resetObj(b, -200 - Math.random() * 50, true);
            });

            // 移动障碍物 + 碰撞检测
            obstacles.forEach(obs => {
                obs.position.z += moveDist;
                // 自转
                obs.rotation.x += 0.02;
                obs.rotation.y += 0.02;

                // 碰撞检测逻辑
                // 障碍物 Z 轴接近相机 (相机在 5, 物体到 5 附近)
                // 并且 X 轴距离足够近
                if (Math.abs(obs.position.z - camera.position.z) < 2.5) {
                    const distX = Math.abs(obs.position.x - camera.position.x);
                    if (distX < 2.5) { // 碰撞半径
                        // 撞到了！
                        triggerDamage();
                        STATE.speed = STATE.speed * 0.4; // 速度减半惩罚
                        // 撞完后为了防止连续判定，把物体移走
                        obs.position.z = 20; 
                    }
                }

                // 回收
                if(obs.position.z > 10) resetObj(obs, -300 - Math.random() * 100, false);
            });

            // 移动粒子
            const sPos = stars.geometry.attributes.position.array;
            for(let i=2; i<sPos.length; i+=3) {
                sPos[i] += moveDist * 0.5;
                if(sPos[i] > 20) sPos[i] = -300;
            }
            stars.geometry.attributes.position.needsUpdate = true;

            // 5. 玩家/相机横向移动
            const lateralSpeed = STATE.speed * 0.12 * dt;
            camera.position.x += STATE.steering * lateralSpeed;

            // 边界限制
            const limit = CONFIG.roadWidth / 2 - 2;
            if (camera.position.x > limit) { camera.position.x = limit; STATE.speed *= 0.98; }
            if (camera.position.x < -limit) { camera.position.x = -limit; STATE.speed *= 0.98; }

            // 6. 相机动态效果 (Roll & FOV)
            camera.rotation.z = -STATE.steering * 0.2; // 转向倾斜
            camera.fov = 75 + (STATE.speed / CONFIG.maxSpeed) * 15; // 极速拉伸视野
            camera.updateProjectionMatrix();

            // 7. 更新UI
            UI.speed.innerText = Math.floor(STATE.speed);
        }


        // =========================================
        // 4. MediaPipe 手势
        // =========================================
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // 性能优先
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                UI.handDot.classList.add('active');
                STATE.controlMode = 'hand';
                
                const lm = results.multiHandLandmarks[0];
                const wrist = lm[0];
                const middle = lm[9];
                
                // 计算倾斜
                const dx = middle.x - wrist.x; 
                // dx > 0: 像右倒; dx < 0: 向左倒 (镜像后)
                
                // 映射灵敏度
                const rawSteer = -dx * 6.0; // 负号因为我们要反向控制(镜像)
                STATE.targetSteering = Math.max(-1, Math.min(1, rawSteer));
            } else {
                UI.handDot.classList.remove('active');
                STATE.controlMode = 'keyboard';
            }
        });

        const cameraUtils = new Camera(UI.video, {
            onFrame: async () => await hands.send({image: UI.video}),
            width: 320, height: 240
        });

        cameraUtils.start()
            .then(() => {
                UI.camDot.classList.add('active');
                UI.loader.style.opacity = 0;
                setTimeout(() => UI.loader.style.display = 'none', 500);
            })
            .catch(() => {
                UI.camDot.classList.add('error');
                UI.loader.innerHTML = "摄像头启动失败 (需要HTTPS)";
            });

        // =========================================
        // 5. 循环
        // =========================================
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            updatePhysics(clock.getDelta());
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
