<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 手势控制赛车</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        
        /* 游戏容器 */
        #game-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }

        /* UI 叠加层 */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #00ffcc;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00ffcc;
            margin-bottom: 10px;
        }
        h1 { margin: 0 0 10px 0; font-size: 24px; }
        p { margin: 5px 0; font-size: 18px; }

        /* 摄像头调试窗口 */
        #webcam-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            z-index: 10;
            border: 2px solid #fff;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            transform: scaleX(-1); /* 镜像显示，符合直觉 */
        }
        #webcam-video { width: 100%; height: 100%; object-fit: cover; }
        
        /* 加载提示 */
        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 30px; z-index: 100; background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 10px;
        }
    </style>

    <!-- 引入 MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- 引入 Three.js (通过 Import Map) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- 加载提示 -->
    <div id="loading">正在初始化引擎与AI...</div>

    <!-- UI 显示 -->
    <div id="ui-layer">
        <div class="stat-box">
            <h1>手势赛车</h1>
            <p>速度: <span id="speed-display">0</span> km/h</p>
            <p>转向: <span id="steer-display">0</span>°</p>
            <p style="font-size: 14px; color: #aaa;">提示：举起单手，左右倾斜控制方向</p>
        </div>
    </div>

    <!-- 摄像头画面 -->
    <div id="webcam-container">
        <video id="webcam-video" playsinline></video>
        <canvas id="webcam-canvas" style="position:absolute; top:0; left:0; width:100%; height:100%;"></canvas>
    </div>

    <!-- 游戏画布 -->
    <div id="game-container"></div>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. 全局变量与配置
        // ==========================================
        const CONFIG = {
            maxSpeed: 2.0,          // 最大速度 (Three.js 单位/帧)
            acceleration: 0.01,     // 加速度
            friction: 0.98,         // 减速/摩擦力
            turnSensitivity: 0.08,  // 转向灵敏度
            maxSteerAngle: 0.8,     // 最大车轮转向角 (弧度)
            cameraLag: 0.1          // 相机跟随延迟 (0-1)
        };

        const STATE = {
            speed: 0,
            steering: 0,            // 当前转向值
            targetSteering: 0,      // 目标转向值 (来自手势)
            handDetected: false
        };

        // DOM 元素
        const speedEl = document.getElementById('speed-display');
        const steerEl = document.getElementById('steer-display');
        const loadingEl = document.getElementById('loading');

        // ==========================================
        // 2. Three.js 场景构建
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // 天空蓝
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100); // 迷雾效果，遮挡远处加载

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // --- 灯光 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 赛车 (简单的组合几何体) ---
        const carGroup = new THREE.Group();
        
        // 车身
        const bodyGeo = new THREE.BoxGeometry(2, 1, 4);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff0033, roughness: 0.3 });
        const carBody = new THREE.Mesh(bodyGeo, bodyMat);
        carBody.position.y = 0.75;
        carBody.castShadow = true;
        carGroup.add(carBody);

        // 车顶
        const topGeo = new THREE.BoxGeometry(1.8, 0.6, 2);
        const topMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const carTop = new THREE.Mesh(topGeo, topMat);
        carTop.position.y = 1.5;
        carTop.position.z = -0.5;
        carTop.castShadow = true;
        carGroup.add(carTop);

        // 车轮函数
        function createWheel(x, z) {
            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const wheel = new THREE.Mesh(wheelGeo, wheelMat);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(x, 0.5, z);
            wheel.castShadow = true;
            return wheel;
        }
        
        carGroup.add(createWheel(1.1, 1.2));  // 前右
        carGroup.add(createWheel(-1.1, 1.2)); // 前左
        carGroup.add(createWheel(1.1, -1.2)); // 后右
        carGroup.add(createWheel(-1.1, -1.2)); // 后左

        scene.add(carGroup);

        // --- 地面与环境 ---
        // 使用一个无限滚动的地面纹理逻辑：地面跟随车走，但纹理偏移
        const planeGeo = new THREE.PlaneGeometry(200, 200);
        const gridHelper = new THREE.GridHelper(200, 100, 0xffffff, 0x555555);
        
        // 创建一个看起来像地面的 Mesh
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const ground = new THREE.Mesh(planeGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        scene.add(gridHelper); // 网格线辅助视觉速度感

        // 装饰物（简单的树/石头，用来参照速度）
        const obstacles = [];
        for(let i=0; i<30; i++) {
            const geo = new THREE.ConeGeometry(1, 4, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const tree = new THREE.Mesh(geo, mat);
            resetObstacle(tree, true); // 随机位置
            scene.add(tree);
            obstacles.push(tree);
        }

        function resetObstacle(obj, randomZ = false) {
            obj.position.x = (Math.random() - 0.5) * 80; // 宽范围
            // 确保不撞车
            if (Math.abs(obj.position.x) < 5) obj.position.x += 10;
            
            // 如果是随机Z（初始化时），否则放置在远处
            if (randomZ) {
                obj.position.z = carGroup.position.z - Math.random() * 100 + 50;
            } else {
                obj.position.z = carGroup.position.z - 100 - Math.random() * 20;
            }
            obj.position.y = 2;
        }

        // ==========================================
        // 3. MediaPipe 手势识别逻辑
        // ==========================================
        const videoElement = document.getElementById('webcam-video');
        const canvasElement = document.getElementById('webcam-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            // 清除调试画布
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 绘制骨架
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 3});

                // --- 核心算法：计算手掌旋转角度 ---
                // 使用手腕(0)和中指指根(9)作为向量
                const wrist = landmarks[0];
                const middleFinger = landmarks[9];

                // 计算 X 轴偏差
                // 注意：在 MediaPipe 中，x 坐标 0 在左，1 在右。
                // 如果我们像握方向盘一样举手：
                // 手向左倒 -> 中指x < 手腕x
                // 手向右倒 -> 中指x > 手腕x
                const dx = middleFinger.x - wrist.x;
                
                // 将 dx (-0.3 到 0.3) 映射到 转向角度
                // 增加灵敏度乘数
                let steerInput = dx * 5.0; 
                
                // 限制幅度
                steerInput = Math.max(-1, Math.min(1, steerInput));

                // 镜像修正：因为摄像头通常是镜像的，而我们这里使用了 scaleX(-1) CSS 显示视频。
                // 但在逻辑中，为了符合直觉（手向右倒车向右转），如果发现方向反了，在这里取反。
                // 测试结果通常：手向屏幕右侧倒 (dx > 0) -> 车应右转 (Rotation Y < 0 或 > 0 取决于坐标系)
                // Three.js: 旋转 Y 正是逆时针(左)，负是顺时针(右)。
                STATE.targetSteering = -steerInput * CONFIG.maxSteerAngle;

            } else {
                STATE.handDetected = false;
                STATE.targetSteering = 0; // 没手时回正
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });

        // 启动摄像头
        cameraUtils.start()
            .then(() => {
                loadingEl.style.display = 'none';
                console.log("摄像头已启动");
            })
            .catch(err => {
                loadingEl.innerHTML = "无法访问摄像头，请检查权限。";
                console.error(err);
            });

        // ==========================================
        // 4. 游戏主循环
        // ==========================================
        
        // 调整大小
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 相机偏移量
        const cameraOffset = new THREE.Vector3(0, 5, 10);

        function updatePhysics() {
            // 1. 速度控制
            // 如果检测到手，并且速度未达上限，则加速
            if (STATE.handDetected && STATE.speed < CONFIG.maxSpeed) {
                STATE.speed += CONFIG.acceleration;
            } else if (!STATE.handDetected && STATE.speed > 0) {
                // 没手时慢慢减速
                STATE.speed *= CONFIG.friction;
            }
            // 简单的转弯减速
            if(Math.abs(STATE.steering) > 0.3) {
                STATE.speed *= 0.99; 
            }

            // 2. 转向平滑插值 (Damping)
            STATE.steering += (STATE.targetSteering - STATE.steering) * CONFIG.turnSensitivity;

            // 3. 应用移动
            // 赛车当前的旋转角度
            carGroup.rotation.y = STATE.steering;

            // 计算移动向量：Z轴负方向是向前
            // 赛车不仅要旋转模型，还要改变移动方向向量
            // 简单的做法：位置沿着当前朝向移动
            const speedX = Math.sin(carGroup.rotation.y) * STATE.speed;
            const speedZ = Math.cos(carGroup.rotation.y) * STATE.speed;

            carGroup.position.x -= speedX; // 注意正负号调整方向
            carGroup.position.z -= speedZ;

            // 限制 X 轴边界（防止跑太远）
            if(carGroup.position.x > 80) carGroup.position.x = 80;
            if(carGroup.position.x < -80) carGroup.position.x = -80;

            // 4. 环境循环 (Infinite Runner Logic)
            // 地面跟随
            ground.position.z = carGroup.position.z;
            gridHelper.position.z = carGroup.position.z;
            // 纹理偏移没做，直接让grid跟着走，视觉上需要参照物
            
            // 检查障碍物，如果跑到了摄像机后面，就重置到前方
            obstacles.forEach(obj => {
                if (obj.position.z > carGroup.position.z + 20) {
                    resetObstacle(obj);
                }
            });

            // 5. 更新 UI
            speedEl.innerText = Math.floor(STATE.speed * 100); // 假装是 km/h
            steerEl.innerText = Math.floor(THREE.MathUtils.radToDeg(-STATE.steering)); // 显示角度
        }

        function updateCamera() {
            // 目标相机位置：车的位置 + 旋转后的偏移
            // 简单版本：相机永远在车屁股后面，不随车身旋转而剧烈旋转，只跟随位置
            const targetPos = carGroup.position.clone().add(cameraOffset);
            
            // 为了增加动感，让相机稍微偏向转向的反方向（可选，这里只做位置跟随）
            camera.position.lerp(targetPos, CONFIG.cameraLag);
            camera.lookAt(carGroup.position);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            updatePhysics();
            updateCamera();
            
            renderer.render(scene, camera);
        }

        // 开始渲染循环
        animate();

    </script>
</body>
</html>
