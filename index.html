<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 手势赛车 - 修复重制版</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(to bottom, #2b1055, #7597de); /* 夕阳渐变背景 */
            font-family: 'Arial', sans-serif; 
        }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* 摄像头画中画 */
        #webcam-preview {
            position: absolute;
            top: 20px; right: 20px;
            width: 200px; height: 150px;
            background: #000;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 10px;
            transform: scaleX(-1);
            z-index: 10;
            object-fit: cover;
        }

        /* 仪表盘 */
        #ui-layer {
            position: absolute;
            bottom: 40px; left: 40px;
            color: white;
            z-index: 10;
            font-style: italic;
        }
        .speed-box { font-size: 60px; font-weight: 900; text-shadow: 0 0 10px #ff0055; }
        .speed-unit { font-size: 20px; font-weight: normal; color: #ddd; }
        .instruction { font-size: 16px; margin-bottom: 5px; color: #00ffcc; text-shadow: 0 1px 2px black;}

        /* 加载遮罩 */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 999;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; transition: opacity 0.5s;
        }
        .bar-bg { width: 300px; height: 4px; background: #333; margin-top: 20px; border-radius: 2px;}
        .bar-fill { width: 0%; height: 100%; background: #ff0055; transition: width 0.3s; }

        /* 操控指示条 */
        #steering-bar {
            position: absolute; bottom: 120px; left: 50%;
            transform: translateX(-50%);
            width: 300px; height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }
        #steering-dot {
            position: absolute; left: 50%; top: -6px;
            width: 18px; height: 18px;
            background: #ff0055;
            border-radius: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 10px #ff0055;
            transition: left 0.1s ease-out;
        }
    </style>
    
    <!-- 引入库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <h2>正在启动引擎...</h2>
        <div class="bar-bg"><div class="bar-fill" id="progress"></div></div>
        <p id="loading-text" style="margin-top:10px; color:#888;">请允许摄像头权限</p>
    </div>

    <div id="ui-layer">
        <div class="instruction" id="status-msg">等待手势识别... (请举起单手)</div>
        <div class="speed-box">0 <span class="speed-unit">KM/H</span></div>
    </div>

    <div id="steering-bar"><div id="steering-dot"></div></div>
    <video id="webcam-preview" playsinline></video>
    <div id="canvas-container"></div>

<script>
/**
 * 配置项
 */
const CONFIG = {
    roadWidth: 16,
    speed: 0,
    maxSpeed: 1.8,
    turnSpeed: 0.08,  // 转向反应速度
    cameraHeight: 3.5,
    cameraDistance: 9
};

const STATE = {
    u: 0, // 赛道进度 (0-1)
    offset: 0, // 左右偏移 (-1 到 1)
    targetOffset: 0, // 目标偏移 (手势控制)
    handsReady: false
};

// 资源引用
let scene, camera, renderer;
let carContainer, carBody, tailLights;
let roadMesh, lineMesh;
let curve;

// 初始化入口
function init() {
    setupScene();
    createRoad();
    createCar();
    createEnvironment();
    
    // 开始动画循环
    animate();
    
    // 初始化AI
    initAI();
}

/**
 * 1. 场景与光照 (修复了太黑的问题)
 */
function setupScene() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    
    // 增加雾气，遮挡远处的断层，营造氛围
    scene.fog = new THREE.FogExp2(0x4b2d5e, 0.008); // 紫色雾气配合背景

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
    
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // 环境光 (整体亮度)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // 模拟夕阳的主光源
    const sunLight = new THREE.DirectionalLight(0xffaa00, 1.2);
    sunLight.position.set(-50, 60, -50);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 1024;
    sunLight.shadow.mapSize.height = 1024;
    scene.add(sunLight);

    // 补光 (照亮车尾)
    const fillLight = new THREE.DirectionalLight(0x4444ff, 0.5);
    fillLight.position.set(20, 10, 20);
    scene.add(fillLight);
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

/**
 * 2. 赛道生成 (修复了垂直墙壁的问题)
 */
function createRoad() {
    // 生成一条更平缓、宽阔的曲线
    const points = [];
    const segmentCount = 150;
    
    for (let i = 0; i <= segmentCount; i++) {
        const angle = (i / segmentCount) * Math.PI * 2;
        // 使用参数方程生成一个闭合的环形山路
        const x = Math.sin(angle * 3) * 60 + Math.cos(angle * 5) * 20;
        const z = Math.cos(angle * 3) * 80 + Math.sin(angle) * 40;
        const y = Math.sin(angle * 6) * 15; // 起伏高度

        points.push(new THREE.Vector3(x, y, z));
    }
    
    curve = new THREE.CatmullRomCurve3(points);
    curve.closed = true; // 闭合赛道

    // 路面几何体
    const roadGeo = new THREE.TubeGeometry(curve, 300, CONFIG.roadWidth / 2, 6, true);
    
    // 材质：深色沥青
    const roadMat = new THREE.MeshStandardMaterial({ 
        color: 0x222222, 
        roughness: 0.8,
        metalness: 0.1,
        side: THREE.DoubleSide
    });
    
    roadMesh = new THREE.Mesh(roadGeo, roadMat);
    roadMesh.receiveShadow = true;
    scene.add(roadMesh);
    
    // 添加车道线 (关键：这给了速度感)
    // 简单的做法是再生成一个细的Tube浮在路面上
    const lineGeo = new THREE.TubeGeometry(curve, 300, 0.2, 3, true);
    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    lineMesh = new THREE.Mesh(lineGeo, lineMat);
    lineMesh.position.y = 0.1; // 稍微抬高防止Z-fighting
    // 注意：这里简单的Tube无法完美贴合扭曲路面的法线，
    // 但因为我们用了双面渲染且路面较宽，视觉上在中间看起来像分道线。
    scene.add(lineMesh);
}

/**
 * 3. 车量模型 (修复了模型太黑、看不清的问题)
 */
function createCar() {
    carContainer = new THREE.Group();
    
    // 3.1 车身
    const bodyGeo = new THREE.BoxGeometry(2, 0.8, 4.2);
    // 使用 MeshPhysicalMaterial 获得更好的金属质感
    const bodyMat = new THREE.MeshPhysicalMaterial({ 
        color: 0x050505, // 接近黑色
        clearcoat: 1.0, 
        clearcoatRoughness: 0.1,
        metalness: 0.6,
        roughness: 0.4
    });
    carBody = new THREE.Mesh(bodyGeo, bodyMat);
    carBody.position.y = 0.6;
    carBody.castShadow = true;
    carContainer.add(carBody);
    
    // 3.2 车顶
    const roofGeo = new THREE.BoxGeometry(1.7, 0.5, 2.0);
    const roof = new THREE.Mesh(roofGeo, bodyMat);
    roof.position.set(0, 1.25, -0.3);
    carContainer.add(roof);

    // 3.3 标志性的贯穿尾灯 (发光)
    const tailGeo = new THREE.BoxGeometry(1.9, 0.1, 0.1);
    const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    tailLights = new THREE.Mesh(tailGeo, tailMat);
    tailLights.position.set(0, 0.8, 2.12);
    carContainer.add(tailLights);

    // 尾灯光晕 (点光源)
    const tailLightSrc = new THREE.PointLight(0xff0000, 1, 15);
    tailLightSrc.position.set(0, 0.8, 2.5);
    carContainer.add(tailLightSrc);

    // 3.4 扰流板
    const wingGeo = new THREE.BoxGeometry(2.2, 0.05, 0.6);
    const wing = new THREE.Mesh(wingGeo, bodyMat);
    wing.position.set(0, 1.1, 2.0);
    carContainer.add(wing);

    scene.add(carContainer);
}

/**
 * 4. 环境装饰 (低多边形山脉)
 */
function createEnvironment() {
    // 在远处随机生成一些金字塔作为山
    const mGroup = new THREE.Group();
    const material = new THREE.MeshStandardMaterial({ 
        color: 0x1a0b2e, 
        roughness: 1, 
        flatShading: true 
    });
    
    for(let i=0; i<40; i++) {
        const h = 20 + Math.random() * 50;
        const geo = new THREE.ConeGeometry(h/2, h, 4);
        const mesh = new THREE.Mesh(geo, material);
        
        // 随机分布在场景周围
        const r = 80 + Math.random() * 100;
        const theta = Math.random() * Math.PI * 2;
        
        mesh.position.x = Math.sin(theta) * r;
        mesh.position.z = Math.cos(theta) * r;
        mesh.position.y = h/2 - 20; // 沉入地下一点
        
        mGroup.add(mesh);
    }
    scene.add(mGroup);
}

/**
 * 5. 核心逻辑：物理移动与摄像机
 */
function updatePhysics() {
    // 简单的加减速
    if (STATE.handsReady) {
        CONFIG.speed += 0.01;
    } else {
        CONFIG.speed *= 0.95; // 没人操作就减速
    }
    CONFIG.speed = Math.min(Math.max(CONFIG.speed, 0), CONFIG.maxSpeed);

    // 1. 沿路径移动
    // speed 转换成 u 的增量 (u 是 0~1)
    const speedFactor = 0.00015 * CONFIG.speed;
    STATE.u += speedFactor;
    if (STATE.u > 1) STATE.u = 0;

    // 2. 获取当前路径上的点和切线
    const pointOnCurve = curve.getPointAt(STATE.u);
    const tangent = curve.getTangentAt(STATE.u).normalize();
    
    // 3. 计算左右偏移 (Lerp 平滑)
    // 手势输入 STATE.targetOffset 范围是 -1 ~ 1
    // 我们让 STATE.offset 慢慢接近 targetOffset
    STATE.offset += (STATE.targetOffset - STATE.offset) * CONFIG.turnSpeed;
    
    // 计算法线 (Right Vector)
    const up = new THREE.Vector3(0, 1, 0);
    // 右向量 = 切线 叉乘 上向量
    const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
    
    // 4. 定位车身
    // 实际位置 = 曲线点 + 右向量 * 偏移量 * 路宽一半
    const finalPos = pointOnCurve.clone().add(right.multiplyScalar(-STATE.offset * (CONFIG.roadWidth/2 - 2)));
    
    carContainer.position.copy(finalPos);
    
    // 5. 旋转车身
    // 让车头朝向切线方向
    // 为了防止 LookAt 翻转，我们看前方一点点
    const lookTarget = curve.getPointAt((STATE.u + 0.01) % 1);
    // 加上偏移量修正 LookTarget，否则车会斜着走
    const nextTangent = curve.getTangentAt((STATE.u + 0.01) % 1).normalize();
    const nextRight = new THREE.Vector3().crossVectors(nextTangent, up).normalize();
    const finalLookTarget = lookTarget.clone().add(nextRight.multiplyScalar(-STATE.offset * (CONFIG.roadWidth/2 - 2)));

    carContainer.lookAt(finalLookTarget);
    
    // 增加视觉倾斜 (模拟悬挂)
    // 转向时，车身向反方向倾斜 (Roll)
    const roll = STATE.offset * 0.3; // 持续的侧倾
    carContainer.rotation.z += (STATE.targetOffset - STATE.offset) * 0.5; // 转向瞬间的侧倾

    // 6. 摄像机跟随 (关键修复点)
    // 摄像机位置 = 车位置 - 切线方向*距离 + 向上*高度
    // 这种算法最稳，不会穿模
    const camPos = carContainer.position.clone()
        .sub(tangent.clone().multiplyScalar(CONFIG.cameraDistance))
        .add(new THREE.Vector3(0, CONFIG.cameraHeight, 0));
        
    // 摄像机平滑插值
    camera.position.lerp(camPos, 0.1);
    
    // 摄像机看向车前方一点，增加动态感
    const camLookAt = carContainer.position.clone().add(tangent.clone().multiplyScalar(10));
    camera.lookAt(camLookAt);

    // 7. 更新 UI
    document.querySelector('.speed-box').innerHTML = Math.floor(CONFIG.speed * 120) + ' <span class="speed-unit">KM/H</span>';
}

function animate() {
    requestAnimationFrame(animate);
    updatePhysics();
    renderer.render(scene, camera);
}

/**
 * 6. MediaPipe AI 手势识别
 */
function initAI() {
    const videoEl = document.getElementById('webcam-preview');
    const statusEl = document.getElementById('status-msg');
    const loadingEl = document.getElementById('loading');
    const progressEl = document.getElementById('progress');
    const steeringDot = document.getElementById('steering-dot');

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(results => {
        // 隐藏Loading
        loadingEl.style.opacity = 0;
        setTimeout(()=>loadingEl.style.display='none', 500);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            STATE.handsReady = true;
            statusEl.innerText = "识别成功：左右摆动手掌转向";
            statusEl.style.color = "#00ff88";

            const lm = results.multiHandLandmarks[0];
            // 计算手掌重心和指尖的相对位置
            // 简单算法：比较手腕(0)和中指指尖(12)的X坐标
            const wrist = lm[0];
            const middleTip = lm[12];
            
            // 计算倾斜差值
            const diffX = middleTip.x - wrist.x;
            
            // 放大灵敏度 (通常diffX在 -0.2 到 0.2 之间)
            let steer = diffX * 4.0;
            // 限制在 -1 到 1
            steer = Math.max(-1, Math.min(1, steer));
            
            // 镜像修正 (如果觉得反了，去掉这里的负号)
            // 视频是镜像的，如果你向左歪头，屏幕上是向右。
            // 这里的逻辑：手向左倾斜(屏幕左边) -> 车左转
            STATE.targetOffset = steer;

        } else {
            STATE.handsReady = false;
            statusEl.innerText = "未检测到手部 - 请在摄像头前举起单手";
            statusEl.style.color = "#ff4444";
            // 自动回正
            STATE.targetOffset = 0;
        }

        // 更新下方 UI 指示条
        const leftPerc = 50 + (STATE.targetOffset * 50);
        steeringDot.style.left = leftPerc + '%';
    });

    const cameraInput = new Camera(videoEl, {
        onFrame: async () => {
            await hands.send({image: videoEl});
        },
        width: 320,
        height: 240
    });

    // 模拟进度条
    progressEl.style.width = "50%";
    
    cameraInput.start().then(()=>{
        progressEl.style.width = "100%";
    });
}

// 启动
window.onload = init;

</script>
</body>
</html>
