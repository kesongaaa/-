<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystic Tarot Experience</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-size: 24px; letter-spacing: 4px; pointer-events: none;
            text-shadow: 0 0 10px #d4af37; transition: opacity 1s;
        }
        #video-feed {
            position: absolute; bottom: 10px; right: 10px; width: 160px; height: 120px;
            transform: scaleX(-1); opacity: 0.3; border-radius: 8px; border: 1px solid #333;
            z-index: 100; pointer-events: none; display: none; /* Hidden by default, enable if debug needed */
        }
        #guide {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5); text-align: center; font-size: 14px; pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
    </style>
    <!-- Three.js & Plugins -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- GSAP for Animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">INITIALIZING THE VOID...</div>
    <video id="video-feed" playsinline></video>
    <div id="guide">
        ğŸ‘‹ æŒ¥æ‰‹æ»‘åŠ¨ &nbsp;|&nbsp; â˜ï¸ é£ŸæŒ‡é€‰æ‹© &nbsp;|&nbsp; ğŸ‘Œ æåˆæŠ½å– &nbsp;|&nbsp; ğŸ– å¼ å¼€æ¶ˆæ•£
    </div>

<script>
/**
 * é…ç½®ä¸å…¨å±€çŠ¶æ€
 */
const CONFIG = {
    cardCount: 22, // å¤§é˜¿å¡çº³
    cardGap: 1.8,  // ç‰Œé—´è·
    camZ: 12,      // ç›¸æœºè·ç¦»
    bloomStrength: 1.2,
    bloomRadius: 0.5,
    bloomThreshold: 0.1,
    scrollFriction: 0.95, // æ»šåŠ¨é˜»å°¼
    hoverLift: 0.8,       // æ‚¬åœä¸Šæµ®é«˜åº¦
    particlesCount: 2000
};

const STATE = {
    scrollX: 0,        // å½“å‰æ»šåŠ¨ä½ç½®
    targetScrollX: 0,  // ç›®æ ‡æ»šåŠ¨ä½ç½®ï¼ˆç‰©ç†ï¼‰
    velocity: 0,       // æ»šåŠ¨é€Ÿåº¦
    handX: 0,          // å½’ä¸€åŒ–æ‰‹éƒ¨Xåæ ‡ (-1 to 1)
    handY: 0,          // å½’ä¸€åŒ–æ‰‹éƒ¨Yåæ ‡ (-1 to 1)
    isHandPresent: false,
    gesture: 'NONE',   // NONE, WAVE, HOVER, PINCH, OPEN
    hoverIndex: -1,    // å½“å‰è¢«æŒ‡çš„ç‰Œç´¢å¼•
    selectedIndex: -1, // è¢«æŠ½å‡ºçš„ç‰Œç´¢å¼•
    mode: 'BROWSING',  // BROWSING, DRAWING, VIEWING, DISSOLVING
    lastHandX: 0,
    pinchDist: 0
};

// å¡”ç½—ç‰Œåç§°
const TAROT_NAMES = [
    "The Fool", "The Magician", "The High Priestess", "The Empress", "The Emperor", 
    "The Hierophant", "The Lovers", "The Chariot", "Strength", "The Hermit", 
    "Wheel of Fortune", "Justice", "The Hanged Man", "Death", "Temperance", 
    "The Devil", "The Tower", "The Star", "The Moon", "The Sun", "Judgement", "The World"
];

// ------------------------------------------------------------------
// 1. èµ„æºç”Ÿæˆ (Canvas Textures) - é¿å…å¤–éƒ¨ä¾èµ–
// ------------------------------------------------------------------

function createCardBackTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 800;
    const ctx = canvas.getContext('2d');
    
    // èƒŒæ™¯æ·±è‰²
    ctx.fillStyle = '#110a1a'; 
    ctx.fillRect(0,0,512,800);
    
    // é‡‘è‰²è¾¹æ¡†
    ctx.strokeStyle = '#cba135';
    ctx.lineWidth = 15;
    ctx.strokeRect(20,20,472,760);
    
    // ç¥ç§˜å›¾æ¡ˆ (ç®€å•çš„å‡ ä½•å›¾æ¡ˆ)
    ctx.beginPath();
    ctx.arc(256, 400, 100, 0, Math.PI*2);
    ctx.lineWidth = 5;
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(256, 200); ctx.lineTo(256, 600);
    ctx.moveTo(156, 400); ctx.lineTo(356, 400);
    ctx.stroke();

    // å™ªç‚¹çº¹ç†
    for(let i=0; i<5000; i++) {
        ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.1})`;
        ctx.fillRect(Math.random()*512, Math.random()*800, 2, 2);
    }
    
    const tex = new THREE.CanvasTexture(canvas);
    return tex;
}

function createCardFrontTexture(index) {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 800;
    const ctx = canvas.getContext('2d');
    
    // ç¾Šçš®çº¸èƒŒæ™¯
    ctx.fillStyle = '#eaddcf'; 
    ctx.fillRect(0,0,512,800);
    
    // å†…éƒ¨è¾¹æ¡†
    ctx.strokeStyle = '#4a3b2a';
    ctx.lineWidth = 10;
    ctx.strokeRect(30,30,452,740);

    // æ–‡å­—
    ctx.fillStyle = '#222';
    ctx.textAlign = 'center';
    ctx.font = 'bold 40px Courier New';
    
    // ç½—é©¬æ•°å­—
    const roman = ["0", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "XVII", "XVIII", "XIX", "XX", "XXI"];
    ctx.fillText(roman[index], 256, 100);

    // åç§°
    ctx.font = 'bold 36px Times New Roman';
    const name = TAROT_NAMES[index].toUpperCase();
    // ç®€å•çš„è‡ªåŠ¨æ¢è¡Œå¤„ç†
    const words = name.split(' ');
    let y = 600;
    words.forEach(word => {
        ctx.fillText(word, 256, y);
        y += 50;
    });

    // ä¸­å¿ƒå›¾å½¢å ä½ (ä¸€ä¸ªé»‘è‰²çš„åœ†)
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(256, 350, 120, 0, Math.PI*2);
    ctx.fill();
    
    // ç¼–å·
    ctx.fillStyle = '#d4af37';
    ctx.font = '100px serif';
    ctx.fillText(index, 256, 385);

    const tex = new THREE.CanvasTexture(canvas);
    return tex;
}

function createParticleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16,16,0,16,16,16);
    grad.addColorStop(0, 'rgba(255, 230, 150, 1)');
    grad.addColorStop(1, 'rgba(255, 230, 150, 0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,32,32);
    return new THREE.CanvasTexture(canvas);
}

// ------------------------------------------------------------------
// 2. Three.js åœºæ™¯æ­å»º
// ------------------------------------------------------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050505);
scene.fog = new THREE.FogExp2(0x050505, 0.04);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 1, CONFIG.camZ);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ReinhardToneMapping;
document.body.appendChild(renderer.domElement);

// ç¯å…‰
const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
scene.add(ambientLight);

const spotLight = new THREE.SpotLight(0xffffff, 1.5);
spotLight.position.set(0, 10, 10);
spotLight.angle = 0.5;
spotLight.penumbra = 0.5;
spotLight.castShadow = true;
scene.add(spotLight);

// é‡ç‚¹ï¼šå¡ç‰Œç»„
const deckGroup = new THREE.Group();
scene.add(deckGroup);

const cardGeometry = new THREE.BoxGeometry(1.4, 2.4, 0.05);
const backMat = new THREE.MeshStandardMaterial({ 
    map: createCardBackTexture(),
    roughness: 0.4,
    metalness: 0.3
});
const sideMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

const cards = [];

for (let i = 0; i < CONFIG.cardCount; i++) {
    // æè´¨æ•°ç»„ï¼šå³å·¦ä¸Šä¸‹å‰å
    const frontMat = new THREE.MeshStandardMaterial({ 
        map: createCardFrontTexture(i),
        roughness: 0.6
    });
    
    // æ³¨æ„ï¼šBoxGeometry æè´¨é¡ºåºæ˜¯ right, left, top, bottom, front, back
    // è¿™é‡Œæˆ‘ä»¬å‡è®¾ front é¢æ˜¯ index 4, back æ˜¯ index 5
    // ä½†ä¸ºäº†ç¿»ç‰Œæ–¹ä¾¿ï¼Œæˆ‘ä»¬ç»Ÿä¸€èƒŒé¢æœå‘Z+ (é»˜è®¤)ï¼Œæ­£é¢æœå‘Z-
    // æˆ–è€…æˆ‘ä»¬åšåŒé¢æè´¨ï¼Œè¿™é‡Œç®€å•å¤„ç†ï¼šZ+ æ˜¯èƒŒé¢ï¼ŒZ- æ˜¯æ­£é¢
    
    const materials = [sideMat, sideMat, sideMat, sideMat, frontMat, backMat];
    
    const card = new THREE.Mesh(cardGeometry, materials);
    // åˆå§‹ä½ç½®
    card.position.x = (i - CONFIG.cardCount / 2) * CONFIG.cardGap;
    card.castShadow = true;
    card.receiveShadow = true;
    
    // è‡ªå®šä¹‰æ•°æ®
    card.userData = { 
        id: i, 
        originalX: card.position.x,
        baseY: 0,
        targetY: 0,
        targetZ: 0,
        targetRotX: 0,
        targetRotY: 0,
        isHovered: false
    };
    
    deckGroup.add(card);
    cards.push(card);
}

// ç²’å­ç³»ç»Ÿ (ç”¨äºæ¶ˆæ•£)
let particleSystem;
function initParticles(pos) {
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const velocities = [];
    const sizes = [];
    
    for(let i=0; i<CONFIG.particlesCount; i++) {
        // åœ¨å¡ç‰Œä½“ç§¯å†…éšæœº
        const x = (Math.random() - 0.5) * 1.4;
        const y = (Math.random() - 0.5) * 2.4;
        const z = (Math.random() - 0.5) * 0.2;
        positions.push(x, y, z);
        
        // çˆ†ç‚¸é€Ÿåº¦
        velocities.push(
            (Math.random() - 0.5) * 0.1,
            (Math.random() - 0.5) * 0.1,
            (Math.random() - 0.5) * 0.1 + 0.02 // ç•¥å¾®å‘å‰
        );
        sizes.push(Math.random());
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    
    const mat = new THREE.PointsMaterial({
        size: 0.05,
        color: 0xffd700,
        map: createParticleTexture(),
        transparent: true,
        opacity: 1,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });
    
    particleSystem = new THREE.Points(geometry, mat);
    particleSystem.userData = { velocities: velocities, life: 1.0 };
    particleSystem.position.copy(pos);
    scene.add(particleSystem);
}

// Post-Processing
const composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);

const bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    CONFIG.bloomStrength,
    CONFIG.bloomRadius,
    CONFIG.bloomThreshold
);
composer.addPass(bloomPass);

// ------------------------------------------------------------------
// 3. äº¤äº’é€»è¾‘ (The Brain)
// ------------------------------------------------------------------

// è¾…åŠ© Raycaster
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function updateGestureLogic(landmarks) {
    if (!landmarks || STATE.mode === 'VIEWING' || STATE.mode === 'DISSOLVING') return;

    // 1. è·å–å…³é”®ç‚¹
    const thumbTip = landmarks[4];
    const indexTip = landmarks[8];
    const middleTip = landmarks[12];
    const palmBase = landmarks[0];
    const indexMCP = landmarks[5]; // é£ŸæŒ‡æ ¹éƒ¨

    // åæ ‡è½¬æ¢ä¸º -1 åˆ° 1
    STATE.handX = (1 - indexTip.x) * 2 - 1; // é•œåƒç¿»è½¬
    STATE.handY = (1 - indexTip.y) * 2 - 1;

    // 2. æŒ¥æ‰‹æ£€æµ‹ (è®¡ç®—æŒå¿ƒé€Ÿåº¦)
    const currentPalmX = (1 - palmBase.x);
    const deltaX = currentPalmX - STATE.lastHandX;
    STATE.lastHandX = currentPalmX;

    // 3. æåˆæ£€æµ‹ (é£ŸæŒ‡+æ‹‡æŒ‡è·ç¦»)
    const dist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
    STATE.pinchDist = dist;
    const isPinching = dist < 0.05;

    // 4. å¼ æ‰‹æ£€æµ‹ (é£ŸæŒ‡å’Œä¸­æŒ‡æŒ‡å°–è·ç¦»è¿œ)
    const openDist = Math.hypot(indexTip.x - middleTip.x, indexTip.y - middleTip.y);
    const isPalmOpen = openDist > 0.15; // ç®€åŒ–åˆ¤æ–­

    // çŠ¶æ€æœºåˆ¤æ–­
    if (isPalmOpen && Math.abs(STATE.handX) < 0.3) {
        STATE.gesture = 'OPEN';
        // æ‰‹æŒå¼ å¼€åœ¨ä¸­é—´ -> åˆ¹è½¦
        STATE.velocity *= 0.85; 
    } else if (isPinching) {
        STATE.gesture = 'PINCH';
    } else if (Math.abs(deltaX) > 0.02) {
        STATE.gesture = 'WAVE';
        // æ–½åŠ æ¨åŠ›
        STATE.velocity += deltaX * 1.5; // çµæ•åº¦ç³»æ•°
    } else {
        STATE.gesture = 'HOVER';
    }

    // 5. æ‚¬åœé«˜äº®é€»è¾‘ (ä»…åœ¨æµè§ˆæ¨¡å¼)
    if (STATE.mode === 'BROWSING' && STATE.gesture === 'HOVER') {
        // ç®€å•çš„é€»è¾‘ï¼šå°†å±å¹•Xåæ ‡æ˜ å°„åˆ°ç‰Œå †ä½ç½®
        // Raycaster æ›´å‡†ç¡®ï¼Œæˆ‘ä»¬ç”¨ Raycaster æŠ•å°„é£ŸæŒ‡ä½ç½®
        mouse.x = STATE.handX;
        mouse.y = STATE.handY;
        raycaster.setFromCamera(mouse, camera);
        
        // æˆ‘ä»¬ä¸ç›´æ¥ raycast åˆ° Mesh (å¤ªè€—è´¹)ï¼Œè€Œæ˜¯è®¡ç®— Ray ä¸ Z=0 å¹³é¢çš„äº¤ç‚¹ X
        // æˆ–è€…æ›´ç®€å•çš„ï¼šæ ¹æ® scrollX å’Œ handX ä¼°ç®—
        // è®©æˆ‘ä»¬ç”¨ Raycaster + Invisible Plane è·å¾—ç²¾ç¡®çš„ä¸–ç•Œåæ ‡ X
        const planeZ = 0;
        const vec = new THREE.Vector3();
        vec.set(mouse.x, mouse.y, 0.5);
        vec.unproject(camera);
        vec.sub(camera.position).normalize();
        const distance = (planeZ - camera.position.z) / vec.z;
        const worldPos = camera.position.clone().add(vec.multiplyScalar(distance));
        
        // æŸ¥æ‰¾å“ªä¸ªå¡ç‰Œæœ€æ¥è¿‘ worldPos.x
        let minDest = 999;
        let targetIdx = -1;
        
        // è€ƒè™‘åˆ° deckGroup åœ¨ç§»åŠ¨ï¼Œæˆ‘ä»¬éœ€è¦æŠŠ worldPos è½¬æ¢åˆ° local ç©ºé—´
        const localX = worldPos.x - deckGroup.position.x;

        cards.forEach((card, idx) => {
            const dist = Math.abs(card.userData.originalX - localX);
            if (dist < 0.8) { // é˜ˆå€¼
                if (dist < minDest) {
                    minDest = dist;
                    targetIdx = idx;
                }
            }
        });
        STATE.hoverIndex = targetIdx;
    } else {
        STATE.hoverIndex = -1;
    }

    // 6. æŠ½ç‰Œè§¦å‘
    if (STATE.mode === 'BROWSING' && STATE.gesture === 'PINCH' && STATE.hoverIndex !== -1) {
        triggerDrawCard(STATE.hoverIndex);
    }
}

// è§¦å‘æŠ½ç‰ŒåŠ¨ç”»
function triggerDrawCard(index) {
    if (STATE.mode !== 'BROWSING') return;
    STATE.mode = 'DRAWING';
    STATE.selectedIndex = index;
    const card = cards[index];

    // å°†å¡ç‰Œä» Group ä¸­â€œåˆ†ç¦»â€è§†è§‰æ•ˆæœ (ä¿æŒåœ¨ Group ç»“æ„ä¸­ï¼Œä½†ç”¨ world position åŠ¨ç”»è¦†ç›–)
    // æ›´å¥½çš„åšæ³•ï¼šæŠŠå¡ç‰Œ attach åˆ° Sceneï¼Œä¿ç•™ä¸–ç•Œå˜æ¢
    scene.attach(card);

    // GSAP åŠ¨ç”»åºåˆ—
    const tl = gsap.timeline({
        onComplete: () => {
            STATE.mode = 'VIEWING';
        }
    });

    // 1. ç§»å‡ºå¹¶å˜å¤§
    tl.to(card.position, {
        x: 0,
        y: 0,
        z: 8, // é è¿‘ç›¸æœº
        duration: 1.5,
        ease: "power2.inOut"
    }, 0);

    // 2. ç¿»è½¬ (æ³¨æ„æè´¨é¡ºåºï¼Œindex 5æ˜¯èƒŒé¢ï¼Œ4æ˜¯æ­£é¢)
    // åˆå§‹æ˜¯èƒŒé¢æœåƒæœº (Rotation 0)ï¼Œæˆ‘ä»¬éœ€è¦ç»• Y è½´è½¬ 180
    tl.to(card.rotation, {
        y: Math.PI, // ç¿»è½¬ 180 åº¦
        x: 0,
        z: 0,
        duration: 1.5,
        ease: "back.out(1.2)" // å¸¦ä¸€ç‚¹å¼¹æ€§
    }, 0.2);

    // 3. Bloom çˆ†å‘
    tl.to(bloomPass, {
        strength: 3.0,
        duration: 0.5,
        yoyo: true,
        repeat: 1
    }, 0.5);
}

// è§¦å‘æ¶ˆæ•£
function triggerDissolve() {
    if (STATE.mode !== 'VIEWING') return;
    STATE.mode = 'DISSOLVING';
    
    const card = cards[STATE.selectedIndex];
    
    // åˆå§‹åŒ–ç²’å­
    initParticles(card.position);

    // éšè—å¡ç‰Œ
    card.visible = false;

    // ç²’å­åŠ¨ç”»åœ¨ render loop ä¸­å¤„ç†ï¼Œè¿‡å‡ ç§’é‡ç½®
    setTimeout(resetGame, 3000);
}

function resetGame() {
    // æ¸…ç†ç²’å­
    if(particleSystem) {
        scene.remove(particleSystem);
        particleSystem.geometry.dispose();
        particleSystem = null;
    }
    
    // é‡ç½®å¡ç‰Œ
    const card = cards[STATE.selectedIndex];
    deckGroup.attach(card); // æ”¾å›ç»„é‡Œ
    card.visible = true;
    card.position.set(card.userData.originalX, 0, 0);
    card.rotation.set(0, 0, 0);
    
    STATE.mode = 'BROWSING';
    STATE.selectedIndex = -1;
    STATE.hoverIndex = -1;
    STATE.velocity = 0;
    
    // é‡ç½® Bloom
    bloomPass.strength = CONFIG.bloomStrength;
}

// ------------------------------------------------------------------
// 4. ä¸»å¾ªç¯ (Animation Loop)
// ------------------------------------------------------------------
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    
    const dt = clock.getDelta();

    // --- ç‰©ç†æ»šåŠ¨é€»è¾‘ ---
    if (STATE.mode === 'BROWSING') {
        // é˜»å°¼
        STATE.velocity *= CONFIG.scrollFriction;
        
        // é™åˆ¶æœ€å°é€Ÿåº¦
        if (Math.abs(STATE.velocity) < 0.001) STATE.velocity = 0;
        
        deckGroup.position.x += STATE.velocity;

        // è¾¹ç•Œé™åˆ¶ (ç±»ä¼¼å¼¹ç°§å›å¼¹)
        const minX = - (CONFIG.cardCount * CONFIG.cardGap) / 2; 
        const maxX = (CONFIG.cardCount * CONFIG.cardGap) / 2;
        
        // è½¯è¾¹ç•Œé€»è¾‘ï¼šç¨å¾®æ‹‰å›æ¥
        if (deckGroup.position.x > 8) deckGroup.position.x = THREE.MathUtils.lerp(deckGroup.position.x, 8, 0.1);
        if (deckGroup.position.x < -25) deckGroup.position.x = THREE.MathUtils.lerp(deckGroup.position.x, -25, 0.1);

        // --- å¡ç‰Œä¸ªä½“åŠ¨ç”» (Hover effect) ---
        cards.forEach((card, i) => {
            // åŸºç¡€ä½ç½®å¤ä½
            let targetY = 0;
            let targetZ = 0;
            let targetRotX = 0;
            let targetRotZ = 0;
            let scale = 1;

            if (i === STATE.hoverIndex) {
                targetY = 0.5;
                targetZ = 1.0;
                targetRotX = -0.2; // ç¨å¾®å‰å€¾
                scale = 1.1;
                // è®© hover çš„å¡ç‰Œå‘å…‰æ›´äº®
                card.material[5].emissive = new THREE.Color(0x222222); 
            } else {
                card.material[5].emissive = new THREE.Color(0x000000);
            }

            // å¹³æ»‘æ’å€¼
            card.position.y = THREE.MathUtils.lerp(card.position.y, targetY, 0.1);
            card.position.z = THREE.MathUtils.lerp(card.position.z, targetZ, 0.1);
            card.rotation.x = THREE.MathUtils.lerp(card.rotation.x, targetRotX, 0.1);
            // å¾®å¾®çš„éšæœºæ¼‚æµ®
            const time = clock.getElapsedTime();
            card.position.y += Math.sin(time * 2 + i) * 0.002;
        });
    }

    // --- ç²’å­æ›´æ–° ---
    if (STATE.mode === 'DISSOLVING' && particleSystem) {
        const positions = particleSystem.geometry.attributes.position.array;
        const velocities = particleSystem.userData.velocities;
        
        for(let i=0; i<CONFIG.particlesCount; i++) {
            positions[i*3] += velocities[i*3] + (Math.random()-0.5)*0.01;
            positions[i*3+1] += velocities[i*3+1] + (Math.random()-0.5)*0.01;
            positions[i*3+2] += velocities[i*3+2];
            
            // é€æ¸å˜å¤§å¹¶æ¶ˆæ•£
            velocities[i*3+1] += 0.001; // ä¸Šå‡
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;
        
        particleSystem.material.opacity -= 0.01;
        if (particleSystem.material.opacity <= 0) particleSystem.material.opacity = 0;
    }

    // --- æ‰‹åŠ¿ï¼šæŸ¥çœ‹æ¨¡å¼ä¸‹çš„æ¶ˆæ•£ ---
    if (STATE.mode === 'VIEWING') {
        // å¦‚æœæ£€æµ‹åˆ°å¼ å¼€æ‰‹æŒ
        if (STATE.gesture === 'OPEN') {
            triggerDissolve();
        }
        
        // è®©å±•ç¤ºçš„å¡ç‰Œç¼“æ…¢æµ®åŠ¨
        const card = cards[STATE.selectedIndex];
        const time = clock.getElapsedTime();
        card.rotation.z = Math.sin(time * 0.5) * 0.05;
        card.rotation.y = Math.PI + Math.sin(time * 0.3) * 0.1;
    }

    // æ¸²æŸ“
    composer.render();
}

// ------------------------------------------------------------------
// 5. MediaPipe åˆå§‹åŒ–
// ------------------------------------------------------------------
const videoElement = document.getElementById('video-feed');
const loadingElement = document.getElementById('loading');

const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
});

hands.onResults(results => {
    loadingElement.style.opacity = 0; // Hide loading once running
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        STATE.isHandPresent = true;
        updateGestureLogic(results.multiHandLandmarks[0]);
    } else {
        STATE.isHandPresent = false;
        STATE.gesture = 'NONE';
        STATE.hoverIndex = -1;
    }
});

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 640,
    height: 480
});

// å¯åŠ¨
cameraUtils.start()
    .then(() => {
        console.log("Camera started");
        animate();
    })
    .catch(err => {
        console.error("Camera Error:", err);
        loadingElement.innerHTML = "CAMERA ACCESS DENIED.<br>Please allow camera access.";
    });

// çª—å£å¤§å°è°ƒæ•´
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
