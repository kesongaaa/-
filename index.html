<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Tarot Ritual</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Times New Roman', serif; }
        canvas { display: block; }
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #6b5a38; font-size: 16px; letter-spacing: 4px; pointer-events: none;
            text-transform: uppercase; opacity: 0.8; transition: opacity 1s;
        }
        #ui-layer {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            color: #444; font-size: 12px; pointer-events: none; letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.9);
        }
        .highlight { color: #8a7342; font-weight: bold; }
        /* éšè—è§†é¢‘æµï¼Œä¿æŒæ²‰æµ¸æ„Ÿ */
        #video-input { display: none; }
    </style>

    <!-- ä¾èµ–åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">Summoning The Circle...</div>
    <video id="video-input" playsinline></video>
    <div id="ui-layer">
        <span class="highlight">ğŸ‘‹ æŒ¥åŠ¨</span> æ—‹è½¬ &nbsp;â€¢&nbsp; 
        <span class="highlight">â˜ï¸ æŒ‡å‘</span> å‡è§† &nbsp;â€¢&nbsp; 
        <span class="highlight">ğŸ‘Œ æåˆ(ä¿æŒ)</span> æŠ½å– &nbsp;â€¢&nbsp; 
        <span class="highlight">âœŠ æ¡æ‹³</span> é‡Šæ”¾
    </div>

<script>
/**
 * ============================================================================
 * é…ç½®ä¸å¸¸é‡ (é™å™ªã€å…‹åˆ¶)
 * ============================================================================
 */
const CONFIG = {
    cardCount: 22,
    radius: 7.5,
    cardW: 1.4,
    cardH: 2.35,
    bloomStrength: 0.8, // é™ä½ Bloomï¼ŒæŸ”å’Œ
    bloomRadius: 0.8,
    bloomThreshold: 0.15,
    friction: 0.95,     // æ—‹è½¬é˜»å°¼
    hoverDrag: 0.90,    // æŒ‡å‘æ—¶çš„å¼ºé˜»å°¼ï¼ˆæ¨¡æ‹Ÿæ‰‹æŒ‡å‹åœ¨è½¬ç›˜ä¸Šï¼‰
    pinchThresh: 0.05,
    pinchTime: 300,     // msï¼Œæåˆå¿…é¡»æŒç»­çš„æ—¶é—´
    goldColor: 0x8a7342, // æš—é‡‘
    lightColor: 0xffaa55 // çƒ›å…‰
};

// çŠ¶æ€æšä¸¾ (äº’æ–¥)
const MODES = {
    ORBIT: 0,      // è‡ªç”±/å—åŠ›æ—‹è½¬
    BRAKING: 1,    // æ‰‹æŒ‡æŒ‡å‘ä¸­ï¼Œæ­£åœ¨è‰°éš¾å‡é€Ÿ
    HOVER: 2,      // å‡ ä¹é™æ­¢ï¼Œé«˜äº®æŸå¼ ç‰Œï¼Œç­‰å¾…é€‰æ‹©
    LOCKED: 3,     // å·²é”å®šï¼Œå‡†å¤‡æŠ½ç‰Œ (æåˆæˆåŠŸ)
    REVEAL: 4,     // ç‰Œå·²æŠ½å‡ºï¼Œå±•ç¤ºä¸­
    DISPERSE: 5,   // ç²’å­æ¶ˆæ•£ä¸­
    REBALANCE: 6   // è¡¥ä½åŠ¨ç”»ä¸­
};

const STATE = {
    mode: MODES.ORBIT,
    rotVel: 0.002,      // åˆå§‹å¾®åŠ¨
    handX: 0, handY: 0, // å¹³æ»‘åçš„æ‰‹éƒ¨åæ ‡
    rawHandX: 0, rawHandY: 0,
    isHandActive: false,
    hoverTarget: null,  // å½“å‰æ‚¬åœçš„ Mesh
    selectedCard: null, // è¢«æŠ½å‡ºçš„ Mesh
    pinchStart: 0,      // æåˆå¼€å§‹æ—¶é—´æˆ³
    cards: [],          // æ´»è·ƒå¡ç‰Œæ•°ç»„
    gapAngle: 0         // ç”¨äºè¡¥ä½è®¡ç®—
};

// ============================================================================
// 1. æè´¨ä¸çº¹ç† (æš—é»‘ä»ªå¼æ„Ÿ)
// ============================================================================

// å¡èƒŒï¼šæ·±è‰²ã€ä½å¯¹æ¯”åº¦ã€ç¥ç§˜ç¬¦å·
function createBackTexture() {
    const cvs = document.createElement('canvas');
    cvs.width = 512; cvs.height = 800;
    const ctx = cvs.getContext('2d');
    
    // ææš—èƒŒæ™¯
    ctx.fillStyle = '#08050a';
    ctx.fillRect(0,0,512,800);
    
    // æš—çº¹
    ctx.strokeStyle = '#2a2215';
    ctx.lineWidth = 2;
    for(let i=0; i<20; i++) {
        ctx.beginPath();
        ctx.arc(256, 400, 30 + i*20, 0, Math.PI*2);
        ctx.stroke();
    }
    
    // é‡‘è‰²è¾¹æ¡† (æš—)
    ctx.strokeStyle = '#5c4d2e';
    ctx.lineWidth = 12;
    ctx.strokeRect(20,20,472,760);

    // å™ªç‚¹
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,512,800);

    return new THREE.CanvasTexture(cvs);
}

// å¡é¢ï¼šç¾Šçš®çº¸ã€æŠ½è±¡ã€ä¸å‘å…‰
function createFrontTexture(idx) {
    const cvs = document.createElement('canvas');
    cvs.width = 512; cvs.height = 800;
    const ctx = cvs.getContext('2d');
    
    // ç¾Šçš®çº¸
    ctx.fillStyle = '#dcd3c3';
    ctx.fillRect(0,0,512,800);
    // çƒ§ç„¦è¾¹ç¼˜
    const g = ctx.createRadialGradient(256,400,200,256,400,600);
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(40,30,10,0.8)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,512,800);

    // å›¾è…¾
    ctx.translate(256,400);
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 6;
    ctx.beginPath();
    const sides = 3 + (idx % 5);
    for(let i=0; i<=sides; i++) {
        const a = (i/sides)*Math.PI*2;
        ctx.lineTo(Math.cos(a)*100, Math.sin(a)*100);
    }
    ctx.stroke();
    
    return new THREE.CanvasTexture(cvs);
}

// ç²’å­çº¹ç†ï¼šé‡‘è‰²ç²‰å°˜
function createDustTexture() {
    const cvs = document.createElement('canvas');
    cvs.width = 64; cvs.height = 64;
    const ctx = cvs.getContext('2d');
    const g = ctx.createRadialGradient(32,32,0,32,32,32);
    g.addColorStop(0, 'rgba(200, 160, 80, 1)'); // æ ¸å¿ƒäº®
    g.addColorStop(1, 'rgba(200, 160, 80, 0)'); // è¾¹ç¼˜é€
    ctx.fillStyle = g;
    ctx.fillRect(0,0,64,64);
    return new THREE.CanvasTexture(cvs);
}

// ============================================================================
// 2. åœºæ™¯æ­å»º
// ============================================================================
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x020202, 0.04); // æµ“é›¾

const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 0.1); // ä½äºåœ†å¿ƒ

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

// ç¯å…‰ï¼šå…‹åˆ¶ã€ç‚¹å…‰æº
const candleLight = new THREE.PointLight(CONFIG.lightColor, 1.2, 25);
candleLight.position.set(0, 2, 0);
scene.add(candleLight);

const ambient = new THREE.AmbientLight(0x223344, 0.3); // å†·è‰²ç¯å¢ƒå…‰å¯¹æ¯”
scene.add(ambient);

// ç‰Œç»„å®¹å™¨
const ringGroup = new THREE.Group();
ringGroup.position.y = -1.2; 
scene.add(ringGroup);

// åˆ›å»ºå¡ç‰Œ
const geo = new THREE.BoxGeometry(CONFIG.cardW, CONFIG.cardH, 0.04);
const backTex = createBackTexture();
const matSide = new THREE.MeshBasicMaterial({ color: 0x111111 });
const matBack = new THREE.MeshStandardMaterial({ 
    map: backTex, roughness: 0.7, metalness: 0.1 
});

for(let i=0; i<CONFIG.cardCount; i++) {
    const matFront = new THREE.MeshStandardMaterial({
        map: createFrontTexture(i), roughness: 0.9
    });
    // Materials: R, L, T, B, Front(Z+), Back(Z-)
    // æˆ‘ä»¬è®© Z+ æ˜¯èƒŒé¢(æœå†…)ï¼ŒZ- æ˜¯æ­£é¢(æœå¤–ï¼Œåˆå§‹ä¸å¯è§)
    // ä¿®æ­£ï¼šBoxGeometry é»˜è®¤ Front æ˜¯ Z+ã€‚
    // æˆ‘ä»¬å¸Œæœ›åˆå§‹çœ‹åˆ°çš„æ˜¯èƒŒé¢ã€‚æ‰€ä»¥ Z+ è´´èƒŒé¢ã€‚
    // Z- è´´æ­£é¢ã€‚
    const mats = [matSide, matSide, matSide, matSide, matBack, matFront];
    
    const card = new THREE.Mesh(geo, mats);
    
    // æ•°æ®ç»“æ„
    const angle = (i / CONFIG.cardCount) * Math.PI * 2;
    card.userData = {
        id: i,
        angle: angle, // é€»è¾‘è§’åº¦
        baseY: 0,
        origScale: 1
    };
    
    // åˆå§‹ä½ç½®
    updateCardPosition(card, angle);
    card.lookAt(0, -1.2, 0); // æœå‘åœ†å¿ƒ
    
    ringGroup.add(card);
    STATE.cards.push(card);
}

function updateCardPosition(card, angle) {
    card.position.x = Math.sin(angle) * CONFIG.radius;
    card.position.z = Math.cos(angle) * CONFIG.radius;
    card.rotation.y = angle + Math.PI; // èƒŒé¢æœåœ†å¿ƒ
}

// ç²’å­ç³»ç»Ÿ (é¢„åŠ è½½)
const pCount = 2000;
const pGeo = new THREE.BufferGeometry();
const pPos = new Float32Array(pCount * 3);
const pVel = new Float32Array(pCount * 3);
const pLife = new Float32Array(pCount); // 0-1
pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
pGeo.setAttribute('alpha', new THREE.BufferAttribute(pLife, 1));

const pMat = new THREE.ShaderMaterial({
    uniforms: {
        tex: { value: createDustTexture() }
    },
    vertexShader: `
        attribute float alpha;
        varying float vAlpha;
        void main() {
            vAlpha = alpha;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = (10.0 / -mvPosition.z) * (0.5 + alpha);
            gl_Position = projectionMatrix * mvPosition;
        }
    `,
    fragmentShader: `
        uniform sampler2D tex;
        varying float vAlpha;
        void main() {
            vec4 c = texture2D(tex, gl_PointCoord);
            gl_FragColor = vec4(c.rgb, c.a * vAlpha);
        }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
});
const particleSystem = new THREE.Points(pGeo, pMat);
particleSystem.visible = false;
scene.add(particleSystem);

// Post Processing
const composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));
const bloom = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
bloom.threshold = CONFIG.bloomThreshold;
bloom.strength = CONFIG.bloomStrength;
bloom.radius = CONFIG.bloomRadius;
composer.addPass(bloom);

// å…‰æ ‡ (DEBUG/FEEDBACK)
const cursor = new THREE.Mesh(
    new THREE.RingGeometry(0.04, 0.05, 32),
    new THREE.MeshBasicMaterial({ color: 0x8a7342, transparent: true, opacity: 0.3 })
);
scene.add(cursor);

// ============================================================================
// 3. æ ¸å¿ƒé€»è¾‘ï¼šæ‰‹åŠ¿çŠ¶æ€æœº & ç‰©ç†
// ============================================================================
const raycaster = new THREE.Raycaster();

function updateLogic(dt) {
    // 1. å¹³æ»‘æ‰‹éƒ¨åæ ‡
    STATE.handX += (STATE.rawHandX - STATE.handX) * 0.15;
    STATE.handY += (STATE.rawHandY - STATE.handY) * 0.15;

    // æ›´æ–°å…‰æ ‡ä½ç½®
    const vec = new THREE.Vector3(STATE.handX, STATE.handY, 0.5);
    vec.unproject(camera);
    const dir = vec.sub(camera.position).normalize();
    cursor.position.copy(camera.position).add(dir.multiplyScalar(4));
    cursor.lookAt(camera.position);

    // 2. çŠ¶æ€åˆ†å‘
    switch (STATE.mode) {
        case MODES.ORBIT:
            handleOrbitMode();
            break;
        case MODES.BRAKING:
        case MODES.HOVER:
            handleInteraction(dt);
            break;
        case MODES.LOCKED:
            // ç­‰å¾…åŠ¨ç”»è§¦å‘
            break;
        case MODES.REVEAL:
            handleRevealMode();
            break;
    }
}

function handleOrbitMode() {
    // æƒ¯æ€§æ—‹è½¬
    ringGroup.rotation.y += STATE.rotVel;
    STATE.rotVel *= CONFIG.friction;

    // æŒ¥åŠ¨æ£€æµ‹ï¼šå¦‚æœæ‰‹åœ¨åŠ¨ï¼Œå¢åŠ åŠ›çŸ©
    // ç®€å•çš„æ‰‹éƒ¨ X è½´ç§»åŠ¨æ˜ å°„åˆ°æ—‹è½¬åŠ›
    // ä»…å½“æ‰‹å¤„äºéä¸­å¿ƒä½ç½®æ—¶æ‰ç®—â€œæ‹¨åŠ¨â€
    if (STATE.isHandActive && Math.abs(STATE.handX) > 0.3) {
        STATE.rotVel -= (STATE.handX * 0.0005);
    }

    // è½¬æ¢åˆ° HOVER æ£€æµ‹
    // åªæœ‰å½“é£ŸæŒ‡ä¼¸å‡ºæŒ‡å‘æ—¶ (æˆ‘ä»¬ç”¨å°„çº¿æ£€æµ‹ä»£æ›¿)
    if (STATE.isHandActive) {
        checkHover();
        if (STATE.hoverTarget) {
            STATE.mode = MODES.BRAKING; // è¿›å…¥å‡é€Ÿé˜¶æ®µ
        }
    }
}

function handleInteraction(dt) {
    // é˜»å°¼é€»è¾‘ï¼šæ¨¡æ‹Ÿæ‰‹æŒ‡å‹åœ¨è½¬ç›˜ä¸Š
    if (STATE.hoverTarget) {
        STATE.rotVel *= CONFIG.hoverDrag; // å¼ºåŠ›é˜»å°¼
        ringGroup.rotation.y += STATE.rotVel;

        // å¦‚æœé€Ÿåº¦è¶³å¤Ÿä½ï¼Œè¿›å…¥å®Œå…¨ HOVER
        if (Math.abs(STATE.rotVel) < 0.0005) {
            STATE.mode = MODES.HOVER;
            STATE.rotVel = 0;
            // æ­¤æ—¶åœ†ç¯åœæ­¢ï¼Œé«˜äº®ç”Ÿæ•ˆ
        }
    } else {
        // ä¸¢å¤±ç›®æ ‡ï¼Œå›åˆ° ORBIT
        STATE.mode = MODES.ORBIT;
    }

    // æŒç»­å°„çº¿æ£€æµ‹
    checkHover();

    // æåˆæ£€æµ‹ (ä»…åœ¨ HOVER ä¸”æœ‰ç›®æ ‡æ—¶)
    if (STATE.mode === MODES.HOVER && STATE.hoverTarget && isPinching()) {
        const now = performance.now();
        if (STATE.pinchStart === 0) STATE.pinchStart = now;
        
        if (now - STATE.pinchStart > CONFIG.pinchTime) {
            // æåˆæˆåŠŸ
            triggerDraw(STATE.hoverTarget);
        }
    } else {
        STATE.pinchStart = 0;
    }
}

function handleRevealMode() {
    // æ¡æ‹³æ£€æµ‹ -> è§¦å‘æ¶ˆæ•£
    if (isFist()) {
        triggerDisperse();
    }
    
    // æ‚¬æµ®åŠ¨ç”»
    if (STATE.selectedCard) {
        const t = performance.now() * 0.001;
        STATE.selectedCard.position.y += Math.sin(t) * 0.002;
        STATE.selectedCard.rotation.z = Math.sin(t*0.5) * 0.05;
    }
}

// å°„çº¿æ£€æµ‹
function checkHover() {
    raycaster.setFromCamera({ x: STATE.handX, y: STATE.handY }, camera);
    const intersects = raycaster.intersectObjects(STATE.cards);
    
    if (intersects.length > 0) {
        const obj = intersects[0].object;
        if (STATE.hoverTarget !== obj) {
            // åˆ‡æ¢ç›®æ ‡
            STATE.hoverTarget = obj;
        }
    } else {
        STATE.hoverTarget = null;
    }
}

// æ‰‹åŠ¿è¾…åŠ©
let _pinchDist = 1;
let _fingerCurl = false;

function isPinching() {
    return _pinchDist < CONFIG.pinchThresh;
}
function isFist() {
    return _fingerCurl;
}

// ============================================================================
// 4. å…³é”®åŠ¨ç”»åºåˆ— (GSAP)
// ============================================================================

function triggerDraw(card) {
    if (STATE.mode === MODES.LOCKED) return;
    STATE.mode = MODES.LOCKED;
    STATE.selectedCard = card;

    // 1. åæ ‡ç³»è½¬æ¢ï¼šä» Group æ‹¿å‡ºæ”¾å…¥ Scene
    const worldPos = new THREE.Vector3();
    const worldQuat = new THREE.Quaternion();
    card.getWorldPosition(worldPos);
    card.getWorldQuaternion(worldQuat);
    scene.attach(card); // ä¿æŒä¸–ç•Œå˜æ¢
    
    // 2. åŠ¨ç”»
    const tl = gsap.timeline({
        onComplete: () => { STATE.mode = MODES.REVEAL; }
    });

    // ç›®æ ‡ä½ç½®ï¼šç›¸æœºæ­£å‰æ–¹
    const targetPos = new THREE.Vector3(0, 0, -2.5);
    targetPos.applyQuaternion(camera.quaternion);
    targetPos.add(camera.position);

    // é£æ¥
    tl.to(card.position, {
        x: targetPos.x, y: targetPos.y, z: targetPos.z,
        duration: 2.0, ease: "power3.inOut"
    }, 0);

    // ç¿»è½¬ (Yè½´è½¬180åº¦å±•ç¤ºæ­£é¢)
    // å½“å‰ rotation æ˜¯åŸºäºä¸–ç•Œåæ ‡çš„ã€‚æˆ‘ä»¬éœ€è¦å®ƒæ­£é¢æœå‘ç›¸æœºã€‚
    // ç®€å•åšæ³•ï¼šè®©å®ƒ LookAt ç›¸æœºï¼Œç„¶åä¿®æ­£ (å› ä¸ºæˆ‘ä»¬æ­£é¢æè´¨æ˜¯ Z-)
    // è¿™é‡Œæˆ‘ä»¬æ‰‹åŠ¨æ’å€¼æ—‹è½¬
    const targetRot = new THREE.Euler(0, Math.PI, 0); // å‡å®šç›¸æœºæœªå¤§åŠ¨
    
    tl.to(card.rotation, {
        x: targetRot.x, y: targetRot.y, z: targetRot.z,
        duration: 2.0, ease: "power2.inOut"
    }, 0);

    // Bloom å¢å¼º
    tl.to(bloom, { strength: 2.5, duration: 1.0, yoyo: true, repeat: 1 }, 0.5);
}

function triggerDisperse() {
    if (STATE.mode !== MODES.REVEAL) return;
    STATE.mode = MODES.DISPERSE;

    const card = STATE.selectedCard;
    const center = card.position.clone();

    // 1. åˆå§‹åŒ–ç²’å­
    particleSystem.visible = true;
    const pos = pGeo.attributes.position.array;
    const vel = pVel;
    const life = pGeo.attributes.alpha.array;

    for(let i=0; i<pCount; i++) {
        // åœ¨å¡ç‰Œè¡¨é¢éšæœºåˆ†å¸ƒ
        pos[i*3] = center.x + (Math.random()-0.5)*1.4;
        pos[i*3+1] = center.y + (Math.random()-0.5)*2.3;
        pos[i*3+2] = center.z;
        
        // ç¼“æ…¢æ‰©æ•£é€Ÿåº¦
        vel[i*3] = (Math.random()-0.5) * 0.02;
        vel[i*3+1] = (Math.random()-0.5) * 0.02;
        vel[i*3+2] = (Math.random()) * 0.01; // å¾®å¾®å‘å
        
        life[i] = 1.0;
    }
    pGeo.attributes.position.needsUpdate = true;
    pGeo.attributes.alpha.needsUpdate = true;

    // 2. éšè—å¡ç‰Œ
    card.visible = false;

    // 3. ç²’å­åŠ¨ç”»å¾ªç¯ç”± animate å¤„ç†
    
    // 4. 2ç§’åå¼€å§‹è¡¥ä½
    setTimeout(triggerRebalance, 1500);
}

function triggerRebalance() {
    STATE.mode = MODES.REBALANCE;

    // ä»æ•°ç»„ç§»é™¤
    const idx = STATE.cards.indexOf(STATE.selectedCard);
    if (idx > -1) STATE.cards.splice(idx, 1);
    
    // é”€æ¯æ—§å¡ç‰Œ Mesh
    scene.remove(STATE.selectedCard); // çœŸæ­£ç§»é™¤
    STATE.selectedCard = null;

    // è®¡ç®—å‰©ä½™å¡ç‰Œçš„æ–°è§’åº¦å¸ƒå±€
    const count = STATE.cards.length;
    if (count === 0) return;

    STATE.cards.forEach((c, i) => {
        // é‡æ–°å‡åŒ€åˆ†å¸ƒ
        const newAngle = (i / count) * Math.PI * 2;
        
        // æˆ‘ä»¬åŠ¨ç”» c.userData.angleï¼Œå¹¶åœ¨ update ä¸­åŒæ­¥åˆ° position
        // æ³¨æ„ï¼šè¦å¤„ç†è·¨è¶Š 2PI çš„æƒ…å†µ (è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥ç¼“åŠ¨)
        gsap.to(c.userData, {
            angle: newAngle,
            duration: 2.5,
            ease: "power2.inOut",
            onUpdate: () => {
                // æ›´æ–°ä½ç½®
                c.position.x = Math.sin(c.userData.angle) * CONFIG.radius;
                c.position.z = Math.cos(c.userData.angle) * CONFIG.radius;
                c.rotation.y = c.userData.angle + Math.PI;
            }
        });
    });

    // è¡¥ä½å®Œæˆåå›åˆ° ORBIT
    setTimeout(() => {
        STATE.mode = MODES.ORBIT;
        particleSystem.visible = false;
        STATE.rotVel = 0.002;
    }, 2600);
}

// ============================================================================
// 5. ä¸»å¾ªç¯
// ============================================================================
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    // é€»è¾‘æ›´æ–°
    updateLogic(dt);

    // è§†è§‰åé¦ˆï¼šå¡ç‰Œé«˜äº® (ä»…åœ¨é DISPERSE çŠ¶æ€)
    if (STATE.mode !== MODES.DISPERSE) {
        STATE.cards.forEach(c => {
            if (c === STATE.hoverTarget && STATE.mode !== MODES.ORBIT) {
                // æŸ”å’Œçš„æš—é‡‘é«˜äº®
                c.material[4].emissive.setHex(0x443311);
                // å¾®å¾®ä¸Šæµ®
                c.position.y = THREE.MathUtils.lerp(c.position.y, 0.3, 0.1);
            } else {
                c.material[4].emissive.setHex(0x000000);
                c.position.y = THREE.MathUtils.lerp(c.position.y, 0, 0.1);
            }
        });
    }

    // ç²’å­æ›´æ–°
    if (STATE.mode === MODES.DISPERSE || STATE.mode === MODES.REBALANCE) {
        const pos = pGeo.attributes.position.array;
        const vel = pVel;
        const life = pGeo.attributes.alpha.array;
        
        for(let i=0; i<pCount; i++) {
            if (life[i] > 0) {
                pos[i*3] += vel[i*3];
                pos[i*3+1] += vel[i*3+1];
                pos[i*3+2] += vel[i*3+2];
                life[i] -= 0.005 + Math.random()*0.005; // éšæœºè¡°å‡
            }
        }
        pGeo.attributes.position.needsUpdate = true;
        pGeo.attributes.alpha.needsUpdate = true;
    }

    composer.render();
}
animate();

// ============================================================================
// 6. MediaPipe Input
// ============================================================================
const videoEl = document.getElementById('video-input');
const loader = document.getElementById('loader');

const hands = new Hands({locateFile: (file) => 
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
});

hands.onResults(res => {
    loader.style.opacity = 0;
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        STATE.isHandActive = true;
        const lm = res.multiHandLandmarks[0];
        
        // åæ ‡
        const indexTip = lm[8];
        STATE.rawHandX = (1 - indexTip.x) * 2 - 1;
        STATE.rawHandY = (1 - indexTip.y) * 2 - 1;

        // æåˆæ£€æµ‹ (æ‹‡æŒ‡å°–-é£ŸæŒ‡å°–)
        const thumbTip = lm[4];
        _pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);

        // æ¡æ‹³æ£€æµ‹ (æŒ‡å°–ä½äºæŒ‡æ ¹)
        // ç®€å•åˆ¤å®šï¼šé£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ Tip y > PIP y (MediaPipe yå‘ä¸‹å¢å¤§)
        // ä¸”æ‹‡æŒ‡ Tip é è¿‘ä¸­æŒ‡ PIP
        const isFistState = (
            lm[8].y > lm[6].y && // é£ŸæŒ‡å¼¯æ›²
            lm[12].y > lm[10].y && // ä¸­æŒ‡å¼¯æ›²
            lm[16].y > lm[14].y    // æ— åæŒ‡å¼¯æ›²
        );
        _fingerCurl = isFistState;
        
    } else {
        STATE.isHandActive = false;
        _pinchDist = 1;
        _fingerCurl = false;
    }
});

const cam = new Camera(videoEl, {
    onFrame: async () => { await hands.send({image: videoEl}); },
    width: 640, height: 480
});
cam.start();

// Resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
