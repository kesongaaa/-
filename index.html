<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Racer - 手势控制</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050011; font-family: 'Segoe UI', sans-serif; }
        
        /* 游戏容器 */
        #game-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }

        /* HUD 界面风格 */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #00f3ff; font-family: 'Courier New', monospace;
            text-transform: uppercase; pointer-events: none;
        }
        .hud-panel {
            background: rgba(0, 10, 30, 0.6);
            border: 1px solid #00f3ff;
            box-shadow: 0 0 10px #00f3ff;
            padding: 20px;
            border-radius: 4px;
            backdrop-filter: blur(5px);
        }
        h1 { margin: 0 0 10px 0; font-size: 24px; letter-spacing: 2px; text-shadow: 0 0 5px #d200ff; color: #fff; }
        .stat-row { font-size: 20px; margin: 5px 0; display: flex; align-items: center; }
        .label { color: #d200ff; margin-right: 10px; width: 80px; }
        
        /* 摄像头画面风格 */
        #webcam-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 260px; height: 195px; z-index: 10;
            border: 2px solid #d200ff;
            box-shadow: 0 0 15px #d200ff;
            background: #000;
            transform: scaleX(-1); /* 镜像 */
        }
        #webcam-video { width: 100%; height: 100%; object-fit: cover; opacity: 0.6; }
        #webcam-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* 加载动画 */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; color: #00f3ff;
        }
        .loader-ring {
            width: 50px; height: 50px; border: 4px solid #333;
            border-top: 4px solid #00f3ff; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .guide-text { font-size: 14px; color: #aaa; margin-top: 10px; border-top: 1px solid #333; padding-top: 10px; }
    </style>

    <!-- MediaPipe 库 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">
        <div class="loader-ring"></div>
        <div>INITIALIZING SYSTEM...</div>
    </div>

    <div id="ui-layer">
        <div class="hud-panel">
            <h1>NEON RACER</h1>
            <div class="stat-row"><span class="label">SPEED</span> <span id="speed-display">0</span> km/h</div>
            <div class="stat-row"><span class="label">STEER</span> <span id="steer-display">0</span>°</div>
            <div class="guide-text">
                单手握持手势<br>
                逆时针(左倾) -> <span style="color:#d200ff">右转</span><br>
                顺时针(右倾) -> <span style="color:#00f3ff">左转</span>
            </div>
        </div>
    </div>

    <div id="webcam-container">
        <video id="webcam-video" playsinline></video>
        <canvas id="webcam-canvas"></canvas>
    </div>

    <div id="game-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // ==========================================
        // 1. 游戏配置
        // ==========================================
        const CONFIG = {
            maxSpeed: 0.8,          // 降低最大速度，更适合巡航
            acceleration: 0.005,    // 加速更平缓
            friction: 0.98,
            turnSensitivity: 0.03,  // 转向更加沉稳
            maxSteerAngle: 0.5,
            roadWidth: 40,
            colors: {
                neonCyan: 0x00f3ff,
                neonPink: 0xd200ff,
                ground: 0x0a0a0a,
                sky: 0x050011
            }
        };

        const STATE = {
            speed: 0,
            steering: 0,
            targetSteering: 0,
            distance: 0,            // 总行驶距离，用于滚动纹理
            handDetected: false
        };

        // ==========================================
        // 2. Three.js 初始化 (科技感场景)
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.sky);
        // 远处的雾，隐藏地平线
        scene.fog = new THREE.FogExp2(CONFIG.colors.sky, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // 相机放低一点，更有赛车感
        const cameraOffset = new THREE.Vector3(0, 3, 8); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('game-container').appendChild(renderer.domElement);

        // --- 地面 (无限延伸逻辑) ---
        // 我们不移动地面 Mesh，而是让纹理滚动
        const planeGeo = new THREE.PlaneGeometry(200, 200, 40, 40); // 大量分段以获得透视感
        
        // 生成一个网格纹理
        function createGridTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // 背景黑
            ctx.fillStyle = '#000000';
            ctx.fillRect(0,0,1024,1024);
            
            // 纵向线 (青色) - 路
            ctx.strokeStyle = '#00f3ff';
            ctx.lineWidth = 4;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00f3ff';
            
            // 画中间的路
            const roadW = 400;
            const center = 512;
            ctx.beginPath();
            ctx.moveTo(center - roadW/2, 0); ctx.lineTo(center - roadW/2, 1024);
            ctx.moveTo(center + roadW/2, 0); ctx.lineTo(center + roadW/2, 1024);
            ctx.stroke();

            // 横向线 (粉色) - 速度感
            ctx.strokeStyle = '#d200ff';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#d200ff';
            for(let i=0; i<=1024; i+=128) {
                ctx.beginPath();
                ctx.moveTo(center - roadW/2 - 200, i); 
                ctx.lineTo(center + roadW/2 + 200, i);
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.anisotropy = 16;
            return texture;
        }

        const gridTexture = createGridTexture();
        const planeMat = new THREE.MeshBasicMaterial({ 
            map: gridTexture,
            color: 0xffffff
        });
        const ground = new THREE.Mesh(planeGeo, planeMat);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // --- 赛车 (Tron 风格线框) ---
        const carGroup = new THREE.Group();
        
        // 车身主体 (黑色遮挡)
        const bodyGeo = new THREE.BoxGeometry(2, 0.8, 4);
        const bodyMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const carBody = new THREE.Mesh(bodyGeo, bodyMat);
        carBody.position.y = 0.6;
        carGroup.add(carBody);

        // 发光轮廓
        const edges = new THREE.EdgesGeometry(bodyGeo);
        const lineMat = new THREE.LineBasicMaterial({ color: CONFIG.colors.neonCyan, linewidth: 2 });
        const carOutline = new THREE.LineSegments(edges, lineMat);
        carBody.add(carOutline);

        // 两个后尾灯 (拖尾)
        const tailGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
        const tailMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.neonPink });
        const tailL = new THREE.Mesh(tailGeo, tailMat);
        tailL.position.set(-0.6, 0.6, 2);
        const tailR = new THREE.Mesh(tailGeo, tailMat);
        tailR.position.set(0.6, 0.6, 2);
        carGroup.add(tailL);
        carGroup.add(tailR);

        scene.add(carGroup);

        // --- 环境粒子 (模拟星空/速度线) ---
        const particlesGeo = new THREE.BufferGeometry();
        const particlesCount = 500;
        const posArray = new Float32Array(particlesCount * 3);
        
        for(let i=0; i<particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 200; // 宽范围分布
        }
        
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMat = new THREE.PointsMaterial({
            size: 0.5,
            color: 0xffffff,
            transparent: true,
            opacity: 0.8
        });
        const starField = new THREE.Points(particlesGeo, particlesMat);
        scene.add(starField);

        // --- 灯光 (虽然用了 BasicMaterial，加个灯增加层次感) ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x000000, 1);
        scene.add(hemiLight);


        // ==========================================
        // 3. MediaPipe 手势识别 (反向逻辑)
        // ==========================================
        const videoElement = document.getElementById('webcam-video');
        const canvasElement = document.getElementById('webcam-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            // 绘制摄像头画面
            if(results.image) canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 绘制骨架
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00f3ff', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#d200ff', lineWidth: 1});

                // 获取手腕(0)和中指根部(9)
                const wrist = landmarks[0];
                const middle = landmarks[9];

                // 计算水平偏移量 (X轴)
                // MediaPipe x坐标: 0(左) -> 1(右)
                // 手向右倒 (顺时针) -> middle.x > wrist.x -> delta > 0
                // 手向左倒 (逆时针) -> middle.x < wrist.x -> delta < 0
                const deltaX = middle.x - wrist.x;

                // --- 关键逻辑：反向控制 ---
                // 目标：顺时针(delta > 0) -> 左转 (Rotation Y Positive)
                // 目标：逆时针(delta < 0) -> 右转 (Rotation Y Negative)
                // 因此：targetSteer 与 deltaX 同号
                
                const sensitivity = 4.0; 
                let steerInput = deltaX * sensitivity;
                
                // 限制最大角度
                steerInput = Math.max(-1, Math.min(1, steerInput));
                
                STATE.targetSteering = steerInput * CONFIG.maxSteerAngle;

            } else {
                STATE.handDetected = false;
                STATE.targetSteering = 0; // 无手时回正
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start().then(() => document.getElementById('loading').style.display = 'none');

        // ==========================================
        // 4. 游戏逻辑循环
        // ==========================================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function updatePhysics() {
            // 1. 速度逻辑
            if (STATE.handDetected && STATE.speed < CONFIG.maxSpeed) {
                STATE.speed += CONFIG.acceleration;
            } else if (!STATE.handDetected) {
                STATE.speed *= CONFIG.friction; // 减速
            }

            // 2. 转向逻辑 (插值平滑)
            STATE.steering += (STATE.targetSteering - STATE.steering) * CONFIG.turnSensitivity;
            
            // 应用转向到车身旋转
            carGroup.rotation.y = STATE.steering;

            // 3. 移动逻辑 (世界坐标系)
            // 计算位移分量
            const moveX = Math.sin(STATE.steering) * STATE.speed;
            const moveZ = Math.cos(STATE.steering) * STATE.speed; // 这个其实不需要实际移动车太远

            // **核心技巧：车只在X轴左右移动，Z轴看似前进其实是纹理后退**
            // 这样可以避免数字过大，也更容易控制无限地图
            
            // X轴移动 (限制在路宽内)
            // 反向逻辑注意：如果车头向左(Rotation > 0)，车应该向左跑
            // 在Threejs中，X轴右为正。RotationY左为正。
            // 所以 Rotation > 0 (左转) -> X 应该减小。
            carGroup.position.x += Math.sin(carGroup.rotation.y) * STATE.speed; // 这里不需要特别反向，因为steering本身已经处理了方向

            // 限制赛道边界
            if(carGroup.position.x > 30) carGroup.position.x = 30;
            if(carGroup.position.x < -30) carGroup.position.x = -30;

            // Z轴：我们不真正移动车很远，而是移动纹理和粒子
            // 记录虚拟行驶距离
            STATE.distance += STATE.speed;

            // 滚动地面纹理 (模拟前进)
            // 纹理 repeat 设为了 1，offset.y 增加会让纹理向后跑，看起来像车向前
            gridTexture.offset.y = -(STATE.distance * 0.2) % 1;

            // 移动粒子 (模拟飞逝的星星)
            const positions = starField.geometry.attributes.position.array;
            for(let i=1; i<positions.length; i+=3) { // Y轴是高度，我们改Z轴 (索引+2)
                // 让粒子迎面飞来
                positions[i+1] += STATE.speed * 20; 
                if(positions[i+1] > 20) {
                    positions[i+1] = -180; // 复位到远处
                }
            }
            starField.geometry.attributes.position.needsUpdate = true;

            // 4. 相机跟随
            // 相机位置 = 车位置 + 偏移
            const targetCamPos = new THREE.Vector3(
                carGroup.position.x * 0.7, // X轴少跟一点，增加速度感
                carGroup.position.y + cameraOffset.y,
                carGroup.position.z + cameraOffset.z
            );
            camera.position.lerp(targetCamPos, 0.1);
            
            // 相机看车前方一点的地方
            const lookTarget = new THREE.Vector3(carGroup.position.x, 0, carGroup.position.z - 20);
            camera.lookAt(lookTarget);

            // 5. 更新 UI
            document.getElementById('speed-display').innerText = Math.floor(STATE.speed * 200);
            // 显示角度，取反显示比较符合直觉（左是负，右是正）
            document.getElementById('steer-display').innerText = Math.floor(THREE.MathUtils.radToDeg(-STATE.steering));
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>
