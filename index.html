<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystic Tarot - Three.js & MediaPipe</title>
    <style>
        :root {
            --primary: #d4af37;
            --bg: #111;
            --panel-bg: rgba(0, 0, 0, 0.85);
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            user-select: none;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--primary);
            padding: 15px;
            border-radius: 8px;
            pointer-events: auto;
            position: absolute;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
            transition: opacity 0.3s;
        }
        /* Top Info */
        #status-panel {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            min-width: 300px;
        }
        #card-name {
            font-size: 1.5em;
            color: var(--primary);
            margin: 0;
            font-weight: bold;
        }
        #card-meaning {
            font-size: 0.9em;
            margin-top: 5px;
            color: #ccc;
        }
        /* Controls */
        #controls {
            bottom: 20px;
            left: 20px;
            font-size: 0.85em;
        }
        #mode-toggle {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 5px;
        }
        /* History */
        #history-panel {
            top: 20px;
            right: 20px;
            width: 250px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .history-item {
            border-bottom: 1px solid #444;
            padding: 8px 0;
            font-size: 0.85em;
            display: flex;
            align-items: center;
        }
        .history-item img {
            width: 30px;
            height: 50px;
            margin-right: 10px;
            object-fit: cover;
        }
        .history-item .reversed {
            transform: rotate(180deg);
        }
        .rev-tag {
            color: #ff6b6b;
            font-size: 0.8em;
            margin-left: 5px;
        }
        /* Loading */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 999;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .spinner {
            width: 50px; height: 50px;
            border: 5px solid #333;
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Video hidden for processing */
        #input_video { display: none; }
    </style>
    
    <!-- Dependencies -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p id="loading-text">Loading Neural Networks & Assets...</p>
    </div>

    <div id="canvas-container"></div>
    <video id="input_video"></video>

    <div id="ui-layer">
        <div id="status-panel" class="panel">
            <div id="card-name">å‡†å¤‡ä¸­...</div>
            <div id="card-meaning">è¯·ç­‰å¾…å‘ç‰Œ</div>
        </div>

        <div id="history-panel" class="panel">
            <h3>æŠ½å¡è®°å½•</h3>
            <div id="history-list"></div>
        </div>

        <div id="controls" class="panel">
            <div>å½“å‰æ¨¡å¼: <span id="mode-label" style="color:var(--primary)">åˆå§‹åŒ–...</span></div>
            <div id="gesture-hint">
                ğŸ– <b>å¼ å¼€</b>: æ‚¬åœ/é‡ç½®<br>
                ğŸ‘Œ <b>æåˆ</b>: æŠ“å–å¡ç‰Œ<br>
                âœŠ <b>æ¡æ‹³</b>: ç¡®è®¤ç»“æœ
            </div>
            <div id="mouse-hint" style="display:none">
                ğŸ–±ï¸ <b>ç§»åŠ¨</b>: æ‚¬åœ<br>
                ğŸ–±ï¸ <b>å·¦é”®æŒ‰ä½</b>: æŠ“å–<br>
                âŒ¨ï¸ <b>ç©ºæ ¼é”®</b>: ç¡®è®¤(æŠ“å–æ—¶)
            </div>
            <button id="mode-toggle">åˆ‡æ¢è¾“å…¥æ¨¡å¼</button>
        </div>
    </div>

<script>
/**
 * å¡”ç½—ç‰Œæ•°æ® (å¤§é˜¿å¡çº³ 0-21)
 * ä½¿ç”¨ç»´åŸºç™¾ç§‘çš„é«˜æ¸…å›¾æº
 */
const TAROT_DATA = [
    { id: 0, name: "The Fool", url: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg", up: "æ–°çš„å¼€å§‹, å†’é™©, çº¯çœŸ", rev: "é²è½, å†’é™©çš„é£é™©, æ„šè ¢" },
    { id: 1, name: "The Magician", url: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg", up: "æ„å¿—åŠ›, åˆ›é€ , æŠ€èƒ½", rev: "æ“çºµ, è®¡åˆ’ä¸å‘¨, æ½œåœ¨å¤©èµ‹" },
    { id: 2, name: "The High Priestess", url: "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg", up: "ç›´è§‰, ç¥ç§˜, å†…åœ¨çŸ¥è¯†", rev: "ç§˜å¯†, å‹æŠ‘çš„æƒ…æ„Ÿ, æ’¤é€€" },
    { id: 3, name: "The Empress", url: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg", up: "ä¸°é¥¶, æ¯æ€§, è‡ªç„¶", rev: "ä¾èµ–, åˆ›é€ åŠ›å—é˜», ç©ºè™š" },
    { id: 4, name: "The Emperor", url: "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg", up: "æƒå¨, ç»“æ„, çˆ¶äº²å½¢è±¡", rev: "æš´æ”¿, åƒµåŒ–, ç¼ºä¹çºªå¾‹" },
    { id: 5, name: "The Hierophant", url: "https://upload.wikimedia.org/wikipedia/commons/8/8d/RWS_Tarot_05_Hierophant.jpg", up: "ä¼ ç»Ÿ, ç²¾ç¥æŒ‡å¼•, ä¿¡ä»°", rev: "åå›, æ–°è§‚å¿µ, é™åˆ¶" },
    { id: 6, name: "The Lovers", url: "https://upload.wikimedia.org/wikipedia/commons/3/3a/TheLovers.jpg", up: "çˆ±, å’Œè°, å…³ç³», é€‰æ‹©", rev: "ä¸å’Œè°, å¤±è¡¡, é”™è¯¯çš„ä»·å€¼è§‚" },
    { id: 7, name: "The Chariot", url: "https://upload.wikimedia.org/wikipedia/commons/9/9b/RWS_Tarot_07_Chariot.jpg", up: "æ§åˆ¶, æ„å¿—åŠ›, èƒœåˆ©", rev: "å¤±æ§, ä¾µç•¥æ€§, ç¼ºä¹æ–¹å‘" },
    { id: 8, name: "Strength", url: "https://upload.wikimedia.org/wikipedia/commons/f/f5/RWS_Tarot_08_Strength.jpg", up: "åŠ›é‡, å‹‡æ°”, åŠå¯¼", rev: "è‡ªæˆ‘æ€€ç–‘, è½¯å¼±, ç”ŸçŒ›" },
    { id: 9, name: "The Hermit", url: "https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg", up: "å†…çœ, å­¤ç‹¬, å¯»æ‰¾çœŸç†", rev: "å­¤ç«‹, åæ‰§, é€€å‡ºç¤¾ä¼š" },
    { id: 10, name: "Wheel of Fortune", url: "https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg", up: "å‘½è¿, è½¬æŠ˜ç‚¹, å‘¨æœŸ", rev: "åè¿æ°”, é˜»åŠ›, å¾ªç¯æ‰“ç ´" },
    { id: 11, name: "Justice", url: "https://upload.wikimedia.org/wikipedia/commons/e/e0/RWS_Tarot_11_Justice.jpg", up: "æ­£ä¹‰, å…¬å¹³, çœŸç›¸", rev: "ä¸å…¬, ç¼ºä¹è´£ä»», ä¸è¯šå®" },
    { id: 12, name: "The Hanged Man", url: "https://upload.wikimedia.org/wikipedia/commons/2/2b/RWS_Tarot_12_Hanged_Man.jpg", up: "æš‚åœ, æ”¾ä¸‹, æ–°è§†è§’", rev: "æ‹–å»¶, æŠµæŠ—, åœæ»" },
    { id: 13, name: "Death", url: "https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg", up: "ç»“æŸ, è½¬å˜, è¿‡æ¸¡", rev: "æŠ—æ‹’æ”¹å˜, æ— æ³•é‡Šæ€€" },
    { id: 14, name: "Temperance", url: "https://upload.wikimedia.org/wikipedia/commons/f/f8/RWS_Tarot_14_Temperance.jpg", up: "å¹³è¡¡, èŠ‚åˆ¶, è€å¿ƒ", rev: "å¤±è¡¡, è¿‡åº¦, ä»“ä¿ƒ" },
    { id: 15, name: "The Devil", url: "https://upload.wikimedia.org/wikipedia/commons/5/55/RWS_Tarot_15_Devil.jpg", up: "æŸç¼š, ç‰©è´¨ä¸»ä¹‰, è¯±æƒ‘", rev: "æ‰“ç ´æ·é”, æ¢å¤åŠ›é‡" },
    { id: 16, name: "The Tower", url: "https://upload.wikimedia.org/wikipedia/commons/5/53/RWS_Tarot_16_Tower.jpg", up: "çªå˜, ç¾éš¾, å¯ç¤º", rev: "é¿å…ç¾éš¾, ææƒ§æ”¹å˜" },
    { id: 17, name: "The Star", url: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg", up: "å¸Œæœ›, çµæ„Ÿ, å®é™", rev: "ç»æœ›, ç¼ºä¹ä¿¡å¿ƒ, æ²®ä¸§" },
    { id: 18, name: "The Moon", url: "https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg", up: "å¹»è§‰, ææƒ§, æ½œæ„è¯†", rev: "é‡Šæ”¾ææƒ§, æ··ä¹±å¹³æ¯" },
    { id: 19, name: "The Sun", url: "https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg", up: "å¿«ä¹, æˆåŠŸ, æ´»åŠ›", rev: "æ¶ˆæ²‰, æš‚æ—¶çš„å¤±è´¥" },
    { id: 20, name: "Judgement", url: "https://upload.wikimedia.org/wikipedia/commons/d/dd/RWS_Tarot_20_Judgement.jpg", up: "å®¡åˆ¤, é‡ç”Ÿ, å†…å¿ƒå¬å”¤", rev: "è‡ªæˆ‘æ€€ç–‘, æ‹’ç»å¬å”¤" },
    { id: 21, name: "The World", url: "https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg", up: "å®Œæˆ, æ•´åˆ, æˆå°±", rev: "æœªå®Œæˆ, ç¼ºä¹é—­ç¯" }
];

// å¡èƒŒçº¹ç† (ç¨‹åºåŒ–ç”Ÿæˆä¸€ä¸ªç®€å•çš„å›¾æ¡ˆ)
function createCardBackTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#2a2a4a';
    ctx.fillRect(0, 0, 256, 512);
    ctx.strokeStyle = '#d4af37';
    ctx.lineWidth = 10;
    ctx.strokeRect(10, 10, 236, 492);
    ctx.beginPath();
    ctx.arc(128, 256, 50, 0, Math.PI * 2);
    ctx.stroke();
    return new THREE.CanvasTexture(canvas);
}

// ----------------------
// å…¨å±€å˜é‡ä¸çŠ¶æ€
// ----------------------
let scene, camera, renderer, light;
let currentCardMesh = null;
let currentCardData = null;
let isReversed = false;
let deck = [...TAROT_DATA];
let particles = []; // ç°çƒ¬ç²’å­æ•°ç»„

// è¾“å…¥çŠ¶æ€
const InputMode = { HAND: 'hand', MOUSE: 'mouse' };
let currentMode = InputMode.HAND;
let handLandmarks = null;
let mouse = new THREE.Vector2();
let isMouseDown = false;
let isSpaceDown = false;

// æ¸¸æˆçŠ¶æ€æœº
const GameState = { IDLE: 0, HOVER: 1, GRABBED: 2, ANIMATING_OUT: 3 };
let currentState = GameState.IDLE;
let raycaster = new THREE.Raycaster();
let cursorPosition = new THREE.Vector2(); // ç»Ÿä¸€å…‰æ ‡ä½ç½® (æ‰‹æˆ–é¼ æ ‡)
let grabOffset = new THREE.Vector3();

// MediaPipe
let hands;
let cameraUtils;

// ----------------------
// åˆå§‹åŒ– Three.js
// ----------------------
function initThree() {
    const container = document.getElementById('canvas-container');
    
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x111111, 0.02);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffeebb, 0.8);
    dirLight.position.set(2, 5, 5);
    dirLight.castShadow = true;
    scene.add(dirLight);
    
    const pointLight = new THREE.PointLight(0xd4af37, 0.5, 10);
    pointLight.position.set(0, 2, 2);
    scene.add(pointLight);

    // ç›‘å¬çª—å£å¤§å°
    window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ----------------------
// å¡ç‰Œé€»è¾‘
// ----------------------
function spawnCard() {
    if (currentCardMesh) {
        scene.remove(currentCardMesh);
        currentCardMesh = null;
    }
    
    if (deck.length === 0) {
        deck = [...TAROT_DATA]; // æ´—ç‰Œ
        addHistoryLog({name: "=== æ´—ç‰Œ ===", isMsg: true});
    }

    // éšæœºæŠ½å–
    const index = Math.floor(Math.random() * deck.length);
    currentCardData = deck[index];
    
    // æ­£é€†ä½åˆ¤å®š
    isReversed = Math.random() < 0.5;

    // åˆ›å»ºå‡ ä½•ä½“
    const geometry = new THREE.BoxGeometry(2, 3.5, 0.05);
    
    // çº¹ç†åŠ è½½
    const loader = new THREE.TextureLoader();
    const backTex = createCardBackTexture();
    
    // é»˜è®¤æè´¨
    const materials = [
        new THREE.MeshStandardMaterial({ color: 0x222222 }), // right
        new THREE.MeshStandardMaterial({ color: 0x222222 }), // left
        new THREE.MeshStandardMaterial({ color: 0x222222 }), // top
        new THREE.MeshStandardMaterial({ color: 0x222222 }), // bottom
        new THREE.MeshStandardMaterial({ color: 0x222222, map: null }), // Front (placeholder)
        new THREE.MeshStandardMaterial({ map: backTex }),   // Back
    ];

    currentCardMesh = new THREE.Mesh(geometry, materials);
    
    // åŠ è½½çœŸå®å›¾ç‰‡
    loader.load(currentCardData.url, (tex) => {
        tex.encoding = THREE.sRGBEncoding;
        currentCardMesh.material[4].map = tex;
        currentCardMesh.material[4].needsUpdate = true;
    }, undefined, () => {
        // å¤±è´¥å›é€€
        currentCardMesh.material[4].color.setHex(0x550000); 
    });

    // åˆå§‹ä½ç½® (åº•éƒ¨å‡èµ·)
    currentCardMesh.position.set(0, -5, 0);
    // åˆå§‹æ—‹è½¬ (èƒŒé¢æœä¸Š)
    currentCardMesh.rotation.y = Math.PI; 
    
    // ç›®æ ‡å±æ€§å­˜å‚¨åœ¨userData
    currentCardMesh.userData = {
        targetPos: new THREE.Vector3(0, 0, 0),
        targetRot: new THREE.Euler(0, isReversed ? Math.PI : 0, isReversed ? Math.PI : 0), // æ­£é¢æœå‰ï¼Œå¦‚æœé€†ä½åˆ™Zè½´è½¬180
        isRevealed: false
    };

    scene.add(currentCardMesh);

    // UIæ›´æ–°
    updateUI("å‡†å¤‡æŠ½å–", "è¯·ä½¿ç”¨æ‰‹åŠ¿æˆ–é¼ æ ‡æŠ“å–å¡ç‰Œ");
    currentState = GameState.IDLE;
    
    // è¿›åœºåŠ¨ç”»
    animateEntry();
}

function animateEntry() {
    let startTime = Date.now();
    const duration = 1000;
    
    function loop() {
        if (!currentCardMesh) return;
        const now = Date.now();
        const progress = Math.min((now - startTime) / duration, 1);
        const ease = 1 - Math.pow(1 - progress, 3); // cubic out
        
        currentCardMesh.position.y = -5 + ease * 5; // -5 to 0
        currentCardMesh.rotation.y = Math.PI + ease * Math.PI * 2; // spin
        
        if (progress < 1) requestAnimationFrame(loop);
        else {
            currentCardMesh.rotation.y = Math.PI; // ä¿æŒèƒŒé¢
            currentState = GameState.IDLE;
        }
    }
    loop();
}

// ----------------------
// ç°çƒ¬ç‰¹æ•ˆ (Ash Effect)
// ----------------------
class AshEffect {
    constructor(mesh) {
        this.particles = [];
        const geom = mesh.geometry;
        const posAttribute = geom.attributes.position;
        const count = posAttribute.count;
        
        // é‡‡æ ·ç‚¹
        const sampleRate = 2; // é™ä½é‡‡æ ·ç‡æå‡æ€§èƒ½
        const matWorld = mesh.matrixWorld;
        
        const particleGeom = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];
        
        // ç®€å•é¢œè‰²
        const color = new THREE.Color(0xffaa33); // ç«æ˜Ÿé¢œè‰²
        
        for (let i = 0; i < count; i+=sampleRate) {
            const v = new THREE.Vector3();
            v.fromBufferAttribute(posAttribute, i);
            v.applyMatrix4(matWorld);
            
            this.particles.push({
                pos: v.clone(),
                vel: new THREE.Vector3((Math.random()-0.5)*0.05, Math.random()*0.1 + 0.02, (Math.random()-0.5)*0.05),
                life: 1.0 + Math.random(),
                noiseOffset: Math.random() * 100
            });
            
            positions.push(v.x, v.y, v.z);
            colors.push(color.r, color.g, color.b);
            sizes.push(Math.random() * 0.1);
        }
        
        particleGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        particleGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        // ShaderMaterial for fading
        const material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 1,
            sizeAttenuation: true
        });

        this.mesh = new THREE.Points(particleGeom, material);
        scene.add(this.mesh);
    }

    update() {
        const positions = this.mesh.geometry.attributes.position.array;
        let activeCount = 0;
        
        for (let i = 0; i < this.particles.length; i++) {
            const p = this.particles[i];
            if (p.life > 0) {
                // Turbulence
                p.vel.x += Math.sin(Date.now() * 0.005 + p.noiseOffset) * 0.002;
                
                p.pos.add(p.vel);
                p.life -= 0.02;
                
                positions[i*3] = p.pos.x;
                positions[i*3+1] = p.pos.y;
                positions[i*3+2] = p.pos.z;
                activeCount++;
            }
        }
        
        this.mesh.geometry.attributes.position.needsUpdate = true;
        this.mesh.material.opacity = Math.max(0, this.mesh.material.opacity - 0.01);
        
        return activeCount > 0 && this.mesh.material.opacity > 0;
    }

    dispose() {
        scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
    }
}

// ----------------------
// æ¸¸æˆä¸»å¾ªç¯é€»è¾‘
// ----------------------
function updateGameLogic() {
    if (currentState === GameState.ANIMATING_OUT) {
        // æ›´æ–°ç²’å­
        for (let i = particles.length - 1; i >= 0; i--) {
            const alive = particles[i].update();
            if (!alive) {
                particles[i].dispose();
                particles.splice(i, 1);
            }
        }
        return;
    }

    if (!currentCardMesh) return;

    // 1. è·å–è¾“å…¥çŠ¶æ€ (Pinch? Fist?)
    let isPinching = false;
    let isFisting = false;

    if (currentMode === InputMode.HAND && handLandmarks) {
        // MediaPipe é€»è¾‘
        const thumbTip = handLandmarks[4];
        const indexTip = handLandmarks[8];
        const wrist = handLandmarks[0];
        
        // è®¡ç®—æåˆ (Thumb Tip <-> Index Tip)
        const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
        isPinching = pinchDist < 0.05;

        // è®¡ç®—æ¡æ‹³ (Tip <-> Wrist å¯¹äºæ‰€æœ‰æ‰‹æŒ‡)
        // ç®€åŒ–: ä¸­æŒ‡å°–åˆ°æ‰‹è…•è·ç¦»çŸ­
        const middleTip = handLandmarks[12];
        const fistDist = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
        isFisting = fistDist < 0.15; // é˜ˆå€¼éœ€è°ƒè¯•

        // æ›´æ–°å…‰æ ‡
        // ä½¿ç”¨é£ŸæŒ‡å’Œæ‹‡æŒ‡çš„ä¸­ç‚¹
        const cx = (thumbTip.x + indexTip.x) / 2;
        const cy = (thumbTip.y + indexTip.y) / 2;
        // æ˜ å°„åˆ°å±å¹•åæ ‡ (-1 to 1)
        cursorPosition.set((1 - cx) * 2 - 1, (1 - cy) * 2 - 1); // é•œåƒX

    } else if (currentMode === InputMode.MOUSE) {
        // é¼ æ ‡é€»è¾‘
        cursorPosition.copy(mouse);
        isPinching = isMouseDown;
        isFisting = isSpaceDown;
    }

    // 2. å°„çº¿æ£€æµ‹
    raycaster.setFromCamera(cursorPosition, camera);
    
    // 3. çŠ¶æ€å¤„ç†
    if (currentState === GameState.IDLE || currentState === GameState.HOVER) {
        const intersects = raycaster.intersectObject(currentCardMesh);
        if (intersects.length > 0) {
            document.body.style.cursor = 'pointer';
            // é«˜äº®
            currentCardMesh.scale.setScalar(1.05);
            currentState = GameState.HOVER;

            if (isPinching) {
                currentState = GameState.GRABBED;
                // è®¡ç®—åç§»ï¼Œä½¿å¾—æŠ“å–ç‚¹ä¸è·³åŠ¨
                // ç®€åŒ–ï¼šç›´æ¥å¸é™„åˆ°ä¸­å¿ƒç¨å‰
                updateUI("å·²æŠ“å–", isReversed ? "???" : "???");
            }
        } else {
            document.body.style.cursor = 'default';
            currentCardMesh.scale.setScalar(1);
            currentState = GameState.IDLE;
        }
    }
    
    else if (currentState === GameState.GRABBED) {
        if (!isPinching) {
            // æ¾å¼€ -> å›åˆ°åŸä½ (Idle)
            currentState = GameState.IDLE;
            new TWEEN_Pos(currentCardMesh.position, new THREE.Vector3(0,0,0), 300);
            updateUI("å‡†å¤‡æŠ½å–", "è¯·ä½¿ç”¨æ‰‹åŠ¿æˆ–é¼ æ ‡æŠ“å–å¡ç‰Œ");
        } else {
            // æ‹–æ‹½ä¸­
            // å°†å¡ç‰Œç§»åŠ¨åˆ°å°„çº¿è·ç¦»æ‘„åƒæœºä¸€å®šè·ç¦»çš„ä½ç½®
            const dist = 3.5; // æ‚¬æµ®åœ¨é•œå¤´å‰
            const targetPos = raycaster.ray.origin.clone().add(raycaster.ray.direction.clone().multiplyScalar(dist));
            
            // çº¿æ€§æ’å€¼å¹³æ»‘ç§»åŠ¨
            currentCardMesh.position.lerp(targetPos, 0.2);
            
            // ç¨å¾®æ ¹æ®ç§»åŠ¨å€¾æ–œ
            currentCardMesh.rotation.x = (targetPos.y - currentCardMesh.position.y) * 0.5;
            currentCardMesh.rotation.z = -(targetPos.x - currentCardMesh.position.x) * 0.5;
            // ä¿æŒæ­£é¢/èƒŒé¢
            // è¿™é‡Œæˆ‘ä»¬å¸Œæœ›æŠ“å–æ—¶ç¿»å¼€çœ‹ä¸€çœ¼ï¼Ÿæˆ–è€…ç¡®è®¤åæ‰ç¿»å¼€ï¼Ÿ
            // è®¾å®šï¼šæŠ“å–æ—¶çœ‹åˆ°ç‰ŒèƒŒï¼Œç¡®è®¤(FIST)åç¿»å¼€å¹¶é”€æ¯
            
            updateUI("ç¡®è®¤å‘½è¿?", "ä¿æŒæŠ“å–å¹¶ã€æ¡æ‹³ã€‘(æˆ–ç©ºæ ¼) ç¡®è®¤");

            if (isFisting) {
                confirmDraw();
            }
        }
    }
}

// ç®€å•çš„è¡¥é—´åŠ¨ç”»è¾…åŠ©
function TWEEN_Pos(obj, target, ms) {
    const start = obj.clone();
    const startTime = Date.now();
    function loop() {
        const p = Math.min((Date.now() - startTime) / ms, 1);
        const e = 1 - Math.pow(1-p, 3);
        obj.lerpVectors(start, target, e);
        if (p < 1) requestAnimationFrame(loop);
    }
    loop();
}

// ----------------------
// ç¡®è®¤æŠ½å–é€»è¾‘
// ----------------------
function confirmDraw() {
    if (currentState === GameState.ANIMATING_OUT) return;
    currentState = GameState.ANIMATING_OUT;

    // 1. ç¿»ç‰ŒåŠ¨ç”»
    const targetRotZ = isReversed ? Math.PI : 0;
    
    // å¼ºåˆ¶ç¿»è½¬æ­£é¢æœæ‘„åƒæœº
    // Mesh ç»“æ„ï¼šæ­£é¢æ˜¯ index 4, èƒŒé¢æ˜¯ index 5. åˆå§‹ Y=PI (èƒŒå¯¹).
    // è¦çœ‹æ­£é¢ï¼ŒYåº”è¯¥å˜ä¸º 0. 
    // å¦‚æœé€†ä½ï¼ŒZ å˜ä¸º PI.
    
    const startRot = currentCardMesh.rotation.clone();
    const startTime = Date.now();
    
    updateUI(currentCardData.name + (isReversed ? " (é€†ä½)" : ""), 
             isReversed ? currentCardData.rev : currentCardData.up);
    
    // ä»ç‰Œåº“ç§»é™¤
    deck = deck.filter(c => c.id !== currentCardData.id);

    // è®°å½•å†å²
    addHistoryLog({
        name: currentCardData.name,
        url: currentCardData.url,
        reversed: isReversed,
        meaning: isReversed ? currentCardData.rev : currentCardData.up
    });

    function flipAndAsh() {
        const now = Date.now();
        const p = Math.min((now - startTime) / 600, 1); // 0.6ç§’ç¿»ç‰Œ
        
        // æ—‹è½¬
        currentCardMesh.rotation.y = THREE.MathUtils.lerp(startRot.y, 0, p);
        currentCardMesh.rotation.z = THREE.MathUtils.lerp(startRot.z, targetRotZ, p);
        currentCardMesh.rotation.x = THREE.MathUtils.lerp(startRot.x, 0, p); // ä¿®æ­£å€¾æ–œ
        
        if (p < 1) {
            requestAnimationFrame(flipAndAsh);
        } else {
            // ç¿»ç‰Œç»“æŸï¼Œè§¦å‘ç°çƒ¬
            setTimeout(() => {
                particles.push(new AshEffect(currentCardMesh));
                scene.remove(currentCardMesh);
                currentCardMesh = null;
                
                // è‡ªåŠ¨ä¸‹ä¸€å¼ 
                setTimeout(spawnCard, 2000);
            }, 500); // åœç•™0.5ç§’è§‚çœ‹
        }
    }
    flipAndAsh();
}

// ----------------------
// UI ä¸ è¾“å…¥å¤„ç†
// ----------------------
function updateUI(title, subtitle) {
    document.getElementById('card-name').innerText = title;
    document.getElementById('card-meaning').innerText = subtitle;
}

function addHistoryLog(item) {
    const list = document.getElementById('history-list');
    const div = document.createElement('div');
    div.className = 'history-item';
    
    if (item.isMsg) {
        div.innerText = item.name;
        div.style.justifyContent = "center";
        div.style.fontStyle = "italic";
    } else {
        const img = document.createElement('img');
        img.src = item.url;
        if (item.reversed) img.className = 'reversed';
        
        const text = document.createElement('span');
        text.innerHTML = `${item.name} ${item.reversed ? '<span class="rev-tag">(é€†)</span>' : ''}`;
        
        div.appendChild(img);
        div.appendChild(text);
    }
    
    list.insertBefore(div, list.firstChild);
}

// é¼ æ ‡äº‹ä»¶
window.addEventListener('mousemove', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
});
window.addEventListener('mousedown', () => { isMouseDown = true; });
window.addEventListener('mouseup', () => { isMouseDown = false; });
window.addEventListener('keydown', (e) => { if(e.code === 'Space') isSpaceDown = true; });
window.addEventListener('keyup', (e) => { if(e.code === 'Space') isSpaceDown = false; });

// æ¨¡å¼åˆ‡æ¢
const toggleBtn = document.getElementById('mode-toggle');
toggleBtn.addEventListener('click', () => {
    if (currentMode === InputMode.HAND) enableMouseMode();
    else enableHandMode(); // å°è¯•åˆ‡å›ï¼ˆå¦‚æœä¹‹å‰å¤±è´¥äº†å¯èƒ½ä¸è¡Œï¼Œä½†é€»è¾‘ä¸Šå…è®¸é‡è¯•ï¼‰
});

function enableMouseMode() {
    currentMode = InputMode.MOUSE;
    document.getElementById('mode-label').innerText = "é¼ æ ‡ Mouse";
    document.getElementById('gesture-hint').style.display = 'none';
    document.getElementById('mouse-hint').style.display = 'block';
    
    // åœæ­¢ MediaPipe (èŠ‚çœèµ„æº)
    if (cameraUtils) {
        // Note: CameraUtils doesn't have an easy stop method in the simple API, 
        // usually we just stop processing results.
        const video = document.getElementById('input_video');
        if(video.srcObject) {
            video.srcObject.getTracks().forEach(track => track.stop());
        }
    }
}

function enableHandMode() {
    location.reload(); // ç®€å•ç²—æš´é‡ç½®ä»¥é‡æ–°è¯·æ±‚æƒé™
}

// ----------------------
// MediaPipe åˆå§‹åŒ–
// ----------------------
function onResults(results) {
    document.getElementById('loader').style.display = 'none';
    
    if (currentMode !== InputMode.HAND) return;

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        // åªå–ç¬¬ä¸€åªæ‰‹
        handLandmarks = results.multiHandLandmarks[0];
    } else {
        handLandmarks = null;
    }
}

function initMediaPipe() {
    const videoElement = document.getElementById('input_video');
    
    hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    
    hands.onResults(onResults);
    
    cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            if (currentMode === InputMode.HAND) {
                await hands.send({image: videoElement});
            }
        },
        width: 640,
        height: 480
    });
    
    cameraUtils.start()
        .then(() => {
            console.log("Camera started");
            document.getElementById('mode-label').innerText = "æ‰‹åŠ¿ Hand (Webcam)";
        })
        .catch(err => {
            console.error("Camera failed", err);
            document.getElementById('loading-text').innerText = "æ‘„åƒå¤´å¤±è´¥ï¼Œåˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼...";
            setTimeout(() => {
                document.getElementById('loader').style.display = 'none';
                enableMouseMode();
            }, 1000);
        });
}

// ----------------------
// ä¸»å¾ªç¯
// ----------------------
function animate() {
    requestAnimationFrame(animate);
    
    updateGameLogic();
    
    renderer.render(scene, camera);
}

// ----------------------
// å¯åŠ¨
// ----------------------
initThree();
initMediaPipe();
spawnCard();
animate();

</script>
</body>
</html>
