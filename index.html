<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ritual Tarot - Dark Atmosphere</title>
    <style>
        /* 
           è§†è§‰ä¿®æ­£ï¼š
           èƒŒæ™¯ä¸å†æ˜¯çº¯é»‘ï¼Œè€Œæ˜¯ææ·±çš„ç°è‰²ï¼Œé…åˆ Fog è¥é€ ç©ºé—´æ„Ÿ 
        */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Georgia', serif; }
        canvas { display: block; }
        
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #555; font-size: 14px; letter-spacing: 3px; 
            text-transform: uppercase; pointer-events: none; transition: opacity 1s;
        }

        #guide {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #444; font-size: 12px; pointer-events: none; letter-spacing: 1px;
            font-weight: 300; opacity: 0.7;
        }
        
        /* è°ƒè¯•çª—å£éšè—ï¼Œä¿æŒæ²‰æµ¸ */
        #video-feed { display: none; }
    </style>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">Waiting for the Spirits...</div>
    <div id="guide">ğŸ– æ—‹è½¬ | â˜ï¸ å‡è§† | ğŸ‘Œ æŠ½å– | âœŠ é‡Šæ”¾ | ğŸ– æ”¾å›</div>
    <video id="video-feed" playsinline></video>

<script>
/**
 * ============================================================================
 * 0. å…¨å±€é…ç½® (ä¸¥æ ¼è°ƒè‰²ä¸æ‰‹æ„Ÿ)
 * ============================================================================
 */
const CONFIG = {
    // è§†è§‰ - ä½å¯¹æ¯”åº¦ï¼Œç°æš—é£æ ¼
    bgColor: 0x0a0a0a,    // æ·±ç°ï¼Œéçº¯é»‘
    fogColor: 0x0a0a0a,
    fogDensity: 0.08,     // è¾ƒæµ“çš„é›¾ï¼Œå¢åŠ æ·±åº¦
    
    // å…‰ç…§ - å…‹åˆ¶
    ambientIntensity: 0.4, // åŸºç¡€å¯è§åº¦
    pointIntensity: 0.8,   // ä¸­å¿ƒçƒ›å…‰
    lightColor: 0xffeebb,  // æš–é»„çƒ›å…‰
    
    // æè´¨
    roughness: 0.8,       // ç²—ç³™ï¼Œä¸åå…‰
    metalness: 0.1,       // æä½é‡‘å±æ„Ÿ
    
    // äº¤äº’æ‰‹æ„Ÿ
    rotationSpeed: 0.003, // åŸºç¡€æƒ¯æ€§
    friction: 0.96,       // è‡ªç„¶å‡é€Ÿ
    brakeFriction: 0.85,  // æŒ‡å‘æ—¶çš„å¼ºåŠ›åˆ¹è½¦
    pinchThreshold: 0.05, 
    pinchDelay: 150,      // ms, æåˆé˜²è¯¯è§¦æ—¶é—´
    
    // å¸ƒå±€
    radius: 7.0,
    cardCount: 22
};

// ä¸¥æ ¼äº’æ–¥çš„çŠ¶æ€æœº
const STATE = {
    // æ¨¡å¼: ORBIT(åœ†ç¯), DRAWING(åŠ¨ç”»ä¸­), VIEWING(å±•ç¤ºä¸­), RETURNING(æ”¾å›ä¸­), DISSOLVING(æ¶ˆæ•£)
    mode: 'ORBIT', 
    
    // ç‰©ç†é‡
    rotVelocity: 0.001,   // æ—‹è½¬é€Ÿåº¦
    targetRotVel: 0,      // ç›®æ ‡é€Ÿåº¦ï¼ˆç”¨äºå¹³æ»‘ï¼‰
    
    // æ‰‹åŠ¿æ•°æ®
    handPresent: false,
    gesture: 'NONE',      // OPEN, POINT, PINCH, FIST
    handX: 0, handY: 0,   // å¹³æ»‘ååæ ‡
    rawX: 0, rawY: 0,
    
    // äº¤äº’å¯¹è±¡
    hoverCard: null,      // å½“å‰æŒ‡å‘çš„ç‰Œ
    activeCard: null,     // å½“å‰æŠ½å‡ºçš„ç‰Œ
    pinchStartTime: 0,    // æåˆå¼€å§‹æ—¶é—´æˆ³
    
    // ç‰Œç»„å¼•ç”¨
    cards: []
};

// ============================================================================
// 1. æè´¨ç³»ç»Ÿ (å»é«˜å…‰ï¼Œå»é²œè‰³)
// ============================================================================

// å¡èƒŒï¼šæš—æ·¡ã€é™ˆæ—§ã€ç¥ç§˜
function createBackTexture() {
    const cvs = document.createElement('canvas');
    cvs.width = 512; cvs.height = 800;
    const ctx = cvs.getContext('2d');
    
    // èƒŒæ™¯ï¼šæš—å²©çŸ³ç°
    ctx.fillStyle = '#1a1816'; 
    ctx.fillRect(0,0,512,800);
    
    // çº¹ç†å™ªç‚¹
    for(let i=0; i<10000; i++) {
        ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.3})`;
        ctx.fillRect(Math.random()*512, Math.random()*800, 2, 2);
    }
    
    // å‡ ä½•å›¾æ¡ˆï¼šæš—é‡‘ (ä¸äº®)
    ctx.strokeStyle = '#6e6046'; // æ¯è‰è‰²ï¼Œéäº®é‡‘
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(256, 400, 120, 0, Math.PI*2);
    ctx.stroke();
    
    ctx.lineWidth = 10;
    ctx.strokeRect(30,30,452,740);

    return new THREE.CanvasTexture(cvs);
}

// å¡é¢ï¼šç¾Šçš®çº¸ã€è¤ªè‰²å¢¨æ°´
function createFrontTexture(idx) {
    const cvs = document.createElement('canvas');
    cvs.width = 512; cvs.height = 800;
    const ctx = cvs.getContext('2d');
    
    // çº¸å¼ ï¼šç°ç±³è‰²ï¼Œåšæ—§
    ctx.fillStyle = '#d0c8b6'; 
    ctx.fillRect(0,0,512,800);
    
    // è¾¹ç¼˜æš—è§’ (Vignette)
    const g = ctx.createRadialGradient(256,400,200,256,400,600);
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(30,25,20,0.6)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,512,800);

    // å†…å®¹ (ç®€å•çš„å¢¨è¿¹)
    ctx.fillStyle = '#222';
    ctx.textAlign = 'center';
    ctx.font = '30px Georgia';
    // ä»…æ˜¾ç¤ºç½—é©¬æ•°å­—ï¼Œå¢åŠ ç¥ç§˜æ„Ÿ
    const romans = ["0", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "XVII", "XVIII", "XIX", "XX", "XXI"];
    ctx.fillText(romans[idx], 256, 700);
    
    // ä¸­å¤®æŠ½è±¡ç¬¦å·
    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.arc(256, 350, 80 + (idx%5)*10, 0, Math.PI*2);
    ctx.moveTo(256, 200); ctx.lineTo(256, 500);
    ctx.stroke();

    return new THREE.CanvasTexture(cvs);
}

function createParticleTexture() {
    const cvs = document.createElement('canvas');
    cvs.width = 32; cvs.height = 32;
    const ctx = cvs.getContext('2d');
    const g = ctx.createRadialGradient(16,16,0,16,16,16);
    g.addColorStop(0, 'rgba(200, 180, 140, 0.8)'); // å°˜åŸƒè‰²
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,32,32);
    return new THREE.CanvasTexture(cvs);
}

// ============================================================================
// 2. åœºæ™¯æ­å»º
// ============================================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(CONFIG.bgColor);
scene.fog = new THREE.FogExp2(CONFIG.fogColor, CONFIG.fogDensity);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 0.1); // ä½äºåœ†å¿ƒï¼Œè½»å¾®åç§»

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
// å…³é”®ï¼šä½¿ç”¨ ACESFilmic æ˜ å°„ï¼Œé˜²æ­¢çˆ†å…‰
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);

// ç¯å…‰
const ambient = new THREE.AmbientLight(0xffffff, CONFIG.ambientIntensity);
scene.add(ambient);

const pointLight = new THREE.PointLight(CONFIG.lightColor, CONFIG.pointIntensity, 20);
pointLight.position.set(0, 1, 0);
scene.add(pointLight);

// ç‰Œç»„å®¹å™¨
const ringGroup = new THREE.Group();
ringGroup.position.set(0, -1.5, 0); // ä¸‹æ²‰ï¼Œæ¨¡æ‹Ÿå¹³è§†/ä¿¯è§†
scene.add(ringGroup);

// åˆ›å»ºå¡ç‰Œ
const cardGeo = new THREE.BoxGeometry(1.4, 2.4, 0.04);
const backMat = new THREE.MeshStandardMaterial({ 
    map: createBackTexture(), 
    roughness: CONFIG.roughness, 
    metalness: CONFIG.metalness 
});
const sideMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 1 });

for(let i=0; i<CONFIG.cardCount; i++) {
    const frontMat = new THREE.MeshStandardMaterial({ 
        map: createFrontTexture(i), 
        roughness: CONFIG.roughness,
        metalness: CONFIG.metalness
    });
    
    // æè´¨é¡ºåº: R, L, T, B, Front(Z+), Back(Z-)
    // æˆ‘ä»¬çš„é€»è¾‘ï¼šZ+æ˜¯èƒŒé¢(æœåœ†å¿ƒ)ï¼ŒZ-æ˜¯æ­£é¢(æœå¤–)
    const mats = [sideMat, sideMat, sideMat, sideMat, backMat, frontMat];
    const card = new THREE.Mesh(cardGeo, mats);
    
    // å¸ƒå±€è®¡ç®—
    const angle = (i / CONFIG.cardCount) * Math.PI * 2;
    card.position.x = Math.sin(angle) * CONFIG.radius;
    card.position.z = Math.cos(angle) * CONFIG.radius;
    
    // ä¿®æ­£ï¼šå¼ºåˆ¶å§¿æ€
    // å…ˆ LookAt åœ†å¿ƒ (0, -1.5, 0)
    // è¿™æ · Z+ è½´æŒ‡å‘åœ†å¿ƒ
    card.lookAt(0, -1.5, 0);
    // ä¿®æ­£ï¼šLookAt åå¯èƒ½å‚ç›´ï¼Œæˆ‘ä»¬éœ€è¦å®ƒç¨å¾®å‘åä»°ä¸€ç‚¹ç‚¹ï¼Œæˆ–è€…å®Œå…¨å‚ç›´
    // å½“å‰ lookAt åœ†å¿ƒæœ¬èº«å°±ä¼šå¸¦ä¸€ç‚¹å€¾è§’ï¼Œå› ä¸º y=-1.5ã€‚è¿™å¾ˆå¥½ã€‚
    
    card.userData = { 
        id: i, 
        basePos: card.position.clone(),
        baseRot: card.rotation.clone(),
        angle: angle
    };
    
    ringGroup.add(card);
    STATE.cards.push(card);
}

// ç²’å­ç³»ç»Ÿ (Object Pooling)
const pCount = 1500;
const pGeo = new THREE.BufferGeometry();
const pPos = new Float32Array(pCount*3);
const pLife = new Float32Array(pCount);
const pVel = new Float32Array(pCount*3);
pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
pGeo.setAttribute('alpha', new THREE.BufferAttribute(pLife, 1));
const pMat = new THREE.PointsMaterial({
    map: createParticleTexture(),
    color: 0xccaa88,
    size: 0.15,
    transparent: true,
    opacity: 0,
    depthWrite: false,
    blending: THREE.AdditiveBlending
});
const particles = new THREE.Points(pGeo, pMat);
scene.add(particles);

// Post Processing (æä½ Bloom)
const composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));
const bloom = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.4, 0.5, 0.9);
bloom.threshold = 0.8; // åªæœ‰æäº®çš„åœ°æ–¹æ‰ bloom
composer.addPass(bloom);

// æŒ‡ç¤ºå…‰æ ‡ (Debug UI, æç®€)
const cursor = new THREE.Mesh(
    new THREE.RingGeometry(0.02, 0.03, 16),
    new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.3, depthTest: false })
);
scene.add(cursor);

// ============================================================================
// 3. é€»è¾‘æ§åˆ¶ (æ ¸å¿ƒä¿®æ­£åŒº)
// ============================================================================

const raycaster = new THREE.Raycaster();

function updateLogic() {
    // 0. æ‰‹éƒ¨å¹³æ»‘
    STATE.handX += (STATE.rawX - STATE.handX) * 0.2;
    STATE.handY += (STATE.rawY - STATE.handY) * 0.2;
    
    // æ›´æ–°å…‰æ ‡
    const vec = new THREE.Vector3(STATE.handX, STATE.handY, 0.5);
    vec.unproject(camera);
    const dir = vec.sub(camera.position).normalize();
    cursor.position.copy(camera.position).add(dir.multiplyScalar(3));
    cursor.lookAt(camera.position);

    // çŠ¶æ€åˆ†æµ
    if (STATE.mode === 'ORBIT') {
        handleOrbit();
    } else if (STATE.mode === 'VIEWING') {
        handleViewing();
    }
    
    // ç²’å­æ›´æ–°
    updateParticles();
}

function handleOrbit() {
    // A. æ—‹è½¬é€»è¾‘ï¼šä»…é™ OPEN æ‰‹åŠ¿
    if (STATE.handPresent && STATE.gesture === 'OPEN') {
        // æ˜ å°„ X è½´ç§»åŠ¨åˆ°æ—‹è½¬åŠ›
        if (Math.abs(STATE.handX) > 0.1) {
            STATE.rotVelocity -= STATE.handX * 0.0005;
        }
    }
    
    // B. æŒ‡å‘é€»è¾‘ï¼šåˆ¹è½¦ & HOVER
    let isHovering = false;
    
    if (STATE.handPresent && STATE.gesture === 'POINT') {
        // å¼ºåˆ¶åˆ¹è½¦
        STATE.rotVelocity *= STATE.brakeFriction;
        
        // å°„çº¿æ£€æµ‹
        raycaster.setFromCamera({x: STATE.handX, y: STATE.handY}, camera);
        const intersects = raycaster.intersectObjects(STATE.cards);
        
        if (intersects.length > 0) {
            isHovering = true;
            const target = intersects[0].object;
            
            if (STATE.hoverCard !== target) {
                STATE.hoverCard = target;
                STATE.pinchStartTime = 0; // é‡ç½®æåˆè®¡æ—¶
            }
        } else {
            STATE.hoverCard = null;
        }
    } else {
        // éæŒ‡å‘çŠ¶æ€ï¼Œä¸äº§ç”Ÿ Hover
        STATE.hoverCard = null;
    }

    // C. ç‰©ç†æ›´æ–°
    ringGroup.rotation.y += STATE.rotVelocity;
    STATE.rotVelocity *= STATE.friction;
    
    // D. æåˆè§¦å‘ (ä»…åœ¨ HOVER çŠ¶æ€)
    if (isHovering && STATE.gesture === 'PINCH' && STATE.hoverCard) {
        if (STATE.pinchStartTime === 0) STATE.pinchStartTime = performance.now();
        
        const duration = performance.now() - STATE.pinchStartTime;
        if (duration > CONFIG.pinchDelay) {
            drawCard(STATE.hoverCard);
        }
    } else {
        STATE.pinchStartTime = 0;
    }
    
    // E. è§†è§‰æ›´æ–° (éå†æ‰€æœ‰å¡ç‰Œ)
    STATE.cards.forEach(card => {
        if (card === STATE.hoverCard) {
            // æ‚¬åœï¼šå¾®äº®ï¼Œä¸å‘å…‰
            card.material[4].emissive.setHex(0x332211); 
            // å¾®åŠ¨
            card.position.y = THREE.MathUtils.lerp(card.position.y, 0.2, 0.1);
        } else {
            card.material[4].emissive.setHex(0x000000);
            card.position.y = THREE.MathUtils.lerp(card.position.y, 0, 0.1);
        }
    });
}

function handleViewing() {
    // åœ¨å±•ç¤ºçŠ¶æ€ä¸‹
    if (!STATE.activeCard) return;

    // æ¡æ‹³ -> æ¶ˆæ•£ (Destruction)
    if (STATE.handPresent && STATE.gesture === 'FIST') {
        disperseCard();
        return;
    }
    
    // å¼ å¼€æ‰‹æŒ -> æ”¾å› (Regret / Return)
    if (STATE.handPresent && STATE.gesture === 'OPEN') {
        returnCard();
        return;
    }
    
    // æ‚¬æµ®å‘¼å¸
    STATE.activeCard.position.y += Math.sin(performance.now() * 0.002) * 0.001;
    STATE.activeCard.rotation.z = Math.sin(performance.now() * 0.001) * 0.03;
}

// ============================================================================
// 4. åŠ¨ç”»ç³»ç»Ÿ (GSAP) - ä¸æ»‘è¿æ¥
// ============================================================================

function drawCard(card) {
    if (STATE.mode !== 'ORBIT') return;
    STATE.mode = 'DRAWING'; // é”å®š
    STATE.activeCard = card;
    STATE.hoverCard = null;

    // 1. åæ ‡ç³»è½¬æ¢ (Scene Space)
    const worldPos = new THREE.Vector3();
    const worldQuat = new THREE.Quaternion();
    card.getWorldPosition(worldPos);
    card.getWorldQuaternion(worldQuat);
    scene.attach(card); // ä¿æŒä¸–ç•Œå˜æ¢
    
    // 2. åŠ¨ç”»åºåˆ—
    const tl = gsap.timeline({
        onComplete: () => { STATE.mode = 'VIEWING'; }
    });

    // ç›®æ ‡ä½ç½®ï¼šç›¸æœºæ­£å‰
    const targetPos = new THREE.Vector3(0, 0, -3);
    targetPos.applyQuaternion(camera.quaternion);
    targetPos.add(camera.position);

    // é£æ¥
    tl.to(card.position, {
        x: targetPos.x, y: targetPos.y, z: targetPos.z,
        duration: 1.5, ease: "power2.inOut"
    }, 0);

    // ç¿»è½¬ï¼šè®© Z- (æ­£é¢) æœå‘ç›¸æœº
    // ç®€å•è§£æ³•ï¼šè®© card lookAt cameraï¼Œç„¶åæ ¹æ®æè´¨æ–¹å‘å¾®è°ƒ
    // æ‰‹åŠ¨è®¡ç®—ï¼šç¿»è½¬180åº¦
    const targetRot = new THREE.Euler(0, Math.PI, 0); // å‡è®¾åˆå§‹æ˜¯èƒŒå‘ç›¸æœº
    // å®é™…ä¸Šæˆ‘ä»¬éœ€è¦æ ¹æ®å½“å‰çŠ¶æ€ç®—ã€‚
    // æœ€ç¨³å¦¥ï¼šLookAt Camera, then rotate Y 180 (because our front material is on Z-)
    // æˆ–è€… rotate Y 0 (if front is Z+). æˆ‘ä»¬ Front æ˜¯ Z- (index 5)
    // åˆå§‹ LookAt(0,-1.5,0) -> Z+ æŒ‡å‘ä¸­å¿ƒã€‚
    // ç¿»è½¬åï¼Œæˆ‘ä»¬å¸Œæœ› Z- æŒ‡å‘ç›¸æœºã€‚
    // ä¹Ÿå°±æ˜¯ Z+ èƒŒå¯¹ç›¸æœºã€‚
    // LookAt Camera ä¼šè®© Z+ æŒ‡å‘ Cameraã€‚æ‰€ä»¥å†è½¬ 180 åº¦ã€‚
    
    // ä½¿ç”¨ä¸­é—´å¯¹è±¡è¾…åŠ©è®¡ç®—å››å…ƒæ•°ä¼šæ›´å‡†ï¼Œè¿™é‡Œæ‰‹åŠ¨æ¨¡æ‹Ÿè§†è§‰æ•ˆæœ
    tl.to(card.rotation, {
        x: 0, 
        y: card.rotation.y + Math.PI, // ç¿»è½¬ 180
        z: 0,
        duration: 1.5, ease: "power2.inOut"
    }, 0);
}

function returnCard() {
    if (STATE.mode !== 'VIEWING') return;
    STATE.mode = 'RETURNING';
    
    const card = STATE.activeCard;
    const tl = gsap.timeline({
        onComplete: () => {
            ringGroup.attach(card); // æ”¾å›ç»„
            card.position.copy(card.userData.basePos);
            card.rotation.copy(card.userData.baseRot);
            card.scale.set(1,1,1);
            STATE.activeCard = null;
            STATE.mode = 'ORBIT';
        }
    });
    
    // åŸè·¯è¿”å›ï¼šè½¬æ¢åˆ°ä¸–ç•Œåæ ‡çš„ç›®æ ‡
    // ç”±äº ringGroup åœ¨è½¬ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—æ­¤æ—¶æ­¤åˆ»è¯¥å¡æ§½çš„ä¸–ç•Œä½ç½®
    // è¿™æ¯”è¾ƒå¤æ‚ï¼Œä¸ºç®€åŒ–è§†è§‰ï¼šå…ˆé£å›å¤§è‡´ä½ç½®ï¼Œè´´åˆæ—¶ç¬é—´ attach
    // æˆ–è€…ï¼šç›´æ¥åå‘æ’­æ”¾åŠ¨ç”»ï¼Ÿä¸ï¼Œåœ†ç¯å¯èƒ½è½¬äº†ã€‚
    // ç®€å•æ–¹æ¡ˆï¼šå¡ç‰Œé£å‘ RingGroup çš„å½“å‰æ—‹è½¬ä¸‹è¯¥å¡åº”è¯¥åœ¨çš„ä½ç½®
    
    // è®¡ç®—ç›®æ ‡ä¸–ç•Œåæ ‡
    const dummy = new THREE.Object3D();
    dummy.position.copy(card.userData.basePos);
    dummy.rotation.copy(card.userData.baseRot);
    
    // è·å– RingGroup å½“å‰å˜æ¢çŸ©é˜µ
    ringGroup.updateMatrixWorld();
    
    // å°† dummy å˜æ¢åˆ°ä¸–ç•Œç©ºé—´
    dummy.applyMatrix4(ringGroup.matrixWorld);
    
    tl.to(card.position, {
        x: dummy.position.x, y: dummy.position.y, z: dummy.position.z,
        duration: 1.2, ease: "power2.inOut"
    }, 0);
    
    // ç¿»è½¬å›èƒŒé¢
    // ç›®æ ‡å››å…ƒæ•°
    const targetQuat = dummy.quaternion;
    
    // GSAP ä¸ç›´æ¥æ”¯æŒ Quat æ’å€¼ï¼Œæˆ‘ä»¬ç”¨ Euler è¿‘ä¼¼æˆ– onUpdate
    // ç®€å•å¤„ç†ï¼šæ²¿ç”¨ Draw çš„åå‘é€»è¾‘
    tl.to(card.rotation, {
        x: dummy.rotation.x,
        y: dummy.rotation.y, // æ³¨æ„æ—‹è½¬åœˆæ•°é—®é¢˜ï¼Œè¿™é‡Œå¯èƒ½éœ€è¦å¤„ç†æœ€çŸ­è·¯å¾„
        z: dummy.rotation.z,
        duration: 1.2, ease: "power2.inOut"
    }, 0);
}

function disperseCard() {
    if (STATE.mode !== 'VIEWING') return;
    STATE.mode = 'DISSOLVING';
    
    const card = STATE.activeCard;
    const center = card.position.clone();
    
    // æ¿€æ´»ç²’å­
    const pos = pGeo.attributes.position.array;
    const vel = pVel;
    const life = pGeo.attributes.alpha.array;
    
    for(let i=0; i<pCount; i++) {
        // è¡¨é¢éšæœº
        pos[i*3] = center.x + (Math.random()-0.5)*1.4;
        pos[i*3+1] = center.y + (Math.random()-0.5)*2.4;
        pos[i*3+2] = center.z + (Math.random()-0.5)*0.1;
        
        // ç¼“æ…¢å‘å¤–æ¼‚æµ®
        vel[i*3] = (Math.random()-0.5) * 0.02;
        vel[i*3+1] = (Math.random()-0.5) * 0.02;
        vel[i*3+2] = Math.random() * 0.02; 
        
        life[i] = 1.0;
    }
    
    pGeo.attributes.position.needsUpdate = true;
    pGeo.attributes.alpha.needsUpdate = true;
    pMat.opacity = 0.8;
    
    // éšè—å¡ç‰Œ
    card.visible = false;
    
    // 2ç§’åé‡ç½®
    setTimeout(() => {
        // é€»è¾‘åˆ é™¤æˆ–é‡ç½®
        // è¿™é‡Œç®€å•å¤„ç†ï¼šé‡ç½®å›åœ†ç¯å¹¶å¯è§ï¼ˆæ¨¡æ‹Ÿæ–°çš„ä¸€è½®å‘½è¿ï¼‰
        ringGroup.attach(card);
        card.position.copy(card.userData.basePos);
        card.rotation.copy(card.userData.baseRot);
        card.visible = true;
        STATE.activeCard = null;
        STATE.mode = 'ORBIT';
    }, 2500);
}

function updateParticles() {
    if (pMat.opacity <= 0) return;
    
    const pos = pGeo.attributes.position.array;
    const vel = pVel;
    const life = pGeo.attributes.alpha.array;
    let active = false;
    
    for(let i=0; i<pCount; i++) {
        if (life[i] > 0) {
            pos[i*3] += vel[i*3];
            pos[i*3+1] += vel[i*3+1];
            pos[i*3+2] += vel[i*3+2];
            life[i] -= 0.01;
            active = true;
        }
    }
    
    if (active) {
        pGeo.attributes.position.needsUpdate = true;
        pGeo.attributes.alpha.needsUpdate = true;
    } else {
        pMat.opacity = 0;
    }
}

// ============================================================================
// 5. è¾“å…¥ç³»ç»Ÿ (MediaPipe)
// ============================================================================
const videoEl = document.getElementById('video-feed');
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

hands.onResults(res => {
    document.getElementById('loader').style.opacity = 0;
    
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        STATE.handPresent = true;
        cursor.visible = true;
        
        const lm = res.multiHandLandmarks[0];
        const tip = lm[8]; // Index tip
        const thumb = lm[4];
        
        // åæ ‡
        STATE.rawX = (1 - tip.x) * 2 - 1;
        STATE.rawY = (1 - tip.y) * 2 - 1;
        
        // æ‰‹åŠ¿è¯†åˆ«
        const pinchDist = Math.hypot(tip.x - thumb.x, tip.y - thumb.y);
        
        // ç®€å•å¯å‘å¼åˆ¤æ–­
        const isFist = (lm[8].y > lm[6].y && lm[12].y > lm[10].y && lm[16].y > lm[14].y);
        const isOpen = !isFist && pinchDist > 0.1;
        const isPoint = !isFist && !isOpen && (lm[8].y < lm[6].y) && (lm[12].y > lm[10].y);
        
        if (isFist) STATE.gesture = 'FIST';
        else if (pinchDist < CONFIG.pinchThreshold) STATE.gesture = 'PINCH';
        else if (isPoint) STATE.gesture = 'POINT';
        else STATE.gesture = 'OPEN';
        
    } else {
        STATE.handPresent = false;
        cursor.visible = false;
        STATE.gesture = 'NONE';
    }
});

const cam = new Camera(videoEl, { onFrame: async () => await hands.send({image: videoEl}), width: 640, height: 480 });
cam.start();

// Loop
function animate() {
    requestAnimationFrame(animate);
    updateLogic();
    composer.render();
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
