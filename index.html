<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js å¡”ç½—æ‰‹åŠ¿æŠ½å¡ (MediaPipe)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; color: white; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-feed { position: absolute; bottom: 20px; right: 20px; width: 200px; height: 150px; transform: scaleX(-1); border: 2px solid #444; z-index: 2; opacity: 0.8; display: none; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        /* Controls */
        #controls { position: absolute; top: 20px; right: 20px; pointer-events: auto; display: flex; gap: 10px; }
        button { background: rgba(0,0,0,0.6); color: #fff; border: 1px solid #fff; padding: 8px 16px; cursor: pointer; border-radius: 4px; transition: 0.3s; }
        button:hover { background: rgba(255,255,255,0.2); }
        button.active { background: #d4af37; color: #000; border-color: #d4af37; }

        /* Status & Hints */
        #status-bar { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        #gesture-hint { font-size: 1.2em; color: #d4af37; margin-bottom: 5px; font-weight: bold; }
        #action-hint { font-size: 0.9em; color: #aaa; }

        /* Result Display */
        #result-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; opacity: 0; transition: opacity 0.5s; pointer-events: none; }
        #card-name { font-size: 3em; color: #d4af37; margin: 0; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px rgba(212, 175, 55, 0.5); }
        #card-meaning { font-size: 1.2em; max-width: 600px; margin-top: 10px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; }

        /* History Panel */
        #history-panel { position: absolute; top: 80px; left: 20px; width: 250px; bottom: 20px; overflow-y: auto; pointer-events: auto; background: rgba(0,0,0,0.5); padding: 10px; border-left: 2px solid #d4af37; scrollbar-width: thin; }
        .history-item { margin-bottom: 15px; border-bottom: 1px solid #444; padding-bottom: 10px; animation: fadeIn 0.5s ease; }
        .history-item img { width: 40px; height: 60px; float: left; margin-right: 10px; border: 1px solid #666; }
        .h-title { color: #d4af37; font-size: 0.9em; font-weight: bold; }
        .h-desc { font-size: 0.8em; color: #ddd; line-height: 1.2; }
        .reversed-tag { color: #ff6b6b; font-size: 0.8em; margin-left: 5px; }

        /* Loader */
        #loader { position: absolute; top:0; left:0; width:100%; height:100%; background:#000; display:flex; justify-content:center; align-items:center; z-index: 100; transition: opacity 1s; }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader"><h2>æ­£åœ¨åŠ è½½èµ„æºä¸æ¨¡å‹...</h2></div>

    <video id="video-feed" playsinline></video>
    
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="controls">
            <button id="btn-mouse" onclick="setMode('mouse')">ğŸ–±ï¸ é¼ æ ‡æ¨¡å¼</button>
            <button id="btn-hand" onclick="setMode('hand')">ğŸ–ï¸ æ‰‹åŠ¿æ¨¡å¼</button>
        </div>

        <div id="status-bar">
            <div id="gesture-hint">ç­‰å¾…æŒ‡ä»¤...</div>
            <div id="action-hint">ğŸ– å¼ å¼€æ‰‹æŒå¼€å§‹ | ğŸ‘Œ æåˆæŠ“å– | âœŠ æ¡æ‹³ç¡®è®¤</div>
        </div>

        <div id="result-overlay">
            <h1 id="card-name"></h1>
            <div id="card-meaning"></div>
        </div>

        <div id="history-panel">
            <div style="text-align:center; color:#888; font-size:0.8em;">--- æŠ½å¡è®°å½• ---</div>
            <div id="history-list"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. é…ç½®ä¸æ•°æ® ---
        const ASSETS = {
            back: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/Tarot_Back_2.jpg/309px-Tarot_Back_2.jpg', // é€šç”¨ç‰ŒèƒŒ
            baseUrl: 'https://raw.githubusercontent.com/turtlemappin/tarot-deck/main/images/', // æŸå¼€æºRWSå›¾æº
            // ç”±äºç¯‡å¹…ï¼Œè¿™é‡Œæ¨¡æ‹Ÿç”Ÿæˆ78å¼ å¡çš„æ•°æ®ç»“æ„ï¼Œå®é™…é¡¹ç›®åº”å®Œæ•´åˆ—å‡º
            getDeck: () => generateTarotDeck()
        };

        const STATE = {
            mode: 'mouse', // 'mouse' or 'hand'
            gesture: 'NONE', // OPEN, PINCH, FIST, POINT
            isGrabbing: false,
            phase: 'IDLE', // IDLE, HOVER, GRABBED, REVEALED, DISSOLVING
            handPos: new THREE.Vector2(), // Normalized -1 to 1
            lastHandPos: new THREE.Vector2()
        };

        // --- 2. å¡”ç½—ç‰Œæ•°æ®ç”Ÿæˆå™¨ ---
        const majorArcana = [
            "The Fool", "The Magician", "The High Priestess", "The Empress", "The Emperor", 
            "The Hierophant", "The Lovers", "The Chariot", "Strength", "The Hermit", 
            "Wheel of Fortune", "Justice", "The Hanged Man", "Death", "Temperance", 
            "The Devil", "The Tower", "The Star", "The Moon", "The Sun", "Judgement", "The World"
        ];
        const suits = ['Wands', 'Cups', 'Swords', 'Pentacles'];
        const ranks = ['Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Page', 'Knight', 'Queen', 'King'];

        function generateTarotDeck() {
            let deck = [];
            let id = 0;
            // æ˜ å°„æ–‡ä»¶åé€»è¾‘ (æ ¹æ®é€‰å®šçš„GitHubæºè°ƒæ•´)
            // å‡è®¾æºæ–‡ä»¶å‘½åæ ¼å¼ç®€å•å¤„ç†ï¼Œå®é™…éœ€ç²¾ç¡®æ˜ å°„
            const formatName = (n) => n.toLowerCase().replace(/ /g, '-');
            
            majorArcana.forEach((name, i) => {
                deck.push({
                    id: id++, name: name, type: 'major',
                    url: `${ASSETS.baseUrl}major/${i < 10 ? '0'+i : i}.jpg`, // éœ€æ ¹æ®å®é™…æºä¿®æ­£ï¼Œè¿™é‡Œä½¿ç”¨å ä½é€»è¾‘
                    // ä¿®æ­£ï¼šç”±äºgithubæºæ–‡ä»¶åä¸ä¸€å®šè§„åˆ™ï¼Œè¿™é‡Œä¸ºæ¼”ç¤ºæ•ˆæœï¼Œè‹¥åŠ è½½å¤±è´¥æ˜¾ç¤ºfallbacké¢œè‰²
                    fallbackColor: 0x4a4a4a,
                    meaningUp: "æ–°çš„å¼€å§‹ï¼Œè‡ªç”±ï¼Œçº¯çœŸã€‚",
                    meaningRev: "é²è½ï¼Œå†’é™©ï¼Œå¹¼ç¨šã€‚"
                });
            });

            suits.forEach(suit => {
                ranks.forEach((rank, i) => {
                    deck.push({
                        id: id++, name: `${rank} of ${suit}`, type: 'minor',
                        url: `${ASSETS.baseUrl}${suit.toLowerCase()}/${i+1}.jpg`, // ä¼ªè·¯å¾„
                        fallbackColor: 0x2a2a2a,
                        meaningUp: `${suit}çš„æ­£ä½å«ä¹‰ï¼šèƒ½é‡æµåŠ¨ã€‚`,
                        meaningRev: `${suit}çš„é€†ä½å«ä¹‰ï¼šèƒ½é‡å—é˜»ã€‚`
                    });
                });
            });
            return deck;
        }

        // çœŸå®ç¯å¢ƒä¿®æ­£ï¼šä½¿ç”¨å ä½å›¾ç”Ÿæˆå™¨æˆ–ç¨³å®šçš„APIï¼Œé˜²æ­¢è·¨åŸŸå’Œ404
        // ä¸ºç¡®ä¿æ¼”ç¤ºæ•ˆæœï¼Œæˆ‘ä»¬ä½¿ç”¨ canvas åŠ¨æ€ç”Ÿæˆå¸¦æ–‡å­—çš„çº¹ç†ä½œä¸º fallback
        function createTexture(text, color = '#222') {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 400;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff'; ctx.fillRect(0,0,256,400); // è¾¹æ¡†
            ctx.fillStyle = color; ctx.fillRect(10,10,236,380);
            ctx.fillStyle = '#d4af37'; ctx.font = '20px Arial'; ctx.textAlign = 'center';
            ctx.fillText(text.split(' ').slice(0,2).join(' '), 128, 180);
            ctx.fillText(text.split(' ').slice(2).join(' '), 128, 210);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        let fullDeck = ASSETS.getDeck();
        let currentCardData = null;

        // --- 3. Three.js åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        // é›¾æ°”æ•ˆæœï¼Œå¢åŠ ç¥ç§˜æ„Ÿ
        scene.fog = new THREE.FogExp2(0x111111, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffd700, 1);
        dirLight.position.set(5, 5, 5);
        scene.add(dirLight);
        const pointLight = new THREE.PointLight(0x00ffff, 0.5);
        pointLight.position.set(-2, 0, 2);
        scene.add(pointLight);

        // ç²’å­ç³»ç»Ÿç»„ï¼ˆç”¨äºç®¡ç†æ‰€æœ‰çš„ç°çƒ¬ï¼‰
        const ashGroup = new THREE.Group();
        scene.add(ashGroup);

        // å¡ç‰Œå¯¹è±¡
        const CARD_GEO = new THREE.PlaneGeometry(2, 3.5, 32, 32); // ç»†åˆ†å¤šä¸€ç‚¹ç”¨äºå˜å½¢æˆ–ç²’å­é‡‡æ ·
        let cardMesh = null;
        let cardTargetPos = new THREE.Vector3(0, 0, 0);
        let cardTargetRot = new THREE.Euler(0, 0, 0);

        // å…‰æ ‡ (ç”¨äºè°ƒè¯•å’Œé¼ æ ‡æ¨¡å¼)
        const cursorGeo = new THREE.RingGeometry(0.05, 0.08, 32);
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5, depthTest: false });
        const cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
        cursorMesh.renderOrder = 999;
        scene.add(cursorMesh);

        // --- 4. æ ¸å¿ƒé€»è¾‘ ---

        function spawnCard() {
            if (fullDeck.length === 0) {
                alert("ç‰Œåº“å·²ç©ºï¼Œé‡æ–°æ´—ç‰Œï¼");
                fullDeck = ASSETS.getDeck();
            }

            // éšæœºæŠ½å–
            const index = Math.floor(Math.random() * fullDeck.length);
            currentCardData = fullDeck.splice(index, 1)[0];
            
            // éšæœºæ­£é€†ä½
            currentCardData.isReversed = Math.random() < 0.5;

            // çº¹ç†
            const texLoader = new THREE.TextureLoader();
            // ç‰ŒèƒŒ
            const backTex = texLoader.load(ASSETS.back);
            // ç‰Œé¢ (ç”±äºURLå¯èƒ½å¤±æ•ˆï¼Œä½¿ç”¨Fallbackç”Ÿæˆå™¨)
            const frontTex = createTexture(currentCardData.name, currentCardData.type==='major'?'#400':'#004'); 
            
            // å°è¯•åŠ è½½çœŸå®å›¾ç‰‡(å¯é€‰)
            // texLoader.load(currentCardData.url, (tex)=>{ mat.map = tex; mat.needsUpdate=true; });

            const matFront = new THREE.MeshStandardMaterial({ 
                map: frontTex, roughness: 0.4, metalness: 0.1 
            });
            const matBack = new THREE.MeshStandardMaterial({ 
                map: backTex, roughness: 0.6 
            });

            if (cardMesh) scene.remove(cardMesh);

            // åˆ›å»ºMeshï¼Œä½¿ç”¨æ­£åé¢æè´¨
            // Geometry Group 0: front, 1: back. PlaneGeometry default normal is +Z.
            // ä¸ºäº†æ­£åé¢é€»è¾‘ï¼Œæˆ‘ä»¬éœ€è¦ä¸¤ä¸ªMeshèƒŒé èƒŒæˆ–è€…Shaderã€‚ç®€å•èµ·è§ï¼Œç”¨GroupåŒ…ä¸¤ä¸ªPlaneã€‚
            
            const group = new THREE.Group();
            
            const frontMesh = new THREE.Mesh(CARD_GEO, matFront);
            frontMesh.position.z = 0.01;
            // å¦‚æœæ˜¯é€†ä½ï¼Œçº¹ç†æ€ä¹ˆå¤„ç†ï¼Ÿ
            // é€»è¾‘ï¼šå¡ç‰Œåˆšç”Ÿæˆæ˜¯ç›–ç€çš„ï¼ˆæ˜¾ç¤ºç‰ŒèƒŒï¼‰ã€‚
            // ç¿»å¼€æ—¶ï¼Œå¦‚æœReversedï¼Œæˆ‘ä»¬æ—‹è½¬Mesh Zè½´ 180åº¦ã€‚
            
            const backMesh = new THREE.Mesh(CARD_GEO, matBack);
            backMesh.rotation.y = Math.PI; // èƒŒé¢æœå¤–
            
            group.add(frontMesh);
            group.add(backMesh);

            cardMesh = group;
            
            // åˆå§‹ä½ç½®ï¼šå±å¹•ä¸‹æ–¹æˆ–éšæœºä½ç½®æ¼‚æµ®
            cardMesh.position.set(0, -5, -2); 
            cardMesh.rotation.set(0, Math.PI, 0); // åˆå§‹èƒŒé¢æœå‘ç›¸æœº
            
            scene.add(cardMesh);

            STATE.phase = 'IDLE';
            cardTargetPos.set(0, 0, 0);
            
            // UI Update
            document.getElementById('result-overlay').style.opacity = 0;
            updateHint("ç­‰å¾…æŠ½å–...");
        }

        function dissolveCard() {
            if (!cardMesh) return;
            
            // 1. ç”Ÿæˆç²’å­
            const count = 2000;
            const geo = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const life = []; // 0-1
            
            // é‡‡æ ·å¡ç‰Œä½ç½®
            // ç®€å•èµ·è§ï¼Œåœ¨ä¸€ä¸ªçŸ©å½¢èŒƒå›´å†…ç”Ÿæˆ
            const width = 2; 
            const height = 3.5;
            
            // è·å–å½“å‰å¡ç‰Œçš„ä¸–ç•Œåæ ‡å’Œæ—‹è½¬
            cardMesh.updateMatrixWorld();
            const center = cardMesh.position.clone();
            
            for(let i=0; i<count; i++) {
                // ç›¸å¯¹åæ ‡
                const rx = (Math.random() - 0.5) * width;
                const ry = (Math.random() - 0.5) * height;
                
                // åº”ç”¨æ—‹è½¬ (ç®€åŒ–å¤„ç†ï¼Œå‡è®¾é¢å‘ç›¸æœº)
                // è‹¥è¦ç²¾ç¡®ï¼Œéœ€åº”ç”¨å››å…ƒæ•°ã€‚
                let p = new THREE.Vector3(rx, ry, 0);
                p.applyEuler(cardMesh.rotation);
                p.add(center);
                
                positions.push(p.x, p.y, p.z);
                
                // é€Ÿåº¦: å‘ä¸Šæ¼‚æµ® + éšæœºæ¹æµ
                velocities.push(
                    (Math.random()-0.5)*0.05, // x
                    Math.random()*0.05 + 0.02, // y (up)
                    (Math.random()-0.5)*0.05  // z
                );
                
                life.push(1.0); // æ»¡è¡€
            }
            
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
            geo.setAttribute('life', new THREE.Float32BufferAttribute(life, 1));
            
            // é¢œè‰²å–é‡‘è‰²æˆ–ç°çƒ¬è‰²
            const mat = new THREE.PointsMaterial({
                color: 0xffd700,
                size: 0.05,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            
            const points = new THREE.Points(geo, mat);
            points.userData = { isAsh: true };
            ashGroup.add(points);
            
            // 2. ç§»é™¤åŸæ¨¡å‹
            scene.remove(cardMesh);
            cardMesh = null;
            
            // 3. UI è®°å½•ä¸å±•ç¤º
            logHistory();
            
            // 4. è‡ªåŠ¨é‡ç½®å»¶è¿Ÿ
            setTimeout(() => {
                spawnCard();
            }, 3000);
        }

        function updateAsh() {
            ashGroup.children.forEach((pts, index) => {
                const positions = pts.geometry.attributes.position.array;
                const vels = pts.geometry.attributes.velocity.array;
                const lifes = pts.geometry.attributes.life.array;
                let alive = false;
                
                for(let i=0; i<lifes.length; i++) {
                    if (lifes[i] > 0) {
                        lifes[i] -= 0.015; // è¡°å‡
                        
                        // Pos += Vel
                        positions[i*3] += vels[i*3];
                        positions[i*3+1] += vels[i*3+1];
                        positions[i*3+2] += vels[i*3+2];
                        
                        // æ¹æµå™ªå£°æ¨¡æ‹Ÿ
                        vels[i*3] += (Math.random()-0.5)*0.002;
                        
                        alive = true;
                    }
                }
                
                pts.geometry.attributes.position.needsUpdate = true;
                pts.geometry.attributes.life.needsUpdate = true;
                pts.material.opacity = Math.max(...lifes); // æ•´ä½“é€æ˜åº¦ç®€å•æ·¡å‡º
                
                if (!alive) {
                    ashGroup.remove(pts);
                    pts.geometry.dispose();
                    pts.material.dispose();
                }
            });
        }

        function logHistory() {
            const list = document.getElementById('history-list');
            const item = document.createElement('div');
            item.className = 'history-item';
            
            const meaning = currentCardData.isReversed ? currentCardData.meaningRev : currentCardData.meaningUp;
            const title = currentCardData.name + (currentCardData.isReversed ? " <span class='reversed-tag'>(é€†ä½)</span>" : "");
            
            // ç”Ÿæˆç¼©ç•¥å›¾ (è¿™é‡Œå¤ç”¨ç”Ÿæˆé€»è¾‘ï¼Œå®é™…åº”ç”¨img src)
            // ç®€å•ç”¨canvasç”Ÿæˆbase64
            const cvs = document.createElement('canvas'); cvs.width=40; cvs.height=60;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = currentCardData.isReversed ? '#500' : '#005'; ctx.fillRect(0,0,40,60);
            
            item.innerHTML = `
                <img src="${cvs.toDataURL()}">
                <div class="h-title">${title}</div>
                <div class="h-desc">${meaning}</div>
                <div style="clear:both"></div>
            `;
            list.prepend(item);
        }

        function showResultUI() {
            const overlay = document.getElementById('result-overlay');
            const nameEl = document.getElementById('card-name');
            const meanEl = document.getElementById('card-meaning');
            
            nameEl.innerHTML = currentCardData.name + (currentCardData.isReversed ? " <br><small>(é€†ä½)</small>" : "");
            meanEl.innerText = currentCardData.isReversed ? currentCardData.meaningRev : currentCardData.meaningUp;
            
            overlay.style.opacity = 1;
        }

        // --- 5. è¾“å…¥å¤„ç†ä¸çŠ¶æ€æœº ---

        const raycaster = new THREE.Raycaster();
        
        // é¼ æ ‡äº‹ä»¶
        window.addEventListener('mousemove', (e) => {
            if (STATE.mode !== 'mouse') return;
            STATE.handPos.x = (e.clientX / window.innerWidth) * 2 - 1;
            STATE.handPos.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });
        window.addEventListener('mousedown', () => {
            if (STATE.mode !== 'mouse') return;
            STATE.isGrabbing = true; // æ¨¡æ‹Ÿ Pinch
            STATE.gesture = 'PINCH';
        });
        window.addEventListener('mouseup', () => {
            if (STATE.mode !== 'mouse') return;
            STATE.isGrabbing = false;
            STATE.gesture = 'NONE';
        });
        // é¼ æ ‡ç‚¹å‡»ä½œä¸ºç¡®è®¤ï¼ˆæ¨¡æ‹ŸFistï¼‰
        window.addEventListener('dblclick', () => {
            if (STATE.mode !== 'mouse' || STATE.phase !== 'REVEALED') return;
            STATE.gesture = 'FIST'; // è§¦å‘ç¡®è®¤
            setTimeout(() => STATE.gesture = 'NONE', 500);
        });

        function updateLogic() {
            // å…‰æ ‡è·Ÿéš
            // å°† 2D å½’ä¸€åŒ–åæ ‡è½¬æ¢ä¸º 3D ä¸–ç•Œåæ ‡ (Z=0å¹³é¢)
            const vec = new THREE.Vector3(STATE.handPos.x, STATE.handPos.y, 0.5);
            vec.unproject(camera);
            const dir = vec.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z; // æ±‚ä¸Z=0å¹³é¢çš„äº¤ç‚¹
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // é™åˆ¶èŒƒå›´
            pos.x = Math.max(-5, Math.min(5, pos.x));
            pos.y = Math.max(-3, Math.min(3, pos.y));
            
            cursorMesh.position.copy(pos);
            cursorMat.color.setHex(STATE.gesture === 'PINCH' ? 0xff0000 : (STATE.gesture === 'FIST' ? 0x0000ff : 0x00ff00));

            if (!cardMesh) return;

            // å°„çº¿æ£€æµ‹
            raycaster.setFromCamera(STATE.handPos, camera);
            const intersects = raycaster.intersectObject(cardMesh, true);
            const isHovering = intersects.length > 0;

            // çŠ¶æ€æœº
            switch (STATE.phase) {
                case 'IDLE':
                    // é»˜è®¤å¡ç‰ŒèƒŒé¢æœä¸Šæ¼‚æµ®
                    cardTargetPos.set(0, 0, 0);
                    cardTargetRot.set(0, Math.PI, 0); // èƒŒé¢
                    
                    if ((STATE.gesture === 'OPEN' || isHovering) && STATE.mode === 'hand') {
                        // æ‰‹åŠ¿æ¨¡å¼ä¸‹ Open å¯ä»¥åœ¨ Idle æ—¶â€œå”¤é†’â€æˆ–å¾®è°ƒ
                    }
                    
                    if (STATE.gesture === 'PINCH' && isHovering) {
                        STATE.phase = 'GRABBED';
                    }
                    break;

                case 'GRABBED':
                    updateHint("æ‹–åŠ¨å¹¶æ¾å¼€ä»¥å±•ç¤º");
                    // å¡ç‰Œè·Ÿéšå…‰æ ‡
                    cardTargetPos.copy(pos);
                    // ç¨å¾®æ‹¿è¿‘ä¸€ç‚¹
                    cardTargetPos.z = 1; 
                    
                    // æƒ¯æ€§æ—‹è½¬æ•ˆæœ
                    cardTargetRot.z = (pos.x - cardMesh.position.x) * 2;
                    cardTargetRot.x = -(pos.y - cardMesh.position.y) * 2;
                    // ä¿æŒèƒŒé¢
                    cardTargetRot.y = Math.PI;

                    if (STATE.gesture !== 'PINCH' && !STATE.isGrabbing) {
                        // æ¾å¼€ -> è¿›å…¥å±•ç¤ºé˜¶æ®µ
                        STATE.phase = 'REVEALED';
                        revealCard();
                    }
                    break;

                case 'REVEALED':
                    updateHint("æ¡æ‹³ (Fist) ç¡®è®¤å¹¶åŒ–ç°");
                    // æ‚¬åœåœ¨å±å¹•ä¸­å¤®åå‰
                    cardTargetPos.set(0, 0, 3);
                    
                    // ç¿»è½¬é€»è¾‘ï¼šå¦‚æœæ˜¯æ­£ä½ï¼ŒYè½´è½¬å›0ï¼›å¦‚æœæ˜¯é€†ä½ï¼ŒZè½´180
                    // åˆå§‹æ˜¯ Y=PI (èƒŒé¢)ã€‚ç¿»å¼€å³ Y=0ã€‚
                    let targetY = 0;
                    let targetZ = 0;
                    if (currentCardData.isReversed) {
                         targetZ = Math.PI; // é€†ä½æ—‹è½¬
                    }
                    
                    cardTargetRot.set(0, targetY, targetZ);

                    if (STATE.gesture === 'FIST') {
                        STATE.phase = 'DISSOLVING';
                        dissolveCard();
                    }
                    break;
            }

            // å¹³æ»‘æ’å€¼æ›´æ–°å¡ç‰Œ Transform
            cardMesh.position.lerp(cardTargetPos, 0.1);
            // æ¬§æ‹‰è§’æ’å€¼æ¯”è¾ƒéº»çƒ¦ï¼Œç®€å•çš„åˆ†é‡lerp
            cardMesh.rotation.x += (cardTargetRot.x - cardMesh.rotation.x) * 0.1;
            cardMesh.rotation.y += (cardTargetRot.y - cardMesh.rotation.y) * 0.1;
            cardMesh.rotation.z += (cardTargetRot.z - cardMesh.rotation.z) * 0.1;
        }

        function revealCard() {
            showResultUI();
        }

        function updateHint(text) {
            document.getElementById('gesture-hint').innerText = text;
        }

        // --- 6. MediaPipe é›†æˆ ---
        const videoElement = document.getElementById('video-feed');
        
        window.setMode = (mode) => {
            STATE.mode = mode;
            document.getElementById('btn-mouse').classList.toggle('active', mode === 'mouse');
            document.getElementById('btn-hand').classList.toggle('active', mode === 'hand');
            
            if (mode === 'hand') {
                videoElement.style.display = 'block';
                startCamera();
            } else {
                videoElement.style.display = 'none';
            }
        };

        function onResults(results) {
            if (STATE.mode !== 'hand') return;
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. è·å–é£ŸæŒ‡æŒ‡å°– (8) åæ ‡ -> æ˜ å°„åˆ°å±å¹•
                // MediaPipe x: 0(left)-1(right), y: 0(top)-1(bottom)
                // Three.js NDC: -1 to 1.
                // æ³¨æ„é•œåƒ: videoæ˜¯ç¿»è½¬çš„ï¼Œæ‰€ä»¥ x = 1 - x
                const indexTip = landmarks[8];
                STATE.handPos.x = (1 - indexTip.x) * 2 - 1; 
                STATE.handPos.y = -indexTip.y * 2 + 1;

                // 2. æ‰‹åŠ¿è¯†åˆ«
                const thumbTip = landmarks[4];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                const wrist = landmarks[0];

                // Pinch: é£ŸæŒ‡ä¸æ‹‡æŒ‡è·ç¦»
                const pinchDist = distance(indexTip, thumbTip);
                
                // Fist: æ‰€æœ‰æŒ‡å°–é è¿‘æ‰‹æŒ/æ‰‹è…•
                // ç®€åŒ–åˆ¤æ–­ï¼šæŒ‡å°–yåæ ‡å¤§äºæŒ‡æ ¹(PIP)åæ ‡ (åœ¨å›¾åƒåæ ‡ç³»ä¸­yå‘ä¸‹å¢å¤§)
                // è¿™é‡Œç”¨ç®€å•çš„æŒ‡å°–åˆ°æ‰‹è…•è·ç¦»åˆ¤æ–­
                const fingersExtended = [8, 12, 16, 20].filter(idx => {
                    // å¦‚æœæŒ‡å°–è·ç¦»æ‰‹è…• æ˜¾è‘—å¤§äº PIPè·ç¦»æ‰‹è…•ï¼Œç®—ä¼¸å±•
                    // ç®€åŒ–ï¼šæŒ‡å°–y < PIPy (å¯¹äºæ‰‹æŒå‘ä¸Šçš„æƒ…å†µä¸é€‚ç”¨)
                    // é€šç”¨ç®—æ³•ï¼šè®¡ç®—å¼¯æ›²åº¦ã€‚
                    return isFingerExtended(landmarks, idx);
                }).length;

                if (pinchDist < 0.05) {
                    STATE.gesture = 'PINCH';
                } else if (fingersExtended === 0) {
                    STATE.gesture = 'FIST';
                } else if (fingersExtended >= 4) {
                    STATE.gesture = 'OPEN';
                } else {
                    STATE.gesture = 'POINT';
                }

                // Smooth pointer
                // (Already handled by logic frame update, input is raw here)
            } else {
                // No hand
            }
        }
        
        function isFingerExtended(landmarks, tipIdx) {
            // PIP joint is tipIdx - 2
            const tip = landmarks[tipIdx];
            const pip = landmarks[tipIdx - 2];
            const wrist = landmarks[0];
            // ç®€å•çš„è·ç¦»åˆ¤æ–­ï¼šTipç¦»Wristæ¯”PIPç¦»Wristè¿œ
            return distance(tip, wrist) > distance(pip, wrist) * 1.2;
        }

        function distance(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        // æ‘„åƒå¤´åˆå§‹åŒ–
        let cameraUtils = null;
        async function startCamera() {
            if (cameraUtils) return; // å·²ç»å¯åŠ¨
            
            try {
                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onResults);
                
                const cam = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                cam.start();
                cameraUtils = cam;
            } catch (e) {
                console.error("Camera failed", e);
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè‡ªåŠ¨é™çº§ä¸ºé¼ æ ‡æ¨¡å¼ã€‚è¯·æ£€æŸ¥HTTPSæˆ–æƒé™ã€‚");
                setMode('mouse');
            }
        }

        // --- 7. ä¸»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            
            updateLogic();
            updateAsh();
            
            renderer.render(scene, camera);
        }

        // åˆå§‹åŒ–
        spawnCard();
        animate();
        
        // é»˜è®¤é¼ æ ‡æ¨¡å¼
        setMode('mouse');
        document.getElementById('loader').style.opacity = 0;
        setTimeout(()=> document.getElementById('loader').remove(), 1000);

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
