<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Tarot - Swipe Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg-color: #000000;
            --tech-green: #00ff9d;
            --card-width: 200px; /* 卡牌变大一点，更有冲击力 */
            --card-height: 340px;
        }

        body {
            margin: 0;
            background: var(--bg-color);
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: none;
            perspective: 1000px; /* 3D 视距 */
        }

        /* 背景层 */
        #bg-canvas, #hand-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }
        #bg-canvas { z-index: 0; }
        #hand-canvas { z-index: 50; }

        /* 卡牌长廊容器 */
        #card-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0; height: 0; /* 容器本身不占位，全靠 absolute */
            transform-style: preserve-3d;
            z-index: 10;
        }

        /* 卡牌样式 */
        .card-wrapper {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            /* 居中定位 */
            left: calc(var(--card-width) * -0.5);
            top: calc(var(--card-height) * -0.5);
            transform-style: preserve-3d;
            /* 动画由 JS 每一帧驱动，这里不需要 transition */
            cursor: pointer;
        }

        .card-face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        /* 卡背 */
        .card-back {
            background: #080808;
            border: 2px solid #333;
            box-shadow: 0 0 15px rgba(255,255,255,0.05);
            display: flex; justify-content: center; align-items: center;
        }
        .card-back::after {
            content: ''; width: 50px; height: 80px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* 激活状态（位于中间时） */
        .card-wrapper.active .card-back {
            border-color: var(--tech-green);
            box-shadow: 0 0 50px rgba(0, 255, 157, 0.4);
        }

        .card-front {
            background: #111;
            transform: rotateY(180deg);
        }
        .card-front img { width: 100%; height: 100%; object-fit: cover; border-radius: 10px; }

        .flipped { transform: rotateY(180deg) !important; } /* JS 会覆盖 transform，这里用 class 标记状态 */

        /* 提示与光标 */
        #status-text {
            position: fixed; bottom: 10%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-size: 14px; letter-spacing: 2px;
            z-index: 100;
        }

        #cursor-ring {
            position: fixed; width: 30px; height: 30px;
            border: 2px solid var(--tech-green); border-radius: 50%;
            box-shadow: 0 0 15px var(--tech-green);
            transform: translate(-50%, -50%);
            z-index: 100; pointer-events: none;
            transition: width 0.1s, height 0.1s;
        }
        #cursor-ring.pinching { width: 10px; height: 10px; background: var(--tech-green); }
        
        #webcam { display: none; }
    </style>
</head>
<body>

    <div id="status-text">SYSTEM READY // SWIPE HAND TO SCROLL</div>
    <div id="cursor-ring"></div>
    <canvas id="bg-canvas"></canvas>
    <canvas id="hand-canvas"></canvas>
    
    <div id="card-container"></div>
    <video id="webcam" autoplay playsinline></video>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js";

        // 增加到 7 张牌，滑动效果更明显
        const cardsData = [
            { img: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg" },
            { img: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg" },
            { img: "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg" },
            { img: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg" },
            { img: "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg" },
            { img: "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Wands05.jpg/352px-Wands05.jpg" },
            { img: "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/RWS_Tarot_07_Chariot.jpg/353px-RWS_Tarot_07_Chariot.jpg" }
        ];

        /* --- 核心变量 --- */
        let handLandmarker;
        const video = document.getElementById("webcam");
        const cursor = document.getElementById("cursor-ring");
        const statusText = document.getElementById("status-text");
        const container = document.getElementById("card-container");
        
        // 画布
        const handCanvas = document.getElementById("hand-canvas");
        const handCtx = handCanvas.getContext("2d");
        const bgCanvas = document.getElementById("bg-canvas");
        const bgCtx = bgCanvas.getContext("2d");

        // --- 滑动系统核心变量 ---
        let targetScroll = 0; // 目标滚动位置 (0 ~ cards.length-1)
        let currentScroll = 0; // 当前实际滚动位置 (用于平滑插值)
        let maxScroll = cardsData.length - 1;
        let cardEls = [];

        // 骨骼
        const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];

        async function init() {
            // 1. 生成卡牌DOM
            cardsData.forEach((c, i) => {
                const el = document.createElement("div");
                el.className = "card-wrapper";
                // 标记翻转状态和索引
                el.dataset.index = i;
                el.dataset.flipped = "false";
                
                el.innerHTML = `
                    <div class="card-face card-back"></div>
                    <div class="card-face card-front"><img src="${c.img}"></div>
                `;
                container.appendChild(el);
                cardEls.push(el);
            });

            // 2. 初始化视觉模型
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            // 3. 启动摄像头
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    resizeCanvas();
                    requestAnimationFrame(renderLoop);
                    predictLoop();
                });
            } catch(e) { statusText.innerText = "CAMERA ERROR"; }
        }

        let lastVideoTime = -1;
        let pinchLocked = false;

        // --- 识别循环 ---
        async function predictLoop() {
            let now = performance.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, now);
                
                handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);

                if (results.landmarks && results.landmarks.length > 0) {
                    const lm = results.landmarks[0];
                    drawSkeleton(lm);

                    const indexTip = lm[8];
                    const thumbTip = lm[4];

                    // 1. 手势滑动映射 (核心逻辑)
                    // 将手在屏幕 X 轴的位置 (0~1) 映射到 卡牌索引 (0 ~ maxScroll)
                    // 1 - indexTip.x 是因为摄像头镜像是反的
                    let handX = (1 - indexTip.x); 
                    
                    // 增加一点边缘死区，让操作更舒适
                    // 手在最左边对应 scroll 0 (第一张牌)
                    // 手在最右边对应 scroll max (最后一张牌)
                    targetScroll = handX * maxScroll;

                    // 限制范围
                    targetScroll = Math.max(0, Math.min(maxScroll, targetScroll));

                    // 2. 更新光标位置
                    const cursorX = handX * window.innerWidth;
                    const cursorY = indexTip.y * window.innerHeight;
                    cursor.style.left = `${cursorX}px`;
                    cursor.style.top = `${cursorY}px`;

                    // 3. 捏合检测 (确认/翻牌)
                    const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    const isPinching = dist < 0.05;

                    if (isPinching) {
                        cursor.classList.add("pinching");
                        if (!pinchLocked) {
                            // 捏合时，翻开当前正中间的那张牌
                            // Math.round(currentScroll) 找到当前最接近中心的卡牌索引
                            triggerFlip(Math.round(currentScroll));
                            pinchLocked = true;
                        }
                    } else {
                        cursor.classList.remove("pinching");
                        pinchLocked = false;
                    }

                    statusText.innerText = isPinching ? "REVEALING FATE..." : "SWIPE TO BROWSE / PINCH TO REVEAL";

                } else {
                    // 没有手时，不自动回正，保持在原地或慢慢归零
                }
            }
            requestAnimationFrame(predictLoop);
        }

        // --- 渲染循环 (处理平滑动画) ---
        function renderLoop() {
            // 平滑插值：让 scroll 慢慢接近 target
            // 0.1 是平滑系数，数值越小越“肉”，越大越跟手
            currentScroll += (targetScroll - currentScroll) * 0.1;

            updateCards3D();
            updateBgParticles();
            requestAnimationFrame(renderLoop);
        }

        // --- 核心：3D 卡牌排列算法 ---
        function updateCards3D() {
            const spacing = 220; // 卡牌间距 px
            
            cardEls.forEach((card, i) => {
                // 计算每张卡牌相对于“当前滚动位置”的偏移量
                // 如果 currentScroll 是 2，那么第 2 张牌的 offset 就是 0 (在正中间)
                const offset = i - currentScroll; 
                
                // 1. 位移 (X轴)
                const translateX = offset * spacing;
                
                // 2. 缩放 (中间大，两边小)
                // Math.abs(offset) 越大，离中心越远
                const scale = Math.max(0.7, 1 - Math.abs(offset) * 0.15);
                
                // 3. 旋转 (Y轴 - Coverflow 效果)
                // 左边的牌向右转，右边的牌向左转
                let rotateY = 0;
                if (offset < -0.5) rotateY = 25; // 左侧
                else if (offset > 0.5) rotateY = -25; // 右侧
                
                // 4. Z轴 (景深)
                // 离中心越远，Z轴越靠后
                const translateZ = -Math.abs(offset) * 100;
                
                // 5. Z-Index (层级)
                // 离中心越近，层级越高，确保中间的压住两边的
                const zIndex = 100 - Math.round(Math.abs(offset) * 10);
                card.style.zIndex = zIndex;

                // 6. 翻转逻辑 (如果已翻开)
                const isFlipped = card.dataset.flipped === "true";
                const flipRotate = isFlipped ? 180 : 0;

                // 组合变换
                // 注意：rotateY 包含基础旋转 + 翻牌旋转
                card.style.transform = `
                    translateX(${translateX}px) 
                    translateZ(${translateZ}px) 
                    rotateY(${rotateY + flipRotate}deg) 
                    scale(${scale})
                `;

                // 视觉高亮
                if (Math.abs(offset) < 0.5) card.classList.add('active');
                else card.classList.remove('active');
            });
        }

        function triggerFlip(index) {
            // 边界检查
            if (index < 0 || index >= cardEls.length) return;
            
            const card = cardEls[index];
            if (card.dataset.flipped === "false") {
                card.dataset.flipped = "true";
                // 爆炸特效
                const rect = card.getBoundingClientRect();
                explode(rect.left + rect.width/2, rect.top + rect.height/2);
            }
        }

        // --- 辅助绘图与粒子 (保持不变) ---
        function drawSkeleton(landmarks) {
            handCtx.lineWidth = 2; handCtx.lineCap = "round";
            handCtx.strokeStyle = "rgba(255, 255, 255, 0.3)";
            
            connections.forEach(([i, j]) => {
                const p1 = landmarks[i], p2 = landmarks[j];
                handCtx.beginPath();
                handCtx.moveTo((1-p1.x)*handCanvas.width, p1.y*handCanvas.height);
                handCtx.lineTo((1-p2.x)*handCanvas.width, p2.y*handCanvas.height);
                handCtx.stroke();
            });

            landmarks.forEach((p, index) => {
                const x = (1-p.x)*handCanvas.width, y = p.y*handCanvas.height;
                handCtx.beginPath();
                if ([4,8,12,16,20].includes(index)) {
                    handCtx.fillStyle = "#00ff9d"; handCtx.arc(x, y, 4, 0, 2*Math.PI);
                } else {
                    handCtx.fillStyle = "rgba(255,255,255,0.6)"; handCtx.arc(x, y, 2, 0, 2*Math.PI);
                }
                handCtx.fill();
            });
        }

        let particles = [];
        function explode(x, y) {
            for(let i=0; i<60; i++) {
                const angle = Math.random()*Math.PI*2, v = Math.random()*15+5;
                particles.push({x, y, vx:Math.cos(angle)*v, vy:Math.sin(angle)*v, life:1, color:'#00ff9d'});
            }
        }
        function updateBgParticles() {
            bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);
            for(let i=particles.length-1; i>=0; i--) {
                let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vx*=0.9; p.vy*=0.9; p.life-=0.03;
                if(p.life<=0) particles.splice(i,1);
                else { bgCtx.globalAlpha=p.life; bgCtx.fillStyle=p.color; bgCtx.beginPath(); bgCtx.arc(p.x,p.y,2,0,Math.PI*2); bgCtx.fill(); }
            }
        }
        function resizeCanvas() { handCanvas.width = bgCanvas.width = window.innerWidth; handCanvas.height = bgCanvas.height = window.innerHeight; }
        window.onresize = resizeCanvas;

        init();
    </script>
</body>
</html>
