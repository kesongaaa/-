<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL Neon Racer: Curved Edition</title>
    <style>
        /* 页面基础样式 */
        body { margin: 0; overflow: hidden; background-color: #050011; font-family: 'Segoe UI', sans-serif; }
        
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* UI 层 */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* 顶部仪表盘 */
        .hud-top {
            padding: 20px;
            display: flex; justify-content: space-between; align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
        }

        .speed-box { text-align: right; color: #0ff; text-shadow: 0 0 15px #0ff; }
        .speed-value { font-size: 60px; font-weight: 800; font-family: 'Courier New', monospace; letter-spacing: -2px; }
        .speed-unit { font-size: 14px; color: #00f3ff; opacity: 0.8; }

        .status-box { color: #fff; font-size: 14px; background: rgba(0, 20, 40, 0.6); padding: 12px; border-radius: 4px; border-left: 3px solid #0ff; backdrop-filter: blur(4px); }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #444; margin-right: 8px; display: inline-block; vertical-align: middle; }
        .dot.active { background: #0f0; box-shadow: 0 0 8px #0f0; }

        /* 底部驾驶舱 UI */
        .cockpit {
            width: 100%; height: 25vh;
            background: linear-gradient(to top, #000 20%, transparent);
            position: relative;
            display: flex; justify-content: center; align-items: center;
        }
        .steering-wheel-indicator {
            width: 100px; height: 100px;
            border: 3px solid rgba(0, 243, 255, 0.3); border-radius: 50%;
            position: relative;
            transition: transform 0.1s;
        }
        .steering-bar {
            position: absolute; top: 50%; left: 10%; width: 80%; height: 2px; background: #0ff;
            box-shadow: 0 0 10px #0ff;
        }
        .curve-indicator {
            position: absolute; bottom: 80px; color: #d200ff; font-weight: bold; font-size: 20px; text-shadow: 0 0 5px #d200ff;
            opacity: 0; transition: opacity 0.3s;
        }

        /* 摄像头预览 */
        #webcam-preview {
            position: absolute; top: 20px; right: 20px;
            width: 160px; height: 120px;
            border: 1px solid #333; background: #000;
            transform: scaleX(-1);
            z-index: 10; opacity: 0.8;
            border-radius: 4px;
        }

        /* 加载界面 */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #0ff; transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #111; border-top: 4px solid #0ff;
            border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <!-- 库文件 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div style="font-size:14px; letter-spacing:1px;">SYSTEM BOOTING...</div>
    </div>

    <div id="canvas-container"></div>
    <video id="webcam-preview" playsinline muted></video>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="status-box">
                <div><span class="dot" id="cam-dot"></span> VISUAL SENSOR</div>
                <div style="margin-top:5px;"><span class="dot" id="hand-dot"></span> HAND TRACKING</div>
                <div style="font-size:12px; color:#888; margin-top:8px;">
                    Control: Tilt hand Left/Right
                </div>
            </div>
            <div class="speed-box">
                <div class="speed-value" id="speed-display">0</div>
                <div class="speed-unit">KM/H</div>
            </div>
        </div>
        <div class="cockpit">
            <div class="curve-indicator" id="curve-warning">>>> TURN >>></div>
            <div class="steering-wheel-indicator" id="steering-wheel">
                <div class="steering-bar"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // =========================================
        // 1. 全局配置
        // =========================================
        const CONFIG = {
            maxSpeed: 280,
            acceleration: 0.6,
            friction: 0.98,
            steerSens: 0.08,
            roadWidth: 50,
            colors: {
                sky: 0x050011,
                grid: 0x00f3ff,
                ground: 0x0a0a0a
            }
        };

        const STATE = {
            speed: 0,           // 0 - maxSpeed
            displaySpeed: 0,
            steering: 0,        // -1 (Left) to 1 (Right)
            targetSteering: 0,
            controlMode: 'keyboard', // 'keyboard' | 'hand'
            
            // 弯道系统状态
            distance: 0,        // 总行驶距离
            currentCurve: 0,    // 当前路段的曲率 (-1 左, 1 右, 0 直)
            playerOffset: 0     // 玩家在道路横向的位置
        };

        const UI = {
            loader: document.getElementById('loader'),
            speed: document.getElementById('speed-display'),
            wheel: document.getElementById('steering-wheel'),
            warning: document.getElementById('curve-warning'),
            camDot: document.getElementById('cam-dot'),
            handDot: document.getElementById('hand-dot'),
            video: document.getElementById('webcam-preview')
        };

        // =========================================
        // 2. Three.js 初始化
        // =========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.sky);
        scene.fog = new THREE.FogExp2(CONFIG.colors.sky, 0.006); // 稍微稀薄一点的雾，为了看清远处的弯道

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 0); // 这里的 position.x 将由 offset 控制

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 灯光
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        
        // =========================================
        // 3. 核心：弯曲道路 Shader
        // =========================================
        // 我们不使用普通贴图移动，而是使用 Shader 实时弯曲网格顶点
        
        const roadUniforms = {
            uTime: { value: 0 },
            uCurve: { value: 0 }, // 核心变量：控制弯曲程度
            uColor: { value: new THREE.Color(CONFIG.colors.grid) },
            uSpeedOffset: { value: 0 } // 纹理滚动
        };

        const roadVertexShader = `
            uniform float uCurve;
            uniform float uSpeedOffset;
            varying vec2 vUv;
            varying float vDepth;

            void main() {
                vUv = uv + vec2(0.0, -uSpeedOffset); // 纹理沿Y轴滚动
                
                vec3 pos = position;
                
                // --- 弯曲算法 ---
                // 计算当前顶点距离相机的深度 (在 PlaneGeometry 中，Z 轴向下延伸，但旋转后是 -Z)
                // 这里我们直接取 absolute z (假设路是平铺的)
                float dist = abs(pos.y); // 因为 Plane 是横着的，旋转 -90度后，原始的 Y 变成了世界的 -Z 距离
                
                // 弯曲公式：x偏移 = 曲率 * 距离的平方
                // 距离越远，偏移越大，形成弯曲视觉
                float distortion = uCurve * dist * dist * 0.0005;
                
                pos.x += distortion;

                vDepth = dist;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const roadFragmentShader = `
            uniform vec3 uColor;
            varying vec2 vUv;
            varying float vDepth;

            void main() {
                // 生成网格
                float gridX = step(0.95, fract(vUv.x * 20.0)); // 20条车道线
                float gridY = step(0.95, fract(vUv.y * 10.0)); // 横线
                
                // 道路边缘发光
                float edge = smoothstep(0.4, 0.5, abs(vUv.x - 0.5));
                
                // 中间虚线
                float centerLine = step(0.49, vUv.x) * step(vUv.x, 0.51) * step(0.5, fract(vUv.y * 5.0));

                vec3 color = uColor * (gridX * 0.3 + gridY * 0.3 + centerLine);
                color += uColor * edge * 2.0; // 边缘更亮

                // 远处的淡出效果
                float alpha = 1.0 - smoothstep(0.0, 800.0, vDepth);

                gl_FragColor = vec4(color, alpha);
            }
        `;

        // 创建高密度平面的路，以便 Shader 能平滑弯曲顶点
        // 宽 100，长 1000，宽分段 20，长分段 200
        const roadGeo = new THREE.PlaneGeometry(100, 1000, 20, 200);
        // 旋转几何体，使其平铺在地面，且原点在近端
        roadGeo.translate(0, 500, 0); // 将中心推远，让 camera 在 0 点刚好在路头
        roadGeo.rotateX(-Math.PI / 2);

        const roadMat = new THREE.ShaderMaterial({
            uniforms: roadUniforms,
            vertexShader: roadVertexShader,
            fragmentShader: roadFragmentShader,
            transparent: true,
            side: THREE.DoubleSide
        });

        const road = new THREE.Mesh(roadGeo, roadMat);
        scene.add(road);


        // =========================================
        // 4. 场景物体 (粒子星空)
        // =========================================
        // 简单的星空，随车漂移
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 2000;
        const posArray = new Float32Array(starsCount * 3);
        for(let i=0; i<starsCount*3; i++) {
            posArray[i] = (Math.random() - 0.5) * 600;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.8, transparent: true, opacity: 0.5});
        const starField = new THREE.Points(starsGeo, starsMat);
        scene.add(starField);


        // =========================================
        // 5. 逻辑控制与物理
        // =========================================
        
        // 键盘控制
        const keys = { left: false, right: false };
        window.addEventListener('keydown', (e) => {
            if(e.code === 'ArrowLeft' || e.key === 'a') keys.left = true;
            if(e.code === 'ArrowRight' || e.key === 'd') keys.right = true;
        });
        window.addEventListener('keyup', (e) => {
            if(e.code === 'ArrowLeft' || e.key === 'a') keys.left = false;
            if(e.code === 'ArrowRight' || e.key === 'd') keys.right = false;
        });

        // 弯道生成函数 (使用简单的正弦波叠加)
        function getTrackCurve(zPos) {
            // zPos 是行驶距离
            // 基础大弯 + 快速小弯
            // 结果范围约 -1 (左) 到 1 (右)
            const baseCurve = Math.sin(zPos * 0.001); // 长直道/长弯道
            const sharpCurve = Math.sin(zPos * 0.003) * 0.5; // 急弯
            
            // 只有当 baseCurve 较大时才加入 sharpCurve，制造复杂路况
            let total = baseCurve; 
            if (Math.abs(baseCurve) > 0.5) total += sharpCurve;
            
            return total;
        }

        function updatePhysics(dt) {
            // 1. 输入处理
            if (STATE.controlMode === 'keyboard') {
                if (keys.left) STATE.targetSteering = -1;
                else if (keys.right) STATE.targetSteering = 1;
                else STATE.targetSteering = 0;
            }

            // 2. 速度处理
            if (STATE.speed < CONFIG.maxSpeed) {
                STATE.speed += CONFIG.acceleration;
            } else {
                STATE.speed = CONFIG.maxSpeed;
            }

            // 撞墙检测与惩罚
            const trackWidthLimit = CONFIG.roadWidth / 2 - 2;
            if (Math.abs(STATE.playerOffset) > trackWidthLimit) {
                STATE.speed *= 0.95; // 减速
                STATE.playerOffset = Math.sign(STATE.playerOffset) * trackWidthLimit; // 限制位置
                // 屏幕震动效果可在此添加
            }

            // 3. 移动距离
            // 转换为场景单位
            const moveDist = (STATE.speed / 20) * dt * 10;
            STATE.distance += moveDist;

            // 4. 弯道逻辑
            // 获取当前应该的曲率
            const targetCurve = getTrackCurve(STATE.distance) * 2.0; // 放大系数
            // 平滑过渡当前曲率 (Lerp)
            STATE.currentCurve += (targetCurve - STATE.currentCurve) * 0.02;

            // 将曲率传给 Shader (控制视觉弯曲)
            roadUniforms.uCurve.value = STATE.currentCurve;
            // 滚动纹理
            roadUniforms.uSpeedOffset.value += moveDist * 0.005;

            // 5. 车辆物理 (转向 + 离心力)
            // 转向平滑
            STATE.steering += (STATE.targetSteering - STATE.steering) * CONFIG.steerSens;

            // 玩家横向移动 = 主动转向 - 道路弯曲带来的离心力
            // 离心力：如果路向右弯 (curve > 0)，车如果不动，相对路来说就是向左偏
            const lateralMove = (STATE.steering * 1.2) * moveDist * 0.15;
            const centrifugalForce = STATE.currentCurve * moveDist * 0.15; 
            
            STATE.playerOffset += lateralMove;
            STATE.playerOffset -= centrifugalForce; // 必须反向抵消离心力才能保持在路中间

            // 6. 相机更新
            // 相机 X 位置即玩家横向位置
            camera.position.x = STATE.playerOffset;
            
            // 相机旋转：结合玩家转向和道路弯曲
            // 玩家转向时，镜头稍微偏转
            // 道路弯曲时，镜头也要看向弯道深处 (Look ahead)
            const lookAheadAngle = -STATE.currentCurve * 0.5; // 看向弯道
            const steerAngle = -STATE.steering * 0.1;
            
            camera.rotation.z = steerAngle; // 侧倾 (Roll)
            camera.rotation.y = lookAheadAngle + steerAngle * 0.5; // 偏航 (Yaw)

            // 粒子更新 (制造速度感)
            const starsPos = starField.geometry.attributes.position.array;
            for(let i=2; i<starsPos.length; i+=3) {
                starsPos[i] += moveDist * 1.5;
                if(starsPos[i] > 50) starsPos[i] = -550; // 循环
            }
            starField.geometry.attributes.position.needsUpdate = true;
            // 粒子整体稍微跟随弯道旋转，增加沉浸感
            starField.rotation.y = lookAheadAngle * 0.2;

            // UI 更新
            STATE.displaySpeed = Math.floor(STATE.speed);
            UI.speed.innerText = STATE.displaySpeed;
            UI.wheel.style.transform = `rotate(${STATE.steering * 90}deg)`;
            
            // 弯道提示
            if (Math.abs(STATE.currentCurve) > 0.8) {
                UI.warning.style.opacity = '1';
                UI.warning.innerText = STATE.currentCurve > 0 ? ">>> RIGHT TURN >>>" : "<<< LEFT TURN <<<";
                UI.warning.style.color = STATE.currentCurve > 0 ? "#00f3ff" : "#d200ff";
            } else {
                UI.warning.style.opacity = '0';
            }
        }

        // =========================================
        // 6. 手势识别 (MediaPipe)
        // =========================================
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // 性能优先
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                UI.handDot.classList.add('active');
                STATE.controlMode = 'hand';
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                const middleFinger = landmarks[9];
                
                // 计算 x 差值 (-1 ~ 1)
                const dx = middleFinger.x - wrist.x;
                
                // 放大并反向 (符合直觉：手往左倒 -> 车往左转)
                // MediaPipe 镜像后，手往左倒 dx 为负
                let steer = dx * 5.0; 
                STATE.targetSteering = Math.max(-1, Math.min(1, -steer)); 
            } else {
                UI.handDot.classList.remove('active');
                STATE.controlMode = 'keyboard';
            }
        });

        const cameraUtils = new Camera(UI.video, {
            onFrame: async () => { await hands.send({image: UI.video}); },
            width: 320, height: 240
        });

        cameraUtils.start().then(() => {
            UI.camDot.classList.add('active');
            UI.loader.style.opacity = '0';
            setTimeout(() => UI.loader.style.display = 'none', 500);
        });

        // =========================================
        // 7. 渲染循环
        // =========================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            roadUniforms.uTime.value += dt;
            updatePhysics(dt);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
