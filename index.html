<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Tarot - True Immersion</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg-color: #000000;
            --tech-green: #00ff9d;
            --card-width: 240px; 
            --card-height: 400px;
            /* 关键修改：极大的半径，形成包裹感 */
            --radius: 1100px; 
        }

        body {
            margin: 0;
            background: var(--bg-color);
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: none;
            /* 关键修改：视距略小于半径，创造广角镜头感 */
            perspective: 800px; 
        }

        /* 画布层 */
        canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #bg-canvas { z-index: 0; }
        #effect-canvas { z-index: 60; }
        #hand-canvas { z-index: 70; opacity: 0.8; }

        /* 1. 世界容器 */
        /* 这个容器就是你的头，旋转它就是转头 */
        #world-container {
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            transform-style: preserve-3d;
            z-index: 10;
        }

        .card-wrapper {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            left: calc(var(--card-width) * -0.5);
            top: calc(var(--card-height) * -0.5);
            transform-style: preserve-3d;
            /* 卡牌背面不可见，优化性能且符合物理 */
            backface-visibility: hidden; 
        }

        .card-face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0,0,0,0.95); /* 更深的阴影 */
        }

        .card-back {
            background: #050505;
            border: 2px solid #333;
            display: flex; justify-content: center; align-items: center;
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.2s;
        }
        /* 卡背纹理 */
        .card-back::after {
            content: ''; position: absolute; top: 10px; left: 10px; right: 10px; bottom: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* 锁定状态：稍微拉近，产生对焦感 */
        .card-wrapper.locked .card-back {
            border-color: var(--tech-green);
            box-shadow: 0 0 80px var(--tech-green), inset 0 0 20px var(--tech-green);
            transform: scale(1.1) translateZ(50px); /* 向圆心（你）靠近 */
        }

        .card-front {
            background: #111;
            transform: rotateX(180deg);
        }
        .card-front img { width: 100%; height: 100%; object-fit: cover; border-radius: 12px; }

        /* 2. 抽出的卡牌 (UI Overlay) */
        #active-card {
            position: fixed;
            width: var(--card-width);
            height: var(--card-height);
            /* 初始隐藏，位置由JS动态计算 */
            top: 0; left: 0;
            transform-style: preserve-3d;
            z-index: 100;
            display: none;
            pointer-events: none;
        }
        
        #active-card .inner {
            width: 100%; height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #active-card.flipped .inner {
            transform: rotateX(180deg);
        }

        /* 沉浸感遮罩 */
        #vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, #000 100%);
            pointer-events: none; z-index: 50;
        }
        
        #status-text {
            position: fixed; bottom: 15%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-size: 14px; letter-spacing: 4px;
            text-shadow: 0 0 10px #000; z-index: 80;
        }

        #webcam { display: none; }
    </style>
</head>
<body>

    <div id="status-text">SYSTEM READY // YOU ARE THE CENTER</div>
    <div id="vignette"></div>

    <canvas id="bg-canvas"></canvas>
    <canvas id="effect-canvas"></canvas>
    <canvas id="hand-canvas"></canvas>
    
    <div id="world-container"></div>
    
    <div id="active-card">
        <div class="inner">
            <div class="card-face card-back"></div>
            <div class="card-face card-front"><img id="active-img" src=""></div>
        </div>
    </div>

    <video id="webcam" autoplay playsinline></video>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js";

        // 24张牌，确保圆环足够密集，包围感更强
        const tarotImages = [
            "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Wands05.jpg/352px-Wands05.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/RWS_Tarot_07_Chariot.jpg/353px-RWS_Tarot_07_Chariot.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/RWS_Tarot_08_Strength.jpg/344px-RWS_Tarot_08_Strength.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Swords03.jpg/347px-Swords03.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/TheLovers.jpg/337px-TheLovers.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/RWS_Tarot_13_Death.jpg/327px-RWS_Tarot_13_Death.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/RWS_Tarot_15_Devil.jpg/337px-RWS_Tarot_15_Devil.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/RWS_Tarot_16_Tower.jpg/331px-RWS_Tarot_16_Tower.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/RWS_Tarot_17_Star.jpg/340px-RWS_Tarot_17_Star.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/RWS_Tarot_18_Moon.jpg/334px-RWS_Tarot_18_Moon.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/17/RWS_Tarot_19_Sun.jpg/336px-RWS_Tarot_19_Sun.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/ea/RWS_Tarot_20_Judgement.jpg/342px-RWS_Tarot_20_Judgement.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/RWS_Tarot_21_World.jpg/350px-RWS_Tarot_21_World.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Wands05.jpg/352px-Wands05.jpg", 
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/TheLovers.jpg/337px-TheLovers.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/RWS_Tarot_13_Death.jpg/327px-RWS_Tarot_13_Death.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/RWS_Tarot_15_Devil.jpg/337px-RWS_Tarot_15_Devil.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/RWS_Tarot_16_Tower.jpg/331px-RWS_Tarot_16_Tower.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/RWS_Tarot_17_Star.jpg/340px-RWS_Tarot_17_Star.jpg"
        ];

        let handLandmarker;
        const video = document.getElementById("webcam");
        const statusText = document.getElementById("status-text");
        const worldContainer = document.getElementById("world-container");
        const activeCard = document.getElementById("active-card");
        const activeImg = document.getElementById("active-img");
        const handCtx = document.getElementById("hand-canvas").getContext("2d");
        const effectCtx = document.getElementById("effect-canvas").getContext("2d");

        // 视角变量
        let cameraAngle = 0;
        let rotateSpeed = 0;
        const MAX_ROTATE_SPEED = 3.0; // 加快一点转速
        
        // 游戏状态
        let handX = 0.5, handY = 0.5;
        let isPinching = false;
        let pinchLocked = false;
        
        const STATE = { IDLE: 0, GRABBED: 2, DISSOLVING: 3 };
        let gameState = STATE.IDLE;
        
        let cards = [];
        // 半径设定：必须非常大才能把你“包”在里面
        const RADIUS = 1100; 
        const ANGLE_STEP = 360 / tarotImages.length;

        async function init() {
            // 1. 构建世界
            tarotImages.forEach((url, i) => {
                const el = document.createElement("div");
                el.className = "card-wrapper";
                el.innerHTML = `<div class="card-face card-back"></div>`; 
                worldContainer.appendChild(el);
                
                const angle = i * ANGLE_STEP;
                // 关键修正：先旋转Y轴(决定方向)，再推向Z轴(半径)
                // 这样卡牌的背面是朝向圆心的（朝向你）
                el.style.transform = `rotateY(${angle}deg) translateZ(${RADIUS}px)`;
                
                cards.push({ el, angle, url });
            });

            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
            video.srcObject = stream;
            video.addEventListener("loadeddata", () => {
                resizeCanvas();
                animate();
                predict();
            });
        }

        let lastVideoTime = -1;
        async function predict() {
            let now = performance.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, now);
                
                handCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);

                if (results.landmarks && results.landmarks.length > 0) {
                    const lm = results.landmarks[0];
                    drawSkeleton(lm);

                    const indexTip = lm[8];
                    const thumbTip = lm[4];
                    handX = 1 - indexTip.x;
                    handY = indexTip.y;
                    
                    const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    isPinching = dist < 0.05;

                    handleInput();
                } else {
                    rotateSpeed *= 0.95; // 缓慢减速
                    isPinching = false;
                    unlockCard();
                }
            }
            requestAnimationFrame(predict);
        }

        /* --- 交互逻辑 --- */
        let lockedCardIndex = -1;

        function handleInput() {
            if (gameState === STATE.GRABBED) {
                handleGrabbed();
                return;
            }

            // 1. 旋转控制 (头控)
            // 手势区域：0.3 (左) --- 0.7 (右)
            if (handX < 0.3) {
                const strength = (0.3 - handX) / 0.3;
                rotateSpeed = -strength * MAX_ROTATE_SPEED; 
                statusText.innerText = "<<< TURNING LEFT";
            } else if (handX > 0.7) {
                const strength = (handX - 0.7) / 0.3;
                rotateSpeed = strength * MAX_ROTATE_SPEED;
                statusText.innerText = "TURNING RIGHT >>>";
            } else {
                rotateSpeed = 0;
            }

            // 2. 锁定检测
            // 只有停止旋转且手在中间
            if (Math.abs(rotateSpeed) < 0.1 && handX >= 0.3 && handX <= 0.7) {
                statusText.innerText = "LOCKED // PINCH TO EXTRACT";
                rotateSpeed = 0;

                // 计算视线正前方的卡牌
                // cameraAngle 是世界旋转的角度。正前方就是 -cameraAngle
                let facingAngle = -cameraAngle % 360;
                if (facingAngle < 0) facingAngle += 360;

                // 寻找最接近 facingAngle 的卡牌
                let closestIdx = -1;
                let minDiff = 1000;

                cards.forEach((card, i) => {
                    // 处理环形角度差 (比如 359度 和 1度 差2度)
                    let diff = Math.abs(card.angle - facingAngle);
                    if (diff > 180) diff = 360 - diff;
                    
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIdx = i;
                    }
                });

                // 容差范围 10度，且食指指向屏幕中央
                if (minDiff < 10 && handY > 0.2 && handY < 0.8) {
                    lockCard(closestIdx);
                } else {
                    unlockCard();
                }
            } else {
                unlockCard();
            }

            if (!isPinching) pinchLocked = false;
        }

        function lockCard(index) {
            if (lockedCardIndex !== index) {
                unlockCard();
                lockedCardIndex = index;
                cards[index].el.classList.add('locked');
            }
            if (isPinching && !pinchLocked) {
                extractCard(index);
            }
        }

        function unlockCard() {
            if (lockedCardIndex !== -1) {
                cards[lockedCardIndex].el.classList.remove('locked');
                lockedCardIndex = -1;
            }
        }

        function extractCard(index) {
            gameState = STATE.GRABBED;
            pinchLocked = true;
            statusText.innerText = "FATE REVEALED";

            const data = cards[index];
            activeImg.src = data.url;
            activeCard.style.display = 'block';
            
            // 隐藏原卡牌
            data.el.style.opacity = 0;

            // 翻转动画
            setTimeout(() => activeCard.classList.add('flipped'), 50);
        }

        function handleGrabbed() {
            // 卡牌跟随
            const x = handX * window.innerWidth;
            const y = handY * window.innerHeight;
            activeCard.style.transform = `translate(${x - 120}px, ${y - 200}px) scale(1.1)`;

            if (!isPinching) {
                dissolve();
            }
        }

        function dissolve() {
            gameState = STATE.DISSOLVING;
            const rect = activeCard.getBoundingClientRect();
            spawnParticles(rect.left + rect.width/2, rect.top + rect.height/2);
            
            activeCard.style.display = 'none';
            activeCard.classList.remove('flipped');

            if (lockedCardIndex !== -1) {
                const el = cards[lockedCardIndex].el;
                setTimeout(() => {
                    el.style.opacity = 1;
                    el.classList.remove('locked');
                }, 300);
            }
            
            setTimeout(() => {
                gameState = STATE.IDLE;
                lockedCardIndex = -1;
            }, 500);
        }

        function animate() {
            // 旋转世界
            cameraAngle += rotateSpeed;
            worldContainer.style.transform = `rotateY(${cameraAngle}deg)`;
            
            updateParticles();
            requestAnimationFrame(animate);
        }

        /* --- 视觉特效 --- */
        let particles = [];
        function spawnParticles(x, y) {
            for(let i=0; i<80; i++) {
                const a = Math.random()*Math.PI*2, v = Math.random()*15+5;
                particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,life:1,color:'#00ff9d'});
            }
        }
        function updateParticles() {
            effectCtx.clearRect(0,0,window.innerWidth,window.innerHeight);
            for(let i=particles.length-1;i>=0;i--) {
                let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=0.03;
                if(p.life<=0) particles.splice(i,1);
                else { effectCtx.globalAlpha=p.life; effectCtx.fillStyle=p.color; effectCtx.beginPath(); effectCtx.arc(p.x,p.y,2,0,Math.PI*2); effectCtx.fill(); }
            }
            effectCtx.globalAlpha=1;
        }

        const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]];
        function drawSkeleton(lm) {
            handCtx.lineWidth = 2; handCtx.lineCap = "round";
            handCtx.strokeStyle = "rgba(0, 255, 157, 0.4)";
            connections.forEach(([i,j])=>{
                const p1=lm[i],p2=lm[j];
                handCtx.beginPath();
                handCtx.moveTo((1-p1.x)*window.innerWidth,p1.y*window.innerHeight);
                handCtx.lineTo((1-p2.x)*window.innerWidth,p2.y*window.innerHeight);
                handCtx.stroke();
            });
            const cx=(1-lm[8].x)*window.innerWidth, cy=lm[8].y*window.innerHeight;
            handCtx.beginPath(); handCtx.arc(cx,cy,6,0,Math.PI*2); handCtx.fillStyle=isPinching?"#fff":"#00ff9d"; handCtx.fill();
        }

        function resizeCanvas() {
            const w=window.innerWidth, h=window.innerHeight;
            document.getElementById("bg-canvas").width=w; document.getElementById("bg-canvas").height=h;
            document.getElementById("effect-canvas").width=w; document.getElementById("effect-canvas").height=h;
            document.getElementById("hand-canvas").width=w; document.getElementById("hand-canvas").height=h;
        }
        window.onresize = resizeCanvas;

        init();
    </script>
</body>
</html>
